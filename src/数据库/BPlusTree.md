
<!--toc:start-->
- [B+树的一些基本操作](#b树的一些基本操作)
  - [插入](#插入)
    - [找到插入位置](#找到插入位置)
    - [插入新元素](#插入新元素)
    - [节点分裂](#节点分裂)
    - [递归调整](#递归调整)
  - [删除](#删除)
    - [找到要删除的元素](#找到要删除的元素)
    - [删除元素](#删除元素)
    - [借节点或合并](#借节点或合并)
    - [递归调整](#递归调整)
<!--toc:end-->

# B+树的一些基本操作

## 插入

### 找到插入位置

1. 从根节点开始，根据键值查找合适的叶子节点。
2. 在B+树中，叶子节点按照键值的顺序排列，因此在插入时，可以从根节点开始遍历，直到到达叶子节点。
3. 对于每个内部节点，根据当前键值选择合适的子树指针向下递归。

### 插入新元素
1. 一旦到达叶子节点，在合适的位置插入新键值。

2. 如果插入后叶子节点的键值数量没有超过树的最大容量（通常是一个固定的上限m），那么插入操作就结束了。

3. 如果插入后叶子节点的键值数量超过了上限，需要进行分裂。

### 节点分裂
1. 如果叶子节点满了（即它包含m个键值），就需要分裂这个节点。

2. 新节点会生成一个新的叶子节点，并将当前节点的部分键值移动到新节点中。

3. 分裂过程中，中间的键值会被提取到父节点中，作为指向新节点的指针。

4. 如果父节点也满了，需要递归分裂父节点，直到树的根节点，可能会导致树的高度增加。

### 递归调整

1. 分裂操作可能会影响到父节点，因此父节点需要插入新生成的键值和指针。
2. 如果父节点满了，继续递归分裂。此过程直到根节点，如果根节点分裂，树的高度增加，新的根节点将包含一个指向新根的指针。

## 删除

### 找到要删除的元素

1. 从根节点开始，找到包含要删除元素的叶子节点。

### 删除元素

1. 在叶子节点中删除指定的键值。
2. 如果删除后，叶子节点的键值数量不小于树的最小容量（通常是⌈m/2⌉），那么删除操作结束。
3. 如果删除后，叶子节点的键值数量小于最小容量，则需要进行借节点或者合并操作。

### 借节点或合并

1. 借节点：如果兄弟节点（左兄弟或右兄弟）有多余的元素（即超过了最小容量），则可以从兄弟节点借一个元素来维持当前节点的容量。
2. 合并节点：如果兄弟节点没有多余的元素，则需要将当前节点与兄弟节点合并。合并过程中，父节点相应的指针也需要调整，可能会导致父节点的键值删除。

### 递归调整

1. 合并或借节点可能会影响父节点。如果父节点的子树数量小于最小容量，就需要继续进行合并或借节点操作，直到根节点。
2. 如果根节点的唯一子节点被合并或删除，树的高度会减少，根节点的指针会指向新的子节点。
