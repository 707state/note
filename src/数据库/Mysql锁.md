# Mysql锁机制

MySQL当中有三种锁：
- 全局锁
- 表级锁
- 行锁

## 什么是全局锁

```sql
flush table with read lock
```
就会让整个数据库处于只读状态，这时在其它线程执行对数据的增删改/对表结构的更改都会被阻塞。

```sql
unlock tables
```
能够释放全局锁。

### 应用场景

主要用于全库逻辑备份。

#### 如果避免性能下降？
如果数据库的引擎支持可重复读的隔离级别，在备份数据库之前开启事务，会先创建ReadView，然后再事执行期间都用这个ReadView，而且由于MVCC的支持，备份期间业务依然可以对数据进行更新操作。
## 表级锁

### 表锁
表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。

表锁的颗粒度太大，会影响并发性能，所以InnoDB实现了颗粒度更细的行级锁。

### 元数据锁

我们不需要显式的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：
- 对一张表进行CRUD操作时，加的是MDL读锁；
- 对一张表做结构变更操作时，加的是MDL写锁。

MDL实在事务提交之后才会释放，也就是说，事务执行期间，MDL是一直持有的。

_写锁获取优先级高于读锁_。

### 意向锁

在对某些记录加上共享/独占锁之前，InnoDB会先加上一个意向共享/独占锁。

也就是在执行更新/插入/删除都会对表加上意向独占锁，再去加锁。

意向共享/独占锁是表级锁，不会和行级的共享锁/独占锁发生冲突，意向锁之间也不会发生冲突，只会和共享表锁/独占表锁发生冲突。

意向锁的目的就是为了快速判断表里是否有记录被加锁。

### AUTO-INC锁

表里的主键通常都会被设置为自增的，这主要是通过对主键字段声明AUTO_INCREMENT属性实现的。

AUTO-INC锁是特殊的表锁机制，锁不再是一个事务提交后才释放，而是在执行完插入语句后就会释放。

插入数据是会加一个表级别的AUTO-INC锁。

## 行级锁

如果要在查询时，对记录加行级锁，就可以用:
```sql
select ... lock in share mode;

select ... for update;
```

这种查询会加锁的方式叫做锁定读。

当事务提交了，锁就会被释放。

行级锁主要有三类：
- Record Lock 记录锁：仅仅把一条记录锁上。
- Gap Lock 间隙锁：锁定一个范围，但不包含记录本身。
- Next-Key Lock: Record Lock + Gap Lock组合，锁定一个范围，并且锁定记录本身。

### Record Lock

锁住的是一条记录，记录锁有S锁和X锁之分。

S锁与S锁兼容，与X锁不兼容。

X锁与X锁不兼容。

### Gap Lock

Gap Lock称为间隙锁，只存在于可重复读隔离级别中，目的是为了解决可重复读隔离级别下幻读的现象。

间隙锁之间是兼容的，两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入phantom record而提出的。

### Next-Key Lock

既能保护该记录，又能够阻止其他事务将新纪录插入到被保护记录的前面的间隙中。

next-key lock是包含间隙锁和记录锁的，如果一个事务获取了X型的next-key lock，那么另外一个事务在获取相同范围的X型记录的next-key lock时会被阻塞。

### 插入意向锁

一个事务在插入一条记录的时候，需要判断插入位置是否已经被其他事务加了间隙锁。

如果有，那么插入操作就会发生阻塞，直到持有锁的事务提交为止，在此期间就会生成一个插入意向锁，表明有事务想在某个区间插入新纪录。

所以插入意向锁并不是意向锁，而是一种特殊的间隙锁，属于行级别锁。

# MySQL是怎么加行锁的？

加锁的对象是索引，加锁的基本单位是next-key lock，有记录锁和间隙锁组合而成，next-key lock是前开后闭区间，而间隙锁是前开后开区间。

在能使用记录锁或者间隙锁就能避免幻读的情况下，next-key lock就会退化成记录锁或者间隙锁。

## 唯一索引等值查询

- 当查询的记录是存在时，在索引上定位到这一条记录后，将该记录的索引中的next-key lock会退化成记录锁；
- 当查询的记录是不存在的，在索引树找到第一条大于该查询的记录的记录后，该记录的索引中的next-key lock就退化成间隙锁。

## 唯一索引范围查询

对每一个扫描到的索引加next-key lock，如果遇到下面的情况，就会退化成记录锁或者间隙锁：
- 针对大于等于的范围查询，因为存在等值查询的条件，那么如果等值查询的记录存在于表中，那么该记录的索引中的next-key lock锁会退化成记录锁。
- 针对小于或者小于等于的范围查询，要看条件值是否存在于表中：
1. 条件值的记录不再表中，那不管是什么条件，扫描到终止范围查询的记录时，该记录的索引的next-key lock会退化成间隙锁。
2. 如果条件值的记录在表中，如果是小于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的next-key lock会退化成间隙锁。其他扫描到的记录，都是在索引上加next-key lock；如果是小于等于条件，扫描到终止范围查询的记录时，该记录的索引next-key lock不会退化成间隙锁。其他扫描到的记录都是在这些记录的索引上加next-key lock。

## 非唯一索引等值查询

因为存在两个索引，一个是主键索引，一个是二级索引，所以在加锁时会对这两个索引都加锁，但是对主键索引加锁时，只有满足查询条件的记录才会对他们的主键索引加锁。

针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也不相同：

1. 非唯一索引等值查询的过程是一个扫描的过程，知道扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引的记录加的是next-key 锁，而对于第一个不符合条件的二级索引的记录，该二级索引的next-key lock会退化为间隙锁，同时，在符合查询条件的记录的主键索引加上记录锁。
2. 当查询的记录不存在的时候，扫描到的第一条不符合条件的二级索引记录，该二级索引的next-key lock会退化成间隙锁，因为不存在满足查询条件的记录，所以不会对主键索引加锁。

## 非唯一索引范围查询

非唯一索引范围查询，索引的next-key lock不会退化为间隙锁和记录锁的情况。

也就是说，非唯一索引范围查询时，对二级索引都是加next-key lock。

## MySQL死锁

### 为什么会有死锁？

InnoDB引擎为了解决可重复读隔离级别下的幻读问题，就引出了next-key lock。

插入意向锁与间隙锁是冲突的，所以当其他食物持有该间隙的间隙锁时，需要等待其他事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以两个事务中select ... for update语句并不会受影响。

### 为什么间隙锁和间隙锁之间是兼容的？

间隙锁的意义只在于阻止区间被插入，因此可以共存。一个事务获取的间隙锁并不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，互补冲突，且功能相同。

但是注意，X型next-key lock是没有兼容性的。

### 插入意向锁

插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，这个锁只用于并发插入操作。

插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。

### insert语句是怎么加行级锁的？

Insert语句在正常执行时，不会生成锁结构，它是靠聚簇索引记录自带的trx_id隐藏列来作为隐式锁来保护记录。

#### 什么是_隐式锁_？

当食物需要加锁的时候，如果这个锁不可能发生冲突，InnoDB就会跳过加锁环节，这种机制被称为隐式锁。

隐式锁是InnoDB实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。

隐式锁就是在Insert过程中不加锁，只有在特殊情况下才会将隐式锁转换为显式锁。

特殊情形：

1. 如果记录之间有间隙锁，为了避免幻读，此时不能插入记录；
2. 如果Insert的记录和只有记录存在唯一键冲突，此时也不能插入记录。

在第二种情形下，有两种可能：

- 主键索引冲突：在冲突的记录上加一个S型记录锁；
- 唯一二级索引冲突：在冲突的记录上加一个next-key lock。

并发多个事务时，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。
