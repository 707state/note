<!--toc:start-->
- [索引的种类](#索引的种类)
  - [按数据结构分](#按数据结构分)
    - [通过主键索引查询数据](#通过主键索引查询数据)
    - [通过二级索引查询数据](#通过二级索引查询数据)
    - [为什么MySQL InnoDB选择B+树作为索引的数据结构？](#为什么mysql-innodb选择b树作为索引的数据结构)
  - [按物理存储分](#按物理存储分)
  - [按字段特性分](#按字段特性分)
  - [按字段个数分](#按字段个数分)
    - [联合索引范围查询](#联合索引范围查询)
  - [索引区分度](#索引区分度)
  - [索引优化方法](#索引优化方法)
- [数据页](#数据页)
  - [User Record怎么存储数据？](#user-record怎么存储数据)
  - [InnoDB是如何给记录创建页目录的呢？](#innodb是如何给记录创建页目录的呢)
    - [B+树如何进行查询的？](#b树如何进行查询的)
    - [聚簇索引和二级索引](#聚簇索引和二级索引)
- [MySQL为什么采用B+树作为索引？](#mysql为什么采用b树作为索引)
  - [什么是最左匹配？](#什么是最左匹配)
  - [为什么联合索引不遵循最左匹配原则就会失效？](#为什么联合索引不遵循最左匹配原则就会失效)
- [补充知识](#补充知识)
  - [什么是索引？](#什么是索引)
  - [索引的优缺点](#索引的优缺点)
    - [优点](#优点)
    - [缺点](#缺点)
  - [MySQL的索引类型](#mysql的索引类型)
  - [为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？](#为什么索引结构默认使用btree而不是b-treehash二叉树红黑树)
    - [B树 vs B+树](#b树-vs-b树)
    - [B+树 vs 哈希表](#b树-vs-哈希表)
    - [B+树 vs 二叉树](#b树-vs-二叉树)
    - [B+树 vs 红黑树](#b树-vs-红黑树)
    - [总结](#总结)
<!--toc:end-->

# 索引的种类

## 按数据结构分
B+树索引、Hash索引、Full-Text索引。

在创建表的时候，InnoDB会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

其余的索引都是辅助索引（Secondary Index），又叫做二级索引/非聚簇索引。创建的主键索引和二级索引默认使用的是B+Tree索引。

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

### 通过主键索引查询数据

数据库的索引和数据都是存储在磁盘的，可以把读取一个节点当作一次磁盘I/O操作。一般来说，Mysql存储千万级数据只需要3-4层高度就可以满足，也就是说_B+树相对于B树和二叉树来说，最大的优势是查询效率很高，因为即使数据量很大，查询一个数据依然能够把磁盘I/O维持在3-4次_

### 通过二级索引查询数据

二级索引放的是主键值而不是实际数据，也就是说，使用二级索引查找时，先检索二级索引中的B+Tree的索引值，找到对应的叶子节点，然后获取主键值，在通过主键索引的B+Tree找到对应的叶子节点，然后获取整行数据，这个过程叫做回表，也就是说要查两个B+Tree才能查到数据。

如果要查询的数据能够直接从二级索引的叶子节点中获得是，就不用再到主键索引里面去找，这种能直接在二级索引找到数据的过程叫做覆盖索引。

### 为什么MySQL InnoDB选择B+树作为索引的数据结构？

1. B+树 VS B 树

B+树只在叶子节点存储数据，而B树的非叶子节点也存储数据，所以B+树的单个节点的数据量更小，在相同的磁盘IO此树下，能够查询更多节点。

另外，B+树采用的是双链表连接，适合MySQL中基于范围的顺序查找，这是B树做不到的。

2. B+树 VS 二叉树

对于有N个叶子节点的B+Tree, 搜索复杂度为 O(log d * N)，d为节点允许的最大子节点个数。

这就让B+树的层数不会太深，而二叉树的深度会非常大。

3. B+树 VS 哈希

哈希表往往采用自平衡二叉树（有序）或者Hash Table（无序）的方法，对于等值查询非常方便，但是对于范围查询性能就很差。

## 按物理存储分
聚簇索引（主键索引）、二级索引（辅助索引）

区别：
- 主键索引的叶子节点存放的是实际数据，所有完整的记录都放在其中；
- 二级索引的B+叶子节点存放的是主键值。

## 按字段特性分
主键索引、唯一索引、普通索引、前缀索引

主键索引：建立在主键字段上的索引，最多一个；

唯一索引：建立在UNIQUE字段上的值，一张表可以有多个唯一索引，索引列的值必须唯一，但可以有空。

普通索引：建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE。

前缀索引：建立在字符类型的字段前几个字符上的索引，而不是在整个字段上建立的索引，对于char, varchar, binary, varbinary都有效。

## 按字段个数分

单列索引、联合索引

联合索引的非叶子节点用两个字段的值作为B+Tree的键，一般是从左到右匹配，这个原则叫做最左匹配。

在使用联合索引进行查询时，如果不遵循最左匹配原则，联合索引就会失效，就无法利用索引快速查询的特性了。

这里需要知道，_利用索引的前提是索引里的key是有序的_。

### 联合索引范围查询

有一些特殊情况，并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询，这种情况发生在范围查询里面。

_范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引_。

一些例子：

1. 如下查询：
```sql
select * from t_table where a > 1 and b = 2;
```
联合索引(a,b)哪一个字段用到了索引的B+Tree？

由于a是最左字段，索引中a是有序的，但是在复合a>1条件的二级索引记录的范围里，b字段的值是无序的。因此不能利用b=2的条件减少需要扫描的记录数量。所以执行语句时对应的扫描区间为(2,+∞)。

2. 如下查询：
```sql
select * from t_table where a >= 1 and b = 2;
```
联合索引(a,b)哪一个字段用到了索引的B+Tree?

这里与1中只有一点区别，就是a的等值查询，但是在a=1范围的字段中，b是有序的，所以在a的字段值为1的地方，可以通过b=1来进行检查，减少扫描范围。也就是说会从a=1 && b=1的字段才开始扫描，而不需要从第一个a=1的字段开始。
3. 如下查询：
```sql
select * from t_table where a between 2 and 8 and b = 2 ;
```

只考虑MySQL, 因为MySQL的between and是左闭右闭区间，所以在边界会用到b的等值查询。

4. 如下查询：
```sql
select * from t_user where name like 'j%' and age = 22 ;
```
联合索引(name, age)哪一个字段用到了B+Tree？

B+Tree的索引是按照name进行排序的，所以前缀为j的记录是相邻的，因此会形成[j,k)的记录。

在边界j仍然是可以用age=22的记录减少扫描量。

## 索引区分度

实际开发中，会把区分度大的字段放置在左面，区分度就是：某个字段column不同值的个数除以表的总行数。

## 索引优化方法

1. 前缀索引优化

使用某个字段中字符串的前几个字符建立索引，能够减少索引字段大小，增加一个索引页中存储的索引值，有效提高索引的查询速度。

局限：

- order by无法利用前缀索引。
- 无法把前缀索引用作覆盖索引。

2. 覆盖索引优化

覆盖索引是说SQL 中query的query的所有字段，在B+Tree的叶子节点上都能找到那些索引，从二级索引中查询的到记录，而不需要用聚簇索引查询获得，可以避免回表操作。

好处：不需要查询出包含整行记录的所有信息。

3. 主键索引最好自增

自增主键能够让插入新记录都是追加操作，不需要重新移动数据；非自增主键需要把数据插入到现有数据页的某个位置，这样可能需要把数据从一个页面复制到另一个，这样的情况叫做页分裂。页分裂会造成大量内存碎片，导致索引结构不紧凑，影响查询效率。

4. 逐渐长度越小，就意味着二级索引的叶子节点越小，这样二级索引占用的空间就越小。

5. 索引最好设置为Not Null

- 避免优化器做索引选择时变得过于复杂。
- 减少NULL值列表占用行格式。

# 数据页

InnoDB的数据是按照数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。

因为默认的数据页的大小为16kb，一次最少从磁盘读取16kb的内容到内存中。

数据页中的内容：

| 名称 | 说明 |
| --- | --- |
| 文件头 | 表示页的信息 |
| 页头 | 页的状态信息 |
| 最小和最大记录 | 两个虚拟的伪记录，分别表示页的最小记录和最大记录 |
| 用户记录 | 存储行记录内容 |
| 空闲空间 | 页中还没被使用的空间 |
| 页目录 | 存储用户记录的相对位置，对记录起到索引作用 |
| 文件尾 | 校验页是否完整 |


在File Header中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表。

采用链表的结构是让数据页之间不需要物理上的连续而是逻辑上的连续。

## User Record怎么存储数据？

数据页中的记录按照主键顺序组成单向链表，特点是插入、删除非常方便，但是检索效率不高，最差需要遍历链表上所有节点。

因此有一个页目录，起到记录的索引作用。

## InnoDB是如何给记录创建页目录的呢？
1. 所有记录划分为几个组，这些记录包括最小记录和最大记录，但不包括标记为'已删除'的记录；
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息会存储该组一共有多少条记录，作为n_owned字段。
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽，每个槽相当于指针指向了不同组的最后一个记录
。

可以看出，页目录就是由很多槽组成的，槽相当于分组记录的索引。然后因为记录是按照主键值从小到大排序的，所以通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽，定位到槽后，在遍历槽内的所有记录，找到对应的记录。

### B+树如何进行查询的？

当我们需要存储的数据量很大时，就需要建立索引，才能方便定位记录。

InnoDB中每个节点都是一个数据页。

特点：

1. 只有叶子节点才存放数据，其他节点仅用来存放目录项作为索引。
2. 非叶子节点非为不同层次，通过分层来降低每一层的搜索量。
3. 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询。

### 聚簇索引和二级索引

索引根据叶子节点存放什么数据，还可以分为聚簇索引/二级索引（非聚簇索引）。

- 聚簇索引的叶子节点存放的是完整的记录
- 二级索引的叶子节点存放的是主键的值

因为表的数据都是存放在聚簇索引的叶子节点里面，所以InnoDB存储引擎一定也会为表创建一个聚簇索引，且由于数据在物理上智慧保存一份，所以聚簇索引只能有一个。

InnoDB在创建聚簇索引时，会根据不同的场景选择不同的不同的列作为索引；

- 如果有主键，默认会使用主键作为聚簇索引的索引键；
- 如果没有主键，就选择第一个不使用NULL值的唯一列作为聚簇索引的索引键；
- 如果上面两个都没有，InnoDB将会自动生成一个隐式自增id列作为聚簇索引的索引键。

一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，基于引出了二级索引，他也是利用了B+树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。

因此，如果某个查询语句使用了二级索引，但是查询的数据不是主键值，就会在二级索引找到主键值之后，需要到聚簇索引中获得数据行，这个过程就叫做回表，也就是说需要两个B+树才能找到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，就不用再去聚簇索引查，这个过程就叫做索引覆盖，也就是只需要查一个B+树就能找到数据。

# MySQL为什么采用B+树作为索引？

1. 单点查询

B树在进行单个索引查询时，最快可以在O(1)查到，而且平均时间代价来看比B+树快一些。

但是因为B树的查询波动比较大，每个节点既存索引又存记录，所以可以在非子节点找到索引，有时需要访问到叶子节点找到索引。

2. 插入和删除效率

B+树有大量的冗余节点，使得删除一个节点的时候直接从叶子节点删除而不用修改非叶子节点。

插入也是一样的，有冗余阶段，插入可能存在节点的分裂，o但是最多只涉及一条路径，并且因为B+树自平衡，就不需要更多复杂的算法，因此，_插入，删除的效率更高_。

3. 范围查询

B+树的所有叶子节点之间还有一个链表进行连接，这种设计对范围查找非常有帮助。

而B树没有这种能力，效率就很低。

但是对于大量单个索引查询的场景，就可以考虑B树。

## 什么是最左匹配？

在使用联合索引的时候，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。

## 为什么联合索引不遵循最左匹配原则就会失效？

在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。

# 补充知识

## 什么是索引？

索引是一种特殊的文件（InnoDB的数据表上的索引是表空间的一个组成部分），包含着数据表里所有记录的引用指针。

## 索引的优缺点

### 优点

1. 可以明显提高查询效率。
2. 大大加快数据的检索速度，这也是创建索引的最主要的原因。
3. 通过使用索引可以在查询的过程中，使用优化隐藏器，提高系统的性能。
4. 通过创建唯一索引，加快表与表之间的连接。

### 缺点

1. 时间方面：创建和维护索引需要耗费时间，当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，会降低增/改/删的效率。
2. 空间方面：索引要占用物理空间。

## MySQL的索引类型

1. 从 **存储结构** 上划分：B树索引，Hash索引，Full-Index索引，R-Tree索引。
2. 从**应用层次**划分：普通索引，唯一索引，复合索引。
   普通索引：一个索引只包含单个列，一个表可以有多个单列索引。
   唯一索引：索引列的值必须唯一，但允许空值。
   复合索引：多列值组成一个索引，专门用于组合索引，其效率大于索引合并。
3. 根据数据的**物理实现方式**与键值的逻辑顺序关系：聚集索引，非聚集索引。
4. 按照**作用字段个数**划分，分成**单列索引**和**联合索引**。

## 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？
在数据库索引结构中，B+树被广泛应用，相比于B树、哈希表、二叉树和红黑树等其他结构，B+树在多方面具有显著优势。以下是详细的对比和原因优化后的解释：
### B树 vs B+树
**时间复杂度**：B树的时间复杂度通常为O(log n)，其中n是节点数。这个复杂度是基于B树的高度与节点数的对数关系得出的。B树通过保持节点的平衡（即所有叶子节点位于同一层）来确保高效的搜索性能。
**B树**：

1. **节点数据存储**：B树的非叶子节点和叶子节点都存储数据，这导致非叶子节点的指针数量减少（也称为扇出变少）。在存储大量数据时，为了保持树的平衡，必须增加树的高度，从而增加I/O操作次数，降低查询性能。

**B+树**：
**时间复杂度**：B+树的时间复杂度同样为O(log n)，但在某些情况下可能会表现为O(log m * log n)，其中m是节点的最大分支数。这种复杂度主要出现在考虑磁盘I/O操作的场景下。然而，在内存操作中，B+树的查询时间复杂度通常仍为O(log n)。

1. **磁盘读写代价低**：B+树的内部节点仅存储键值和子节点指针，而不存储具体数据。因此，内部节点更小，可以在一个盘块中存储更多的键值和指针。一旦读入内存，可以查找更多关键字，从而减少I/O操作次数。
2. **数据存储在叶子节点**：所有数据都存储在叶子节点，非叶子节点只存储索引信息。这样，数据的扫描和区间查询只需遍历叶子节点链表即可，不需要遍历整个树结构。这使得B+树更加适合范围查询。
3. **扇出更大**：由于非叶子节点更小，B+树的扇出更大，树的高度更低，从而减少I/O操作。
### B+树 vs 哈希表
**哈希表**：

1. **快速定位但无顺序**：哈希表可以在O(1)时间内进行等值查询，但不支持范围查询和有序访问，无法利用索引完成排序操作。
2. **I/O复杂度高**：哈希表在存储和检索时需要频繁进行哈希计算，I/O复杂度高。
3. **不支持部分匹配**：哈希索引必须匹配所有索引列，不能进行部分匹配查找。
4. **哈希碰撞问题**：大量重复键值会导致哈希碰撞，降低查询效率。
### B+树 vs 二叉树
**二叉树**：

1. **高度不均匀**：普通二叉树无法自平衡，随着数据量增加，树的高度可能变得不均匀，导致查询效率下降。
2. **I/O代价高**：树的高度增加会导致更多的I/O操作，影响性能。
### B+树 vs 红黑树
**时间复杂度**：红黑树的时间复杂度为O(log n)。这是因为它通过一系列旋转操作来维持树的平衡，确保树的高度保持在log n级别。
**红黑树**：

1. **树高度增加**：红黑树的高度随着数据量增加而增加，即使它是自平衡的，树的高度也相对较高。
2. **I/O代价高**：红黑树在存储大规模数据时，其I/O操作复杂度较高。
### 总结
**不使用平衡二叉树的主要原因**：

1. **深度太大**：平衡二叉树的每个节点最多只有两个子节点，导致树的深度较大。B+树由于扇出较大，深度较低，I/O复杂度为O(log_mN)。
2. **物理位置分散**：平衡二叉树的父子节点在逻辑上很近，但在物理存储上可能相距较远，无法充分利用磁盘顺序读和预读的高效特性。

综上所述，B+树在数据库索引中被广泛应用，因为它在**减少磁盘I/O次数、支持高效范围查询、存储密度高等方面具有显著优势**。相比于其他数据结构，B+树更能满足数据库系统对高效数据存储和检索的需求。
