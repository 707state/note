<!--toc:start-->
- [几种进程间通信机制](#几种进程间通信机制)
  - [管道](#管道)
  - [消息队列](#消息队列)
  - [共享内存](#共享内存)
  - [信号量](#信号量)
  - [信号](#信号)
  - [Socket](#socket)
- [进程间同步机制](#进程间同步机制)
  - [自旋锁](#自旋锁)
  - [互斥锁](#互斥锁)
    - [什么是线程的上下文切换？](#什么是线程的上下文切换)
  - [自旋锁与互斥锁的总结](#自旋锁与互斥锁的总结)
  - [读写锁](#读写锁)
- [乐观锁](#乐观锁)
<!--toc:end-->

# 几种进程间通信机制

## 管道

匿名管道和命名管道。

前者只能用于具有父子关系的进程，后者没有限制。

管道的问题在于，通信效率低，不适合频繁交换数据的场景。

## 消息队列

消息队列是保存在内核中的消息链表。

问题在于：

1. 通信不及时。
2. 大小有限制。
3. 存在内核态与用户态之间的数据拷贝开销。

## 共享内存

使用一块虚拟地址空间，映射到相同的物理地址。这样两个进程就能看到同一块内存上的内容。

## 信号量

信号量是一个整型计数器，主要用于实现进程间的同步和互斥，而不是缓存进程间通信的数据。

P操作：信号量减去1，相减后如果信号量变为<0，就说明资源已经被占用，进程需要阻塞等待；否则表明还有资源可用，进程正常执行。

V操作：信号量+1，相加后如果信号量<=0，就说明当前有阻塞中的进程，于是将这个进程唤醒；否则，表明当前没有阻塞的进程。

P操作是进入共享资源之前，V操作是离开共享资源。

## 信号

信号是进程间通信机制唯一的异步通信机制。

## Socket

跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。

# 进程间同步机制

## 自旋锁

自旋锁是在加锁失败后，让线程独占CPU进行忙等待。

在实现上，通常使用的是指令集提供的CAS指令，在用户态完成加锁和解锁，不会主动产生线程上下文切换。

加锁的步骤：
1. 查看锁的状态，如果锁是空闲的，就执行第二步；
2. 将锁设置为线程所有。

CAS指令将这两个操作合并成了一个硬件级指令，形成原子指令。

需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。

## 互斥锁

互斥锁在加锁失败之后，线程会释放CPU，交给其他线程。

对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的，也就是说，当互斥锁加锁失败，会从用户态转换到内核态，让内核帮忙切换线程。这里存在一个上下文切换的开销。

这个开销是两次上下文切换的成本：

1. 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
2. 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

### 什么是线程的上下文切换？

当两个线程是属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

## 自旋锁与互斥锁的总结

如果能保证被锁住的代码的执行是非常短暂的，就应该使用自旋锁，否则使用互斥锁。

## 读写锁

读写锁适用于能够明确区分读操作和写操作的场景。

工作原理：

1. 当写锁没有被线程持有的时候，多个线程能够并发地持有读锁，这就提高了并发度。因为读锁具有读读兼容性。
2. 一旦写锁被持有，读线程的获取读锁就会被阻塞，其他线程的获取写锁也会被阻塞。

公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。

# 乐观锁

上面提到的三种锁都属于悲观锁。也就是认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。

乐观锁假定冲突的概率很低，工作方式：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。

只有在冲突概率非常低，并且加锁成本非常高的情况下，才建议使用乐观锁。
