<!--toc:start-->
- [创建型模式](#创建型模式)
- [结构性模式](#结构性模式)
- [行为型模式](#行为型模式)
- [七大原则](#七大原则)
    - [开闭原则](#开闭原则)
    - [依赖倒置原则](#依赖倒置原则)
    - [单一职责原则](#单一职责原则)
    - [接口隔离原则](#接口隔离原则)
    - [迪米特法则](#迪米特法则)
    - [里式替换原则](#里式替换原则)
- [责任链模式](#责任链模式)
  - [基本概念](#基本概念)
  - [工作流程](#工作流程)
- [工厂模式](#工厂模式)
  - [主要类型](#主要类型)
  - [应用场景](#应用场景)
- [单例模式](#单例模式)
  - [常见的单例模式实现](#常见的单例模式实现)
  - [双重锁检查如何实现单例](#双重锁检查如何实现单例)
  - [静态内部类如何实现单例模式](#静态内部类如何实现单例模式)
- [策略模式](#策略模式)
<!--toc:end-->

# 创建型模式

在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。

* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式
* 创建者模式
* 原型模式
* 单例模式

# 结构性模式

通过类和接口间的继承和引用实现创建复杂结构的对象。

* 外观模式
* 适配器模式
* 代理模式
* 组合模式
* 享元模式
* 装饰模式
* 桥接模式

# 行为型模式

通过类之间不同通信方式实现不同行为。

* 中介者模式
* 观察者模式
* 命令模式
* 迭代器模式
* 模板方法模式
* 策略模式
* 状态模式
* 备忘录模式
* 解释器模式
* 职责链模式
* 访问者模式

# 七大原则

1. 开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。

2. 单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。

3. 依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。

4. 接口隔离原则：将不同功能定义在不同接口中实现接口隔离。

5. 里氏替换原则：任何基类可以出现的地方，子类一定可以出现。

6. 迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。

7. 合成复用原则：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。



### 开闭原则

定义：开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。

减少对已有代码的修改（比如已有方法、逻辑），提升扩展性；可以提高软件系统的可复用性及可维护性，同时减少对已有代码的影响。

方式一：可以采用继承、重写等方式。

方式二：还可以更多的依赖接口与抽象，不要依赖具体实现！！ 因为你依赖实现，改动只能改动具体实现。


### 依赖倒置原则

定义：依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，抽象不依赖细节，细节应该依赖抽象。

通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。

### 单一职责原则

定义：定单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更的原因。

举例：假设我们有一个 Class负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个Class来实现，进行解耦。后期需求变更维护互不影响。

这样的设计可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个 Class/Interface/Method 只负责一项职责。但实际情况很多时候是不符合单一职责的，因为会加大代码量！！以及让代码过于分散！

### 接口隔离原则

定义：接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。

接口隔离原则符合我们常说的高内聚、低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。

### 迪米特法则

定义：迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。

迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类， 而出现在方法体内部的类不属于朋友类。实体类之间尽量减少相互作用！！ 简单就是一句话，减少类之间的耦合，这也是为什么我们很多方法定义成private或者protect！

### 里式替换原则

定义：里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为T1的对象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序P 在所有的对象o1都替换成 o2 时，程序 P 的行为没有发生变化，那么类型T2 是类型T1 的子类型。

定义重新理解：可以理解为一个软件实体如果适用一个父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下：引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。

子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。

子类中可以增加自己特有的方法。

当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。

当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。


# 责任链模式

责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。

请求会沿着一条链传递，直到有一个对象处理它为止。这种模式常用于处理不同类型的请求以及在不确定具体接收者的情况下将请求传递给多个对象中的一个。

## 基本概念

责任链模式主要包括以下几个角色：

- Handler（抽象处理者）：定义了一个处理请求的接口或抽象类，其中通常会包含一个指向链中下一个处理者的引用。
- ConcreteHandler（具体处理者）：实现抽象处理者的处理方法，如果它能处理请求，则处理；否则将请求转发给链中的下一个处理者。
- Client（客户端）：创建处理链，并向链的第一个处理者对象提交请求。

## 工作流程

1. 客户端将请求发送给链上的第一个处理者对象。
2. 处理者接收到请求后，决定自己是否有能力进行处理。
    2.1 如果可以处理，就处理请求。
    2.2 如果不能处理，就将请求转发给链上的下一个处理者。
3. 过程重复，直到链上的某个处理者能处理该请求或者链上没有更多的处理者。

# 工厂模式

工厂模式（Factory Pattern）属于创建型设计模式，主要用于创建对象，而不暴露创建对象的逻辑给客户端。

其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

调用工厂方法的代码（客户端代码）无需了解不同子类之间的差别，只管调用接口的 deliver 方法即可。

## 主要类型

1. 简单工厂模式（Simple Factory）：它引入了创建者的概念，将实例化的代码从应用程序的业务逻辑中分离出来。简单工厂模式包括一个工厂类，它提供一个方法用于创建对象。
2. 工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类进行。

## 应用场景

1. 数据库访问层（DAL）组件：工厂方法模式适用于数据库访问层，其中需要根据不同的数据库（如MySQL、PostgreSQL、Oracle）创建不同的数据库连接。工厂方法可以隐藏这些实例化逻辑，只提供一个统一的接口来获取数据库连接。
2. 日志记录：当应用程序需要实现多种日志记录方式（如向文件记录、数据库记录或远程服务记录）时，可以使用工厂模式来设计一个灵活的日志系统，根据配置或环境动态决定具体使用哪种日志记录方式。

# 单例模式

单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式主要用于控制对某些共享资源的访问，例如配置管理器、连接池、线程池、日志对象等。

1. 私有构造方法：确保外部代码不能通过构造器创建类的实例。
2. 私有静态实例变量：持有类的唯一实例。
3. 公有静态方法：提供全局访问点以获取实例，如果实例不存在，则在内部创建。

## 常见的单例模式实现

饿汉式单例（Eager Initialization）在类加载时就急切地创建实例，不管你后续用不用得到，这也是饿汉式的来源，简单但不支持延迟加载实例。

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

懒汉式单例（Lazy Initialization）在实际使用时才创建实例。这种实现方式需要考虑线程安全问题，因此一般会带上 synchronized 关键字。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

## 双重锁检查如何实现单例

双重检查锁用 synchronized 同步代码块替代了 synchronized 同步方法。并且在 instance 前加上 volatile 关键字，防止指令重排，因为 instance = new Singleton() 并不是一个原子操作，可能会被重排序，导致其他线程获取到未初始化完成的实例。

```java
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

当 instance 创建后，再次调用 getInstance 方法时，不会进入同步代码块，从而提高了性能。

## 静态内部类如何实现单例模式

利用 Java 的静态内部类（Static Nested Class）和类加载机制来实现线程安全的延迟初始化。

```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

当第一次加载 Singleton 类时并不会初始化 SingletonHolder，只有在第一次调用 getInstance 方法时才会导致 SingletonHolder 被加载，从而实例化 instance。

# 策略模式

策略模式是一种行为型设计模式，它定义了一系列的算法，将每个算法封装起来，使得它们可以相互替换。这种模式通常用于实现不同的业务规则，其中每种策略封装了特定的行为或算法。

特别适合优化程序中的复杂条件分支语句（if-else）。

在策略模式中，有三个角色：上下文、策略接口和具体策略。

1. 策略接口：定义所有支持算法公共接口。
2. 具体策略：实现策略接口的类，提供具体的算法实现。
3. 上下文：使用策略的类。通常包含一个引用指向策略接口，可以在运行时改变其具体策略。
