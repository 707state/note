
# 983 最低票价

在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。

火车票有 三种不同的销售方式 ：

    一张 为期一天 的通行证售价为 costs[0] 美元；
    一张 为期七天 的通行证售价为 costs[1] 美元；
    一张 为期三十天 的通行证售价为 costs[2] 美元。

通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张 为期 7 天 的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。

返回 你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费 。

```c++ 
class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {

        array<int, 366> dp; // dp[i]表示本年度第i天出游的花费
        int last = min(costs[0], min(costs[1], costs[2]));
        if (days.size() == 1) {
            return last;
        }
        dp[days[0]] = last;
        for (int i = days[0]; i <= days[1]; i++) {
            dp[i] = last;
        }
        int index = 1;
        for (int i = days[1]; i < 366; i++) {
            if (i == days[index]) { // 这一天需要去旅游
                index++;
                if (i >= 30) { // 从30天前，7天前，1天前
                    dp[i] =
                        min(dp[i - 30] + costs[2],
                            min(dp[i - 7] + costs[1], dp[i - 1] + costs[0]));
                } else if (i >= 7) {
                    dp[i] = min(
                        min(dp[i - 7] + costs[1], dp[i - 1] + costs[0]),
                        costs[2]); // 要么从七天前或者一天前或者涵盖在30天之内
                } else {
                    dp[i] = min(dp[i - 1] + costs[0], min(costs[2], costs[1]));
                }
                last = dp[i]; // 最近一天总共花了多少钱
            } else {          // 不用旅游的花费
                dp[i] = last;
            }
            if (index == days.size()) {
                return dp[i];
            }
        }
        return dp[365];
    }
};
```

# 组合总和 4 

给定一个由 不同 正整数组成的数组 nums ，和一个目标整数 target 。请从 nums 中找出并返回总和为 target 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。

```c++ 
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target+1,0);
        dp[0]=1;
        for(int i=1;i<=target;i++){
            for(auto& num: nums){
                if(num<=i&& dp[i - num] < INT_MAX - dp[i]){
                    dp[i]+=dp[i-num];
                }
            }
        }
        return dp[target];
    }
};
```

# 1928 规定时间内到达终点的最小花费

一个国家有 n 个城市，城市编号为 0 到 n - 1 ，题目保证 所有城市 都由双向道路 连接在一起 。道路由二维整数数组 edges 表示，其中 edges[i] = [xi, yi, timei] 表示城市 xi 和 yi 之间有一条双向道路，耗费时间为 timei 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。

每次经过一个城市时，你需要付通行费。通行费用一个长度为 n 且下标从 0 开始的整数数组 passingFees 表示，其中 passingFees[j] 是你经过城市 j 需要支付的费用。

一开始，你在城市 0 ，你想要在 maxTime 分钟以内 （包含 maxTime 分钟）到达城市 n - 1 。旅行的 费用 为你经过的所有城市 通行费之和 （包括 起点和终点城市的通行费）。

给你 maxTime，edges 和 passingFees ，请你返回完成旅行的 最小费用 ，如果无法在 maxTime 分钟以内完成旅行，请你返回 -1 。

```c++ 
class Solution {
public:
    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {
        int n=passingFees.size();//城市总数
        vector<vector<int>> dp(maxTime+1,vector<int>(n,INT_MAX/2));//dp[t][i]表示t分钟到达城市i的最少通行费总和
        dp[0][0]=passingFees[0];
        for(int t=1;t<=maxTime;t++){
            for(const auto& edge: edges){
                int i=edge[0],j=edge[1],cost=edge[2];
                if(cost<=t){//因为是双向道路，所以i, j之间可以互相到达
                    dp[t][i]=min(dp[t][i],dp[t-cost][j]+passingFees[i]);
                    dp[t][j]=min(dp[t][j],dp[t-cost][i]+passingFees[j]);
                }
            }
        }
        int ans=INT_MAX/2;
        for(int i=1;i<=maxTime;i++){//找到到达n-1城市的最小值
            ans=min(ans,dp[i][n-1]);
        }
        return ans==INT_MAX/2?-1:ans;
    }
};
```

# LCP 09 最小跳跃次数

为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]>=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。

为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。


思路：

从右向左计算dp值(从后向前)，当前位置如果为i 则它如果直接跳到右边（前面）去就是dp[jump[i]+i]+1（这个值已经计算过了），计算出当前位置dp[i]之后，当前位置i可以影响 i+1到dp[j] >= dp[i]+1位置上的值（因为某个位置可以跳到左边任意位置）注意遍历到dp[j]>=dp[i]+1即可。
```c++ 
class Solution {
public:
    int minJump(vector<int>& jump) {
        int n=jump.size();
        vector<int> dp(n);
        dp[n-1]=1;
        for(int i=n-2;i>=0;i--){
            dp[i]=(i+jump[i]>=n)?1: dp[jump[i]+i]+1;
            for(int j=i+1;j<n&&dp[j]>=dp[i]+1;++j){
                dp[j]=dp[i]+1;
            }
        }
        return dp[0];
    }
};
```


# 790 多米诺和托米诺平铺

```c++ 
class Solution {
public:
    int numTilings(int n) {
        vector<long> dp(n+1,0);
        if(n==1) return 1;
        if(n==2) return 2;
        constexpr static int mod=1e9+7;
        dp[0]=1;
        dp[1]=1;
        dp[2]=2;
        for(int i=3;i<=n;i++){
           dp[i]=(dp[i-1]*2+dp[i-3])%mod;
        }
        return dp[n];
    }
};
```

# 96 不同的二叉搜索树

给定一个整数 n,求以 1 ... n 为节点组成的二叉搜索树有多少种?

同义题：给定n,求所有二叉树的形状

```c++
class Solution {
public:
int numTrees(int n) {
vector<int> dp(n + 1);
dp[0] = 1;
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= i; j++) {
dp[i] += dp[j - 1] * dp[i - j];
}
}
return dp[n];
}
};
```

# 32 最长有效括号

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号
子串
的长度。

```c++ 
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxans = 0, n = s.length();
        vector<int> dp(n, 0);
        for (int i = 1; i < n; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = max(maxans, dp[i]);
            }
        }
        return maxans;
    }
};
```

# 322 零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

```c++ 
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<coins.size();i++){
            for(int j=coins[i];j<=amount;j++){
                if(dp[j-coins[i]]!=INT_MAX){
                    dp[j]=min(dp[j-coins[i]]+1,dp[j]);
                }
            }
        }
        return dp[amount]>amount? -1: dp[amount];
    }
};
```

# 375 猜数字大小 2 

我们正在玩一个猜数游戏，游戏规则如下：

    我从 1 到 n 之间选择一个数字。
    你来猜我选了哪个数字。
    如果你猜到正确的数字，就会 赢得游戏 。
    如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
    每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。

给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。

为了将支付的金额最小化，除了需要将每次支付的金额控制在较低值以外，还需要在猜数字的过程中缩小所选数字的范围。当猜了数字 x 并且猜错时，会知道 x 比所选数字大还是小。如果 x 比所选数字大，则任何比 x 大的数字一定都比所选数字大，因此应该在比 x 小的数字中继续猜数字。如果 x 比所选数字小，同理可知应该在比 x 大的数字中继续猜数字。

用 f(i,j) 表示在范围 [i,j] 内确保胜利的最少金额，目标是计算 f(1,n)。

假设第一次猜的数字是 x 并且猜错，则需要支付金额 x，当 x 大于所选数字时，为了确保胜利还需要支付的金额是 f(1,x−1)，当 x 小于所选数字时，为了确保胜利还需要支付的金额是 f(x+1,n)。为了在任何情况下都能确保胜利，应考虑最坏情况，计算 f(1,n) 时应取上述两者的最大值：f(1,n)=x+max(f(1,x−1),f(x+1,n))。

为了将确保胜利的金额最小化，需要遍历从 1 到 n 的所有可能的 x，使得 f(1,n) 的值最小：

f(1,n)=min{x+max(f(1,x−1),f(x+1,n))} (1≤x≤n)

由于 f(1,x−1) 和 f(x+1,n) 都是比原始问题 f(1,n) 规模更小的问题，因此可以使用动态规划的方法求解。

动态规划的状态为 f(i,j)，表示在范围 [i,j] 内确保胜利的最少金额。

当 i=j 时范围 [i,j] 只包含 1 个数字，所选数字一定是范围内的唯一的数字，不存在猜错的情况，因此 f(i,j)=0；当 i>j 时范围 [i,j] 不存在，因此 f(i,j)=0。综合上述两种情况可知，动态规划的边界情况是：当 i≥j 时，f(i,j)=0。

当 i<j 时，在范围 [i,j] 内第一次猜的数字可能是该范围内的任何一个数字。在第一次猜的数字是 k 的情况下（i≤k≤j），在范围 [i,j] 内确保胜利的最少金额是 k+max(f(i,k−1),f(k+1,j))。需要遍历全部可能的 k 找到在范围 [i,j] 内确保胜利的最少金额，因此状态转移方程如下：

f(i,j)=(i≤k≤j) min{k+max(f(i,k−1),f(k+1,j))}
```c++ 
//逆序
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+1,vector<int>(n+1));
        for(int i=n-1;i>=1;i--){
            for(int j=i+1;j<=n;j++){
                dp[i][j]=j+dp[i][j-1];
                for(int k=i;k<j;k++){
                    dp[i][j]=min(dp[i][j],k+max(dp[i][k-1],dp[k+1][j]));
                }
            }
        }
        return dp[1][n];
    }
};
//正序
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+2,vector<int>(n+2));
        for(int l=2;l<=n;l++){
            for(int i=1;i+l<=n+1;i++){
                int j=i+l-1;
                int minCost=INT_MAX;
                for(int k=i;k<=j;k++){
                    int cost=k+max(dp[i][k-1],dp[k+1][j]);
                    minCost=min(cost,minCost);
                }
                dp[i][j]=minCost;
            }
        }
        return dp[1][n];
    }
};
``` 

# 53 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组
是数组中的一个连续部分。

```c++
class Solution {
 public:
  int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size());
    int result=dp[0]=nums[0];
    for(int i=1;i<nums.size();i++){
        dp[i]=max(dp[i-1]+nums[i],nums[i]);
        result=max(result,dp[i]);
    }
    return result;
  }
};
```
<<<<<<< HEAD

# 213 打家劫舍2 

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

```c++ 
```c++ 
class Solution {
public:
    int rob_helper(vector<int>& nums,int start,int end){
        int first=nums[start],second=max(nums[start],nums[start+1]);
        for(int i=start+2;i<=end;i++){
            int tmp=second;
            second=max(nums[i]+first,second);
            first=tmp;
        }
        return second;
    }
    int rob(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        if(nums.size()==2) return max(nums[0],nums[1]);
        return max(rob_helper(nums,0,nums.size()-2),rob_helper(nums,1,nums.size()-1));
    }
};
```
# 3193 统计逆序对的数量

给你一个整数 n 和一个二维数组 requirements ，其中 requirements[i] = [endi, cnti] 表示这个要求中的末尾下标和 逆序对 的数目。

整数数组 nums 中一个下标对 (i, j) 如果满足以下条件，那么它们被称为一个 逆序对 ：

    i < j 且 nums[i] > nums[j]

请你返回 [0, 1, 2, ..., n - 1] 的 
排列
perm 的数目，满足对 所有 的 requirements[i] 都有 perm[0..endi] 恰好有 cnti 个逆序对。

由于答案可能会很大，将它对 109 + 7 取余 后返回。

```c++ 
class Solution {
    static constexpr int MOD=1'000'000'007;
public:
    int numberOfPermutations(int n, vector<vector<int>>& requirements) {
        vector<int> req(n,-1);
        req[0]=0;
        for(auto& p: requirements){
            req[p[0]]=p[1];
        }
        if(req[0]){
            return 0;
        }
        int m=ranges::max(req);
        vector<vector<int>> memo(n,vector<int>(m+1,-1));
        auto dfs=[&](auto &&dfs,int i,int j)->int{
            if(i==0) return 1;//边界条件
            int &res=memo[i][j];
            if(res!=-1) return res;
            res=0;
            if(int r=req[i-1];r>=0){
                if(j>=r&&j-i<=r){
                    res=dfs(dfs,i-1,r);
                }
            }else{
                for(int k=0;k<=min(i,j);k++) res=(res+dfs(dfs,i-1,j-k))%MOD;
            }
            return res;
        };
        return dfs(dfs,n-1,req[n-1]);
    }
};
```
=======
>>>>>>> 8fa2b28 (Update algo)
