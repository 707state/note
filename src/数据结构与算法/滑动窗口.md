# 3 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n=s.length();
        int ans=0;
        int left=0;
        unordered_map<char,int> window;
        for(int right=0;right<n;right++){
            char c=s[right];
            while(window.count(c)){
                window.erase(s[left++]);
            }
            window[c]++;
            ans=max(ans,right-left+1);
        }
        return ans;
    }
};
```

# 1446 连续字符

给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。

请你返回字符串 s 的 能量。

```cpp 
class Solution {
public:
    int maxPower(string s) {
        unordered_map<char,int> window;
        int left=0;
        int ans=0;
        for(int right=0;right<s.length();right++){
            window[s[right]]++;
            while(window.size()>1){
                if(--window[s[left]]==0){
                    window.erase(s[left]);
                }
                left++;
            }
            ans=max(ans,right-left+1);
        }
        return ans;
    }
};
```

# 316 去除重复字母

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的
字典序
最小（要求不能打乱其他字符的相对位置）。

```cpp 
class Solution {
public:
    string removeDuplicateLetters(string s) {
        array<int,26> left,in_ans;
        for(auto c: s){
            left[c-'a']++;//统计每个字母的出现次数
        }
        string ans;
        for(auto c: s){
            left[c-'a']--;
            if(in_ans[c-'a']) continue;//ans不能有重复字母
            while(!ans.empty()&&c<ans.back()&&left[ans.back()-'a']){//(x=ans.back())，如果c<x且右边还有x, 就可以把x去掉，因为后面可以重新把x加到ans中
                in_ans[ans.back()-'a']=false;//标记x不在ans中
                ans.pop_back();
            }
            ans+=c;//把c加载ans末尾
            in_ans[c-'a']=true;//把c加到ans中
        }
        return ans;
    }
};
```

# 239 滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int max_num=INT_MIN;
        vector<int> ans;
        deque<int> q;
        for(int i=0;i<nums.size();i++){
            //元素进入队尾
            while(!q.empty()&&nums[q.back()]<=nums[i]){
                q.pop_back();
            }
            //离开队首
            q.push_back(i);
            while(i-q.front()>=k){
                q.pop_front();
            }
            if(i>=k-1){
                ans.emplace_back(nums[q.front()]);
            }
        }
        return ans;
    }
};
```

# 76 最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        array<int,128> need;
        for(auto&c: t){
            need[c]++;
        }
        int r=0,l=0,n=s.length();
        int dist=t.length();
        int start=0,size=INT_MAX;
        while(r<n){
            char c=s[r];
            if(need[c]>0){
                dist--;
            }
            need[c]--;
            if(dist==0){
                while(l<r&&need[s[l]]<0) need[s[l++]]++;
                if(size>r-l+1){
                    size=r-l+1;
                    start=l;
                }
                need[s[l++]]++;
                dist++;
            }
            r++;
        }
        return size==INT_MAX?"":s.substr(start,size);
    }
};
```
# 3258 统计满足K约束的子字符串的数量1 
给你一个 二进制 字符串 s 和一个整数 k。

如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束：

    字符串中 0 的数量最多为 k。
    字符串中 1 的数量最多为 k。

返回一个整数，表示 s 的所有满足 k 约束 的子字符串的数量。

```cpp
class Solution {
public:
    int countKConstraintSubstrings(string s, int k) {
        int left=0;
        int ans=0;
        int cnt[2]{};
        for(int i=0;i<s.length();i++){
            cnt[s[i]&1]++;
            while(cnt[0]>k&&cnt[1]>k){
                cnt[s[left++]&1]--;
            }
            ans+=i-left+1;
        }
        return ans;
    }
};
```


