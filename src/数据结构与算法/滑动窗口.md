<!--toc:start-->
- [3 无重复字符的最长子串](#3-无重复字符的最长子串)
- [1446 连续字符](#1446-连续字符)
- [316 去除重复字母](#316-去除重复字母)
- [239 滑动窗口最大值](#239-滑动窗口最大值)
- [76 最小覆盖子串](#76-最小覆盖子串)
- [3258 统计满足K约束的子字符串的数量1](#3258-统计满足k约束的子字符串的数量1)
- [30 串联所有单词的子串](#30-串联所有单词的子串)
- [UNSOLVED 658 找到K个最接近的元素](#unsolved-658-找到k个最接近的元素)
- [1287 有序数组中出现次数超过25%的元素](#1287-有序数组中出现次数超过25的元素)
<!--toc:end-->

# 3 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n=s.length();
        int ans=0;
        int left=0;
        unordered_map<char,int> window;
        for(int right=0;right<n;right++){
            char c=s[right];
            while(window.count(c)){
                window.erase(s[left++]);
            }
            window[c]++;
            ans=max(ans,right-left+1);
        }
        return ans;
    }
};
```

</details>

# 1446 连续字符
给你一个字符串 s
，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。

请你返回字符串 s 的 能量。

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    int maxPower(string s) {
        unordered_map<char,int> window;
        int left=0;
        int ans=0;
        for(int right=0;right<s.length();right++){
            window[s[right]]++;
            while(window.size()>1){
                if(--window[s[left]]==0){
                    window.erase(s[left]);
                }
                left++;
            }
            ans=max(ans,right-left+1);
        }
        return ans;
    }
};
```

</details>

# 316 去除重复字母
给你一个字符串 s
，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的
字典序 最小（要求不能打乱其他字符的相对位置）。

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    string removeDuplicateLetters(string s) {
        array<int,26> left,in_ans;
        for(auto c: s){
            left[c-'a']++;//统计每个字母的出现次数
        }
        string ans;
        for(auto c: s){
            left[c-'a']--;
            if(in_ans[c-'a']) continue;//ans不能有重复字母
            while(!ans.empty()&&c<ans.back()&&left[ans.back()-'a']){//(x=ans.back())，如果c<x且右边还有x, 就可以把x去掉，因为后面可以重新把x加到ans中
                in_ans[ans.back()-'a']=false;//标记x不在ans中
                ans.pop_back();
            }
            ans+=c;//把c加载ans末尾
            in_ans[c-'a']=true;//把c加到ans中
        }
        return ans;
    }
};
```

</details>

# 239 滑动窗口最大值
给你一个整数数组 nums，有一个大小为 k
的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k
个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int max_num=INT_MIN;
        vector<int> ans;
        deque<int> q;
        for(int i=0;i<nums.size();i++){
            //元素进入队尾
            while(!q.empty()&&nums[q.back()]<=nums[i]){
                q.pop_back();
            }
            //离开队首
            q.push_back(i);
            while(i-q.front()>=k){
                q.pop_front();
            }
            if(i>=k-1){
                ans.emplace_back(nums[q.front()]);
            }
        }
        return ans;
    }
};
```

</details>

# 76 最小覆盖子串
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t
所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串
\"\" 。

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    string minWindow(string s, string t) {
        array<int,128> need;
        for(auto&c: t){
            need[c]++;
        }
        int r=0,l=0,n=s.length();
        int dist=t.length();
        int start=0,size=INT_MAX;
        while(r<n){
            char c=s[r];
            if(need[c]>0){
                dist--;
            }
            need[c]--;
            if(dist==0){
                while(l<r&&need[s[l]]<0) need[s[l++]]++;
                if(size>r-l+1){
                    size=r-l+1;
                    start=l;
                }
                need[s[l++]]++;
                dist++;
            }
            r++;
        }
        return size==INT_MAX?"":s.substr(start,size);
    }
};
```

</details>

# 3258 统计满足K约束的子字符串的数量1
给你一个 二进制 字符串 s 和一个整数 k。

如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束：

    字符串中 0 的数量最多为 k。
    字符串中 1 的数量最多为 k。

返回一个整数，表示 s 的所有满足 k 约束 的子字符串的数量。

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    int countKConstraintSubstrings(string s, int k) {
        int left=0;
        int ans=0;
        int cnt[2]{};
        for(int i=0;i<s.length();i++){
            cnt[s[i]&1]++;
            while(cnt[0]>k&&cnt[1]>k){
                cnt[s[left++]&1]--;
            }
            ans+=i-left+1;
        }
        return ans;
    }
};
```

</details>

# 30 串联所有单词的子串
给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。

s 中的 串联子串 是指一个包含 words
中所有字符串以任意顺序排列连接起来的子串。

    例如，如果 words = ["ab","cd","ef"]， 那么 "abcdef"， "abefcd"，"cdabef"， "cdefab"，"efabcd"， 和 "efcdab" 都是串联子串。 "acdbef" 不是串联子串，因为他不是任何 words 排列的连接。

返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    vector<int> findSubstring(string &s, vector<string> &words) {
        vector<int> res;
        int m = words.size(), n = words[0].size(), ls = s.size();
        for (int i = 0; i < n && i + m * n <= ls; ++i) {
            unordered_map<string, int> differ;
            for (int j = 0; j < m; ++j) {
                ++differ[s.substr(i + j * n, n)];
            }
            for (string &word: words) {
                if (--differ[word] == 0) {
                    differ.erase(word);
                }
            }
            for (int start = i; start < ls - m * n + 1; start += n) {
                if (start != i) {
                    string word = s.substr(start + (m - 1) * n, n);
                    if (++differ[word] == 0) {
                        differ.erase(word);
                    }
                    word = s.substr(start - n, n);
                    if (--differ[word] == 0) {
                        differ.erase(word);
                    }
                }
                if (differ.empty()) {
                    res.emplace_back(start);
                }
            }
        }
        return res;
    }
};
```

</details>

# UNSOLVED 658 找到K个最接近的元素

给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近
x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。

整数 a 比整数 b 更接近 x 需要满足：

    |a - x| < |b - x| 或者
    |a - x| == |b - x| 且 a < b

<details><summary>Click to expand</summary>

``` cpp
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        int n = nums.size();
        unordered_map<int, vector<int>> indices;
        int xMin = INT_MAX, xMax = INT_MIN;
        for (int i = 0; i < n; ++i) {
            for (const int& x: nums[i]) {
                indices[x].push_back(i);
                xMin = min(xMin, x);
                xMax = max(xMax, x);
            }
        }

        vector<int> freq(n);
        int inside = 0;
        int left = xMin, right = xMin - 1;
        int bestLeft = xMin, bestRight = xMax;

        while (right < xMax) {
            ++right;
            if (indices.count(right)) {
                for (const int& x: indices[right]) {
                    ++freq[x];
                    if (freq[x] == 1) {
                        ++inside;
                    }
                }
                while (inside == n) {
                    if (right - left < bestRight - bestLeft) {
                        bestLeft = left;
                        bestRight = right;
                    }
                    if (indices.count(left)) {
                        for (const int& x: indices[left]) {
                            --freq[x];
                            if (freq[x] == 0) {
                                --inside;
                            }
                        }
                    }
                    ++left;
                }
            }
        }

        return {bestLeft, bestRight};
    }
};
```

</details>

# 1287 有序数组中出现次数超过25%的元素

给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。

<details>

```cpp
int findSpecialInteger(int* arr, int arrSize) {
    int span=arrSize/4+1;
    int left=0;
    for(int right=0;right<arrSize;right++){
        while(right<arrSize&&arr[left]==arr[right]){
            right++;
        }
        if(right-left>=span){
            return arr[left];
        }
        left=right;
    }
    return -1;
}
```

</details>

# LCR 180 文件组合

待传输文件被切分成多个部分，按照原排列顺序，每部分文件编号均为一个 正整数（至少含有两个文件）。传输要求为：连续文件编号总和为接收方指定数字 target 的所有文件。请返回所有符合该要求的文件传输组合列表。

注意，返回时需遵循以下规则：

    每种组合按照文件编号 升序 排列；
    不同组合按照第一个文件编号 升序 排列。


<details>

```cpp
class Solution {
public:
    vector<vector<int>> fileCombination(int target) {
        vector<vector<int>> ans;
        int i=1,j=1;
        int sum=0;
        while(i<=target/2){
            if(sum<target){
                sum+=j;
                j++;
            }else if(sum>target){
                sum-=i;
                i++;
            }else{
                vector<int> arr;
                for(int k=i;k<j;k++){
                    arr.push_back(k);
                }
                ans.push_back(arr);
                sum-=i;
                i++;
            }
        }
        return ans;
    }
};
```

</details>
