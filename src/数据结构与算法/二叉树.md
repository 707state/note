
# 102 二叉树层序遍历

```c++ 
class Solution {
    vector<vector<int>> level_order;
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        std::list<TreeNode*> list;
        if(root!=nullptr)
        list.push_back(root);
        while(list.size()){
            int size=list.size();
            vector<int> vec;
            for(int i=0;i<size;i++){
                auto node=list.front();
                list.pop_front();
                vec.push_back(node->val);
                if(node->left) list.push_back(node->left);
                if(node->right) list.push_back(node->right);
            }
            level_order.emplace_back(vec);
        }
        return level_order;
    }
};
```

# 199 二叉树的右视图

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

```c++ 
class Solution {
 public:
  vector<int> rightSideView(TreeNode *root) {
      if(root==nullptr) return {};
    vector<vector<int>> levelOrder;
    queue<TreeNode *> que;
    que.push(root);
    while (!que.empty()) {
      int n = que.size();
      levelOrder.push_back(vector<int>());
      for (int i = 0; i < n; i++) {
        auto node = que.front();
        que.pop();
        levelOrder.back().push_back(node->val);
        if (node->left) que.push(node->left);
        if (node->right) que.push(node->right);
      }
    }
    vector<int> ans;
    for (auto i : levelOrder) {
      ans.push_back(i.back());
    }
    return ans;
  }
};
```


# 637 二叉树的层平均值

```c++ 
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ans;
        std::queue<TreeNode*> que;
        if(root!=nullptr) que.push(root);
        while(que.size()){
            int size=que.size();
            double level_sum=0;
            for(int i=0;i<size;i++){
                auto node=que.front();
                que.pop();
                level_sum+=node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            ans.push_back((double)(level_sum/size));
        }
        return ans;
    }
};
```

# 429 N叉树的层序遍历

```c++ 
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> level_order;
        std::queue<Node*> que;
        if(root) que.push(root);
        while(que.size()){
            int n=que.size();
            vector<int> level;
            for(int i=0;i<n;i++){
                auto node=que.front();
                que.pop();
                level.push_back(node->val);
                for(auto each: node->children){
                    que.push(each);
                }
            }
            level_order.emplace_back(std::move(level));
        }
        return level_order;
    }
};
```


# 116 填充每一个节点的下一个右侧节点指针

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。


```c++ 
class Solution {
 public:
  Node* connect(Node* root) {
    if (root == nullptr) return root;
    queue<Node*> Q;
    Q.push(root);
    while (!Q.empty()) {
      int size = Q.size();
      for (int i = 0; i < size; i++) {
        auto node = Q.front();
        Q.pop();
        if (i < size - 1) {  // 连接
          node->next = Q.front();
        }
        if (node->left) Q.push(node->left);
        if (node->right) Q.push(node->right);
      }
    }
    return root;
  }
};
```

# 117 填充下一个右侧节点 2 

给定一个二叉树：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。

初始状态下，所有 next 指针都被设置为 NULL 。

```c++ 

class Solution {
 public:
  Node* connect(Node* root) {
    if (root == nullptr) return root;
    queue<Node*> q;
    q.push(root);
    while (!q.empty()) {
      int n = q.size();
      Node* last = nullptr;
      for (int i = 1; i <= n; i++) {
        auto f = q.front();
        q.pop();
        if (f->left) q.push(f->left);
        if (f->right) q.push(f->right);
        if (i != 1) last->next = f;
        last = f;
      }
    }
    return root;
  }
};
```

# 对称二叉树

```c++ 
class Solution {
    bool checker(TreeNode* left,TreeNode *right){
        if(!left&&!right) return true;
        if(left&&right)
        return left->val==right->val&&checker(left->left,right->right)&&checker(left->right, right->left);
        return false;
    }
public:
    bool isSymmetric(TreeNode* root) {
        return checker(root,root);
    }
};
```


# 1597 根据中缀表达式构造二叉表达式树

二叉表达式树 是一种表达算术表达式的二叉树。二叉表达式树中的每一个节点都有零个或两个子节点。 叶节点（有 0 个子节点的节点）表示操作数，非叶节点（有 2 个子节点的节点）表示运算符： '+' （加）、 '-' （减）、 '*' （乘）和 '/' （除）。

对于每一个运算符为 o 的非叶节点，对应的 中缀表达式 为 (A o B)，其中 A 是左子树所表达的表达式， B 是右子树所表达的表达式。

给定一个 中缀表达式 字符串 s，其中包含操作数、上面提到的运算符，以及括号 '(' 与 ')' 。

返回一个有效的 二叉表达式树，其 中序遍历 序列对应表达式 s 消除括号后的序列（详情参见下面的示例）。

注意，表达式的一般解析顺序适用于 s，即优先解析括号内的表达式，然后解析乘除法，最后解析加减法。

同时，操作数在 s 和树的中序遍历中 出现顺序相同 。

```c++
class Solution {
    stack<Node*> nums;
    stack<char> ops;
    std::map<char,int> priority{
        {'(',4},
        {'*',3},
        {'/',3},
        {'+',2},
        {'-',2},
        {')',1}
    };
    void pop_up(){
        auto right=nums.top();
        nums.pop();
        auto left=nums.top();
        nums.pop();
        nums.push(new Node(ops.top(),left,right));
        ops.pop();
    }
public:
    Node* expTree(string s) {
        for(auto& c:s){
            if(isdigit(c)){
                nums.push(new Node(c));
            }else{
                if(ops.empty()||priority[ops.top()]<priority[c]){
                    ops.push(c);
                }else{
                    while(!ops.empty()&&ops.top()!='('&&priority[ops.top()]>=priority[c]){
                        pop_up();
                    }
                    if(c!=')') ops.push(c);
                    else ops.pop();
                }
            }
        }  
        while(!ops.empty()) pop_up();
        return nums.top();
    }
};
```


# 103 二叉树的锯齿形层序遍历

给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。


```c++
class Solution {
    vector<vector<int>> ans;
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        bool level_order=true;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(que.size()){
            int size=que.size();
            deque<int> vec;
            for(int i=0;i<size;i++){
                auto node=que.front();
                que.pop();
                if(level_order)
                vec.push_back(node->val);
                else vec.push_front(node->val);
                    if(node->left) que.push(node->left);
                    if(node->right) que.push(node->right);
            }
            level_order=!level_order;
            ans.emplace_back(vector<int>{vec.begin(),vec.end()});
        }
        return ans;
    }
};
```
