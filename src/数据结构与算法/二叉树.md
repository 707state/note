<!--toc:start-->
- [102 二叉树层序遍历](#102-二叉树层序遍历)
- [199 二叉树的右视图](#199-二叉树的右视图)
- [637 二叉树的层平均值](#637-二叉树的层平均值)
- [429 N 叉树的层序遍历](#429-n-叉树的层序遍历)
- [116 填充每一个节点的下一个右侧节点指针](#116-填充每一个节点的下一个右侧节点指针)
- [117 填充下一个右侧节点 2](#117-填充下一个右侧节点-2)
- [对称二叉树](#对称二叉树)
- [1597 根据中缀表达式构造二叉表达式树](#1597-根据中缀表达式构造二叉表达式树)
- [103 二叉树的锯齿形层序遍历](#103-二叉树的锯齿形层序遍历)
- [426 将二叉树转化为排序的双向链表](#426-将二叉树转化为排序的双向链表)
- [297 二叉树的序列化和反序列化](#297-二叉树的序列化和反序列化)
- [863 二叉树中所有距离为 K 的节点](#863-二叉树中所有距离为-k-的节点)
- [543 二叉树的直径](#543-二叉树的直径)
- [124 二叉树中的最大路径和](#124-二叉树中的最大路径和)
- [2246 相邻字符不同的最长路径](#2246-相邻字符不同的最长路径)
- [114 二叉树展开为链表](#114-二叉树展开为链表)
- [437 路径总和 3](#437-路径总和-3)
- [208 实现 Trie (前缀树)](#208-实现-trie-前缀树)
  - [思路](#思路)
- [236 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)
- [3249 统计好节点的数目](#3249-统计好节点的数目)
- [250 统计同值子树](#250-统计同值子树)
- [1120 子树的最大平均值](#1120-子树的最大平均值)
- [545 二叉树的边界](#545-二叉树的边界)
- [366 寻找二叉树的叶子节点](#366-寻找二叉树的叶子节点)
- [314 二叉树的垂直遍历](#314-二叉树的垂直遍历)
- [270 最接近的二叉搜索树值](#270-最接近的二叉搜索树值)
- [272 最接近的二叉搜索树的值Ⅱ](#272-最接近的二叉搜索树的值ⅱ)
- [255 验证二叉搜索树的前序遍历序列](#255-验证二叉搜索树的前序遍历序列)
- [333 最大的二叉搜索树](#333-最大的二叉搜索树)
- [588 设计内存文件系统](#588-设计内存文件系统)
- [1522 N叉树的直径](#1522-n叉树的直径)
- [431 将N叉树编码为二叉树](#431-将n叉树编码为二叉树)
- [428 序列化和反序列化N叉树](#428-序列化和反序列化n叉树)
- [2196 根据描述创建二叉树](#2196-根据描述创建二叉树)
- [958 二叉树的完全性检验](#958-二叉树的完全性检验)
- [1644 二叉树的最近公共祖先Ⅱ](#1644-二叉树的最近公共祖先ⅱ)
- [1530 好叶子节点对的数量](#1530-好叶子节点对的数量)
- [666 路径总和Ⅳ](#666-路径总和ⅳ)
<!--toc:end-->

# 102 二叉树层序遍历
<details><summary>Click to expand</summary>

```c++
class Solution {
    vector<vector<int>> level_order;
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        std::list<TreeNode*> list;
        if(root!=nullptr)
        list.push_back(root);
        while(list.size()){
            int size=list.size();
            vector<int> vec;
            for(int i=0;i<size;i++){
                auto node=list.front();
                list.pop_front();
                vec.push_back(node->val);
                if(node->left) list.push_back(node->left);
                if(node->right) list.push_back(node->right);
            }
            level_order.emplace_back(vec);
        }
        return level_order;
    }
};
```

</details>

# 199 二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

<details><summary>Click to expand</summary>

```c++
class Solution {
 public:
  vector<int> rightSideView(TreeNode *root) {
      if(root==nullptr) return {};
    vector<vector<int>> levelOrder;
    queue<TreeNode *> que;
    que.push(root);
    while (!que.empty()) {
      int n = que.size();
      levelOrder.push_back(vector<int>());
      for (int i = 0; i < n; i++) {
        auto node = que.front();
        que.pop();
        levelOrder.back().push_back(node->val);
        if (node->left) que.push(node->left);
        if (node->right) que.push(node->right);
      }
    }
    vector<int> ans;
    for (auto i : levelOrder) {
      ans.push_back(i.back());
    }
    return ans;
  }
};
```

</details>

# 637 二叉树的层平均值
<details><summary>Click to expand</summary>

```c++
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ans;
        std::queue<TreeNode*> que;
        if(root!=nullptr) que.push(root);
        while(que.size()){
            int size=que.size();
            double level_sum=0;
            for(int i=0;i<size;i++){
                auto node=que.front();
                que.pop();
                level_sum+=node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            ans.push_back((double)(level_sum/size));
        }
        return ans;
    }
};
```

</details>

# 429 N 叉树的层序遍历

<details><summary>Click to expand</summary>

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> level_order;
        std::queue<Node*> que;
        if(root) que.push(root);
        while(que.size()){
            int n=que.size();
            vector<int> level;
            for(int i=0;i<n;i++){
                auto node=que.front();
                que.pop();
                level.push_back(node->val);
                for(auto each: node->children){
                    que.push(each);
                }
            }
            level_order.emplace_back(std::move(level));
        }
        return level_order;
    }
};
```

</details>

# 116 填充每一个节点的下一个右侧节点指针

给定一个 完美二叉树
，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node { int val; Node \*left; Node \*right; Node \*next; }

填充它的每个 next
指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将
next 指针设置为 NULL。

<details><summary>Click to expand</summary>

```c++
class Solution {
 public:
  Node* connect(Node* root) {
    if (root == nullptr) return root;
    queue<Node*> Q;
    Q.push(root);
    while (!Q.empty()) {
      int size = Q.size();
      for (int i = 0; i < size; i++) {
        auto node = Q.front();
        Q.pop();
        if (i < size - 1) {  // 连接
          node->next = Q.front();
        }
        if (node->left) Q.push(node->left);
        if (node->right) Q.push(node->right);
      }
    }
    return root;
  }
};
```

</details>

# 117 填充下一个右侧节点 2

给定一个二叉树：

struct Node { int val; Node \*left; Node \*right; Node \*next; }

填充它的每个 next
指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将
next 指针设置为 NULL 。

初始状态下，所有 next 指针都被设置为 NULL 。

<details><summary>Click to expand</summary>

```c++

class Solution {
 public:
  Node* connect(Node* root) {
    if (root == nullptr) return root;
    queue<Node*> q;
    q.push(root);
    while (!q.empty()) {
      int n = q.size();
      Node* last = nullptr;
      for (int i = 1; i <= n; i++) {
        auto f = q.front();
        q.pop();
        if (f->left) q.push(f->left);
        if (f->right) q.push(f->right);
        if (i != 1) last->next = f;
        last = f;
      }
    }
    return root;
  }
};
```

</details>

# 对称二叉树

<details><summary>Click to expand</summary>

```c++
class Solution {
    bool checker(TreeNode* left,TreeNode *right){
        if(!left&&!right) return true;
        if(left&&right)
        return left->val==right->val&&checker(left->left,right->right)&&checker(left->right, right->left);
        return false;
    }
public:
    bool isSymmetric(TreeNode* root) {
        return checker(root,root);
    }
};
```

</details>

# 1597 根据中缀表达式构造二叉表达式树
二叉表达式树
是一种表达算术表达式的二叉树。二叉表达式树中的每一个节点都有零个或两个子节点。
叶节点（有 0 个子节点的节点）表示操作数，非叶节点（有 2
个子节点的节点）表示运算符： \'+\' （加）、 \'-\' （减）、 \'\*\'
（乘）和 \'/\' （除）。

对于每一个运算符为 o 的非叶节点，对应的 中缀表达式 为 (A o B)，其中 A
是左子树所表达的表达式， B 是右子树所表达的表达式。

给定一个 中缀表达式 字符串 s，其中包含操作数、上面提到的运算符，以及括号
\'(\' 与 \')\' 。

返回一个有效的 二叉表达式树，其 中序遍历 序列对应表达式 s
消除括号后的序列（详情参见下面的示例）。

注意，表达式的一般解析顺序适用于
s，即优先解析括号内的表达式，然后解析乘除法，最后解析加减法。

同时，操作数在 s 和树的中序遍历中 出现顺序相同 。

<details><summary>Click to expand</summary>

```c++
class Solution {
    stack<Node*> nums;
    stack<char> ops;
    std::map<char,int> priority{
        {'(',4},
        {'*',3},
        {'/',3},
        {'+',2},
        {'-',2},
        {')',1}
    };
    void pop_up(){
        auto right=nums.top();
        nums.pop();
        auto left=nums.top();
        nums.pop();
        nums.push(new Node(ops.top(),left,right));
        ops.pop();
    }
public:
    Node* expTree(string s) {
        for(auto& c:s){
            if(isdigit(c)){
                nums.push(new Node(c));
            }else{
                if(ops.empty()||priority[ops.top()]<priority[c]){
                    ops.push(c);
                }else{
                    while(!ops.empty()&&ops.top()!='('&&priority[ops.top()]>=priority[c]){
                        pop_up();
                    }
                    if(c!=')') ops.push(c);
                    else ops.pop();
                }
            }
        }
        while(!ops.empty()) pop_up();
        return nums.top();
    }
};
```

</details>

# 103 二叉树的锯齿形层序遍历

给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历
。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

<details><summary>Click to expand</summary>

```c++
class Solution {
    vector<vector<int>> ans;
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        bool level_order=true;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(que.size()){
            int size=que.size();
            deque<int> vec;
            for(int i=0;i<size;i++){
                auto node=que.front();
                que.pop();
                if(level_order)
                vec.push_back(node->val);
                else vec.push_front(node->val);
                    if(node->left) que.push(node->left);
                    if(node->right) que.push(node->right);
            }
            level_order=!level_order;
            ans.emplace_back(vector<int>{vec.begin(),vec.end()});
        }
        return ans;
    }
};
```

</details>

# 426 将二叉树转化为排序的双向链表
将一个 二叉搜索树 就地转化为一个 已排序的双向循环链表 。

对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

特别地，我们希望可以 原地
完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

<details><summary>Click to expand</summary>

```c++
class Solution {
    Node *first,*last;
    void helper(Node* node){
        if(node){
            helper(node->left);
            if(last){
                last->right=node;
                node->left=last;
            }else{
                first=node;
            }
            last=node;
            helper(node->right);
        }
    }
public:
    Node* treeToDoublyList(Node* root) {
        if(root==nullptr){
            return root;
        }
        helper(root);
        last->right=first;
        first->left=last;
        return first;
    }
};
```

</details>

# 297 二叉树的序列化和反序列化

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 /
反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode
序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

<details><summary>Click to expand</summary>

```c++
class Codec {
public:
    void reserialize(TreeNode* root,string &str){
        if(root==nullptr){
            str+="Null,";
        }else{
            str+=to_string(root->val)+",";
            reserialize(root->left, str);
            reserialize(root->right,str);
        }
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string ret;
        reserialize(root, ret);
        return ret;
    }
    TreeNode *rdeserialize(list<string>& data){
        if(data.front()=="Null"){
            data.erase(data.begin());
            return nullptr;
        }
        auto root=new TreeNode(stoi(data.front()));
        data.erase(data.begin());
        root->left=rdeserialize(data);
        root->right=rdeserialize(data);
        return root;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        list<string> data_list;
        string str;
        for(auto&& ch: data){
            if(ch==','){
                data_list.emplace_back(std::move(str));
            }else{
                str.push_back(move(ch));
            }
        }
        if(!str.empty()){
            data_list.emplace_back(std::move(str));
        }
        return rdeserialize(data_list);
    }
};
```

</details>

# 863 二叉树中所有距离为 K 的节点

给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 k
，返回到目标结点 target 距离为 k 的所有结点的值的数组。

答案可以以 任何顺序 返回。

思路：

保存一个节点的父节点，左右和父节点三次调用。

<details><summary>Click to expand</summary>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    vector<int> ans;
    unordered_map<int,TreeNode *> parent_node;
    int deps=0;
    void parent(TreeNode *node){
        if(node==nullptr) return;
        if(node->left){
            parent_node[node->left->val]=node;
            parent(node->left);
        }
        if(node->right){
            parent_node[node->right->val]=node;
            parent(node->right);
        }
    }
    void find_ans(TreeNode *root,TreeNode* target,int cur){
        if(root==nullptr){
            return;
        }
        if(cur==deps){
            ans.emplace_back(root->val);
            return;
        }
        if(root->left!=target){
            find_ans(root->left,root,cur+1);
        }
        if(root->right!=target){
            find_ans(root->right,root,cur+1);
        }
        if(parent_node[root->val]!=target){
            find_ans(parent_node[root->val],root,cur+1);
        }
    }
public:
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        deps=k;
        parent(root);
        find_ans(target,nullptr,0);
        return ans;
    }
};
```

</details>

# 543 二叉树的直径
给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度
。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。

<details><summary>Click to expand</summary>

```c++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int ans=0;
        auto dfs=[&](auto&& dfs,TreeNode* node)->int{
            if(!node) return -1;
            int l_len=dfs(dfs,node->left)+1;
            auto r_len=dfs(dfs,node->right)+1;
            ans=max(ans,l_len+r_len);
            return max(l_len,r_len);
        };
        dfs(dfs,root);
        return ans;
    }
};
```

</details>

# 124 二叉树中的最大路径和

二叉树中的 路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int ans=INT_MIN;
        auto dfs=[&](auto&& dfs,TreeNode* node)->int{
            if(!node) return 0;//没有节点
            int l_val=dfs(dfs,node->left);//左子树最大链和
            int r_val=dfs(dfs,node->right);//右子树最大链和
            ans=max(ans,l_val+r_val+node->val);//两条链拼成路径
            return max(max(l_val,r_val)+node->val,0);//当前子树最大链和
        };
        dfs(dfs,root);
        return ans;
    }
};
```

</details>

# 2246 相邻字符不同的最长路径

给你一棵 树（即一个连通、无向、无环图），根节点是节点 0 ，这棵树由编号从0 到 n - 1 的 n 个节点组成。用下标从 0 开始、长度为 n 的数组 parent来表示这棵树，其中parent\[i\] 是节点 i 的父节点，由于节点 0是根节点，所以 parent\[0\] == -1 。

另给你一个字符串 s ，长度也是 n ，其中 s\[i\] 表示分配给节点 i 的字符。

请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径，并返回该路径的长度。

如果没有相邻节点的限制，那么本题求的就是树的直径上的点的个数，见 1245.树的直径。

考虑用树形 DP 求直径。枚举子树 x 的所有子树 y，维护从 x 出发的最长路径maxLen，那么可以更新答案为从 y 出发的最长路径加上 maxLen，再加上 1（边x−y），即合并从 x 出发的两条路径。递归结束时返回 maxLen。

对于本题的限制，我们可以在从子树 y 转移过来时，仅考虑从满足s\[y\]=s\[x\] 的子树 y 转移过来，所以对上述做法加个 if 判断就行了。

由于本题求的是点的个数，所以答案为最长路径的长度加一。

<details><summary>Click to expand</summary>

```c++
class Solution {
public:
    int longestPath(vector<int>& parent, string s) {
        int n=parent.size();
        vector<vector<int>> g(n);
        for(int i=1;i<n;i++){
            g[parent[i]].emplace_back(i);
        }
        int ans=0;
        auto dfs=[&](auto&& dfs,int x)->int{
            int maxLen=0;
            for(int y:g[x]){
                int len=dfs(dfs,y)+1;
                if(s[y]!=s[x]){
                    ans=max(ans,maxLen+len);
                    maxLen=max(maxLen,len);
                }
            }
            return maxLen;
        };
        dfs(dfs,0);
        return ans+1;
    }
};
```

</details>

# 114 二叉树展开为链表

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right
子指针指向链表中下一个结点，而左子指针始终为 null 。

展开后的单链表应该与二叉树 先序遍历 顺序相同。

<details><summary>Click to expand</summary>

```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        if(root==nullptr) return;
        auto subFlatten=[](auto&& subFlatten,TreeNode* node)->TreeNode*{
            TreeNode* left=node->left;
            TreeNode* right=node->right;
            auto last=node;
            node->left=nullptr;
            if(left){
                node->right=left;
                last=subFlatten(subFlatten,left);
            }
            if(right){
                last->right=right;
                last=subFlatten(subFlatten,right);
            }
            return last;
        };
        subFlatten(subFlatten, root);
    }
};
```

</details>

# 437 路径总和 3
给定一个二叉树的根节点 root ，和一个整数 targetSum
，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径
不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

<details><summary>Click to expand</summary>

```c++
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        int ans=0;
        unordered_map<long long,int> cnt{{0,1}};
        auto dfs=[&](auto&& dfs,TreeNode* node,long long s){
            if(!node) return;
            s+=node->val;
            ans+=cnt.contains(s-targetSum)?cnt[s-targetSum]:0;
            cnt[s]++;
            dfs(dfs,node->left,s);
            dfs(dfs,node->right,s);
            cnt[s]--;
        };
        dfs(dfs,root,0);
        return ans;
    }
};
```

</details>

# 208 实现 Trie (前缀树)
Trie（发音类似 \"try\"）或者说 前缀树
是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

    Trie() 初始化前缀树对象。
    void insert(String word) 向前缀树中插入字符串 word 。
    boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
    boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

## 思路

Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：

    指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 a，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。
    布尔字段 isEnd，表示该节点是否为字符串的结尾。

插入字符串

我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：

    子节点存在。沿着指针移动到子节点，继续处理下一个字符。
    子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。

重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。

查找前缀

我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：

    子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
    子节点不存在。说明字典树中不包含该前缀，返回空指针。

重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。

若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的
isEnd 为真，则说明字典树中存在该字符串。

<details><summary>Click to expand</summary>

```c++
class Trie {
    vector<Trie *> children;
    bool isEnd;
    Trie *searchPrefix(string prefix){
        Trie *node=this;
        for(char ch: prefix){
            ch-='a';
            if(node->children[ch]==nullptr){
                return nullptr;
            }
            node=node->children[ch];
        }
        return node;
    }
public:
    Trie(): children(26),isEnd(false) {
    }
    void insert(string word) {
        Trie *node=this;
        for(char ch: word){
            ch-='a';
            if(node->children[ch]==nullptr){
                node->children[ch]=new Trie();
            }
            node=node->children[ch];
        }
        node->isEnd=true;
    }
    bool search(string word) {
        Trie *node=this->searchPrefix(word);
        return node!=nullptr && node->isEnd;
    }
    bool startsWith(string prefix) {
        return this->searchPrefix(prefix)!=nullptr;
    }
};
```

</details>

# 236 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为："对于有根树 T 的两个节点
p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x
的深度尽可能大（一个节点也可以是它自己的祖先）。"

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root){
            return nullptr;
        }
        if(root==q||root==p){
            return root;
        }
        auto left=lowestCommonAncestor(root->left,p,q);
        auto right=lowestCommonAncestor(root->right,p,q);
        if(left&&right){
            return root;
        }
        return left?left:(right?right:nullptr);
    }
};
```

</details>

# 3249 统计好节点的数目
现有一棵 无向 树，树中包含 n 个节点，按从 0 到 n - 1
标记。树的根节点是节点 0 。给你一个长度为 n - 1 的二维整数数组
edges，其中 edges\[i\] = \[ai, bi\] 表示树中节点 ai 与节点 bi
之间存在一条边。

如果一个节点的所有子节点为根的 子树 包含的节点数相同，则认为该节点是一个
好节点。

返回给定树中 好节点 的数量。

子树 指的是一个节点以及它所有后代节点构成的一棵树。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int countGoodNodes(vector<vector<int>>& edges) {
        int n=edges.size()+1;
        vector<vector<int>> g(n);
        for(auto& e:edges){
            int x=e[0],y=e[1];
            g[x].emplace_back(y);
            g[y].emplace_back(x);
        }
        int ans=0;
        auto dfs=[&](auto &&dfs,int x,int fa)->int{
            int size=1,sz0=0;
            bool ok=true;
            for(int y: g[x]){
                if(y==fa) continue;
                int sz=dfs(dfs,y,x);
                if(sz0==0){
                    sz0=sz;
                }else if(sz!=sz0){
                    ok=false;
                }
                size+=sz;
            }
            ans+=ok;
            return size;
        };
        dfs(dfs,0,-1);
        return ans;
    }
};
```

</details>

# 250 统计同值子树

给定一个二叉树，统计该二叉树数值相同的子树个数。

同值子树是指该子树的所有节点都拥有相同的数值。

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int count=0;
    bool isIsomorphic(TreeNode* node){
        if(node->left==nullptr && node->right==nullptr){
            count+=1;
            return true;
        }
        bool flag=true;
        if(node->left){
            flag=isIsomorphic(node->left) && flag && node->val==node->left->val;
        }
        if(node->right){
            flag=isIsomorphic(node->right) && flag && node->val==node->right->val;
        }
        if(!flag) return false;
        count++;
        return true;
    }
public:
    int countUnivalSubtrees(TreeNode* root) {
        if(!root) return 0;
        isIsomorphic(root);
        return count;
    }
};
```

</details>

# 1120 子树的最大平均值

给你一棵二叉树的根节点 root，找出这棵树的 每一棵 子树的 平均值 中的 最大 值。

子树是树中的任意节点和它的所有后代构成的集合。

树的平均值是树中节点值的总和除以节点数。

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    double ans;
public:
    double maximumAverageSubtree(TreeNode* root) {
        ans=0.0;
        auto [num,sum]=accumulate(root);
        ans=max(ans,(double)sum/num);
        return ans;
    }
    std::pair<int,double> accumulate(TreeNode *root){
        if(root==nullptr){
            return {0,0.0};
        }
        if(!root->left && !root->right){
            ans=max(ans,(double)root->val);
            return {1,(double)root->val};
        }
        auto [l_num,l_sum]=accumulate(root->left);
        auto [r_num,r_sum]=accumulate(root->right);
        ans=max(ans,(double)(l_sum+r_sum+root->val)/(l_num+r_num+1));
        return {l_num+r_num+1,l_sum+r_sum+root->val};
    }
};
```

</details>

# 545 二叉树的边界

二叉树的 边界 是由 根节点 、左边界 、按从左到右顺序的 叶节点 和 逆序的右边界 ，按顺序依次连接组成。

左边界 是满足下述定义的节点集合：

    根节点的左子节点在左边界中。如果根节点不含左子节点，那么左边界就为 空 。
    如果一个节点在左边界中，并且该节点有左子节点，那么它的左子节点也在左边界中。
    如果一个节点在左边界中，并且该节点 不含 左子节点，那么它的右子节点就在左边界中。
    最左侧的叶节点 不在 左边界中。

右边界 定义方式与 左边界 相同，只是将左替换成右。即，右边界是根节点右子树的右侧部分；叶节点 不是 右边界的组成部分；如果根节点不含右子节点，那么右边界为 空 。

叶节点 是没有任何子节点的节点。对于此问题，根节点 不是 叶节点。

给你一棵二叉树的根节点 root ，按顺序返回组成二叉树 边界 的这些值。

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> boundaryOfBinaryTree(TreeNode* root) {
        vector<int> res;
        dfs(root,true,true,res);
        return res;
    }
    void dfs(TreeNode *node,bool leftBound,bool rightBound,vector<int>& res){
        if(!node){
            return;
        }
        if(leftBound){
            res.push_back(node->val);
        }else if(!node->left && !node->right){
            res.push_back(node->val);
            return;
        }
        dfs(node->left,leftBound,!leftBound && rightBound&&!node->right,res);
        dfs(node->right,!rightBound&&leftBound&&!node->left,rightBound,res);
        if(!leftBound && rightBound){
            res.push_back(node->val);
        }
    }
};
```

</details>

# 366 寻找二叉树的叶子节点

给你一棵二叉树的 root 节点，请按照以下方式收集树的节点：

    收集所有的叶子节点。
    移除所有的叶子节点。
    重复以上步骤，直到树为空。

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<vector<int>> ans;
    vector<int> path;
public:
    vector<vector<int>> findLeaves(TreeNode* root) {
        if(root==nullptr){
            return {};
        }
        while(root&&( root->left || root->right)){
            dfs(root);
            ans.emplace_back(std::move(path));
        }
        ans.emplace_back(vector{root->val});
        return ans;
    }
    bool dfs(TreeNode *root){
        if(root==nullptr){
            return false;
        }
        if(!root->left && !root->right){
            path.emplace_back(root->val);
            return true;
        }
        auto isChildLeaf=dfs(root->left);
        if(isChildLeaf){
            root->left=nullptr;
        }
        isChildLeaf=dfs(root->right);
        if(isChildLeaf){
            root->right=nullptr;
        }
        return false;
    }
};
```

</details>

# 314 二叉树的垂直遍历

给你一个二叉树的根结点，返回其结点按 垂直方向（从上到下，逐列）遍历的结果。

如果两个结点在同一行和列，那么顺序则为 从左到右。

<details>

```cpp

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> verticalOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(!root){
            return result;
        }
        map<int,vector<int>> mp;
        queue<pair<TreeNode*,int>> queue;
        queue.emplace(root,0);
        while(!queue.empty()){
            auto [node,column]=queue.front();
            queue.pop();
            if(node){
                mp[column].push_back(node->val);
                if(node->left){
                    queue.emplace(node->left,column-1);
                }
                if(node->right){
                    queue.emplace(node->right,column+1);
                }
            }
        }
        for(auto& p:mp){
            result.push_back(p.second);
        }
        return result;
    }
};
```

</details>

# 270 最接近的二叉搜索树值

给你二叉搜索树的根节点 root 和一个目标值 target ，请在该二叉搜索树中找到最接近目标值 target 的数值。如果有多个答案，返回最小的那个。

<details>

```cpp
class Solution {
public:
    int closestValue(TreeNode* root, double target) {
        int closest=INT_MIN/2;
        double minDiff=INT_MAX;
        auto prev=root;
        if(root->val==target){
            return target;
        }
        std::function<void(TreeNode*)> dfs=[&](TreeNode *node){
            if(node==nullptr){
                return;
            }
            double diff=abs(node->val-target);
            if(diff<minDiff || (diff==minDiff&&node->val<closest)){
                closest=node->val;
                minDiff=diff;
            }
            dfs(node->left);
            dfs(node->right);
        };
        dfs(root);
        return closest;
    }
};
```

</details>

# 272 最接近的二叉搜索树的值Ⅱ

给定二叉搜索树的根 root 、一个目标值 target 和一个整数 k ，返回BST中最接近目标的 k 个值。你可以按 任意顺序 返回答案。

题目 保证 该二叉搜索树中只会存在一种 k 个值集合最接近 target

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> closestKValues(TreeNode* root, double target, int k) {
        vector<int> mid_traverse;
        stack<TreeNode*> st;
        int closestIndex=-1;
        if(root!=nullptr) st.push(root);
        while(!st.empty()){
            auto node=st.top();
            if(node){
                st.pop();
                if(node->right){
                    st.push(node->right);
                }
                st.push(node);
                st.push(nullptr);
                if(node->left) st.push(node->left);
            }else{
                st.pop();
                node=st.top();
                st.pop();
                if(node->val<=target){
                    closestIndex=mid_traverse.size();
                }
                mid_traverse.emplace_back(node->val);
            }
        }
        vector<int> result;
        int n=mid_traverse.size();
        int index1=closestIndex;
        int index2=closestIndex+1;
        while(k>0&&index1>=0 && index2<n){
            if(target-mid_traverse[index1]<mid_traverse[index2]-target){
                result.emplace_back(mid_traverse[index1]);
                index1--;
            }else{
                result.emplace_back(mid_traverse[index2]);
                index2++;
            }
            k--;
        }
        while(k>0&&index1>=0){
            result.emplace_back(mid_traverse[index1--]);
            k--;
        }
        while(k>0 && index2<n){
            result.emplace_back(mid_traverse[index2++]);
            k--;
        }
        return result;
    }
};
```

</details>

# 255 验证二叉搜索树的前序遍历序列

给定一个 无重复元素 的整数数组 preorder ， 如果它是以二叉搜索树的先序遍历排列 ，返回 true 。

<details>

```cpp
class Solution {
public:
    bool verifyPreorder(vector<int>& preorder) {
        stack<int> stack;
        int min = INT_MIN;
        for (auto num : preorder) {
            if (num <= min) {
                return false;
            }
            while (!stack.empty() && num > stack.top()) {
                min = stack.top();
                stack.pop();
            }
            stack.push(num);
        }
        return true;
    }
};
```

</details>

# 333 最大的二叉搜索树

给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该
子树
的大小。其中，最大指的是子树节点数最多的。

二叉搜索树（BST）中的所有节点都具备以下属性：

    左子树的值小于其父（根）节点的值。

    右子树的值大于其父（根）节点的值。

注意：子树必须包含其所有后代。

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool valid(TreeNode* root,int l,int r){
        if(!root) return 1;
        if(root->val <=l || root->val>=r)return 0;
        return valid(root->left,l,root->val) && valid(root->right,root->val,r);
    }
    int cnt(TreeNode* r){
        return r?cnt(r->left)+cnt(r->right)+1:0;
    }
    int largestBSTSubtree(TreeNode* root) {
        if(!root) return 0;
        if(valid(root,INT_MIN,INT_MAX)) return cnt(root);
        return std::max(largestBSTSubtree(root->left),largestBSTSubtree(root->right));
    }
};
```

</details>

# 588 设计内存文件系统

你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：

    -1 表示墙或是障碍物
    0 表示一扇门
    INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。

你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。

<details>

```cpp
class FileSystem {
public:
    FileSystem() {

    }
    vector<string> ls(string path) {
        auto p=find(path);
        if(!p->content.empty()){
            return {path.substr(path.rfind('/')+1)};
        }
        vector<string> res;
        for(auto& i: p->dir){
            res.emplace_back(i.first);
        }
        return res;
    }

    void mkdir(string path) {
        find(path);
    }

    void addContentToFile(string filePath, string content) {
        auto p=find(filePath);
        p->content+=content;
    }

    string readContentFromFile(string filePath) {
        auto p=find(filePath);
        return p->content;
    }
    private:
    string content;
    map<string,FileSystem*> dir;
    FileSystem* find(string path){
        for(auto& c:path){
            if(c=='/') c=' ';
        }
        stringstream ss(path);
        auto p=this;
        while(ss>>path){
            if(!p->dir.count(path)){
                p->dir[path]=new FileSystem();
            }
            p=p->dir[path];
        }
        return p;
    }
};
```

</details>

# 1522 N叉树的直径

给定一棵 N 叉树 的根节点 root ，计算这棵树的直径长度。

N 叉树的直径指的是树中任意两个节点间路径中 最长 路径的长度。这条路径可能经过根节点，也可能不经过根节点。

<details>

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int diameter(Node* root) {
        int maxHeight=0;
        auto height=[&](auto&& height,Node* node)->int{
            if(!node){
                return 0;
            }
            if(node->children.empty()){
                return 0;
            }
            int node_height=0;
            int max_1=0,max_2=0;
            for(auto c: node->children){
                int num=height(height,c)+1;
                if(num>max_1){
                    max_2=max_1;
                    max_1=num;
                }else if(num>max_2){
                    max_2=num;
                }
            maxHeight=max(maxHeight,max_1+max_2);
            }
            return max_1;
        };
    height(height,root);
       return maxHeight;
    }
};
```

</details>

# 431 将N叉树编码为二叉树

设计一个算法，可以将 N 叉树编码为二叉树，并能将该二叉树解码为原 N 叉树。一个 N 叉树是指每个节点都有不超过 N 个孩子节点的有根树。类似地，一个二叉树是指每个节点都有不超过 2 个孩子节点的有根树。你的编码 / 解码的算法的实现没有限制，你只需要保证一个 N 叉树可以编码为二叉树且该二叉树可以解码回原始 N 叉树即可。

<details>

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Codec {
public:
    // Encodes an n-ary tree to a binary tree.
    TreeNode* encode(Node* root) {
        if(!root){
            return nullptr;
        }
        auto newRoot=new TreeNode(root->val);
        queue<pair<TreeNode*,Node*>> q;
        q.emplace(newRoot,root);
        while(!q.empty()){
            auto [bNode,nNode]=q.front();
            q.pop();
            TreeNode* prevBNode=nullptr;
            TreeNode* headBNode=nullptr;
            for(auto nChild: nNode->children){
                auto newBNode=new TreeNode(nChild->val);
                if(!prevBNode){
                    headBNode=newBNode;
                }else{
                    prevBNode->right=newBNode;
                }
                prevBNode=newBNode;
                q.emplace(newBNode,nChild);
            }
            bNode->left=headBNode;
        }
        return newRoot;
    }

    // Decodes your binary tree to an n-ary tree.
    Node* decode(TreeNode* root) {
        if(!root){
            return nullptr;
        }
        auto newRoot=new Node(root->val);
        queue<pair<Node*,TreeNode*>> q;
        q.emplace(newRoot,root);
        while(!q.empty()){
            auto [nNode,bNode]=q.front();
            q.pop();
            auto firstChild=bNode->left;
            auto sibling=firstChild;
            while(sibling){
                auto nChild=new Node(sibling->val);
                nNode->children.emplace_back(nChild);
                q.emplace(nChild,sibling);
                sibling=sibling->right;
            }
        }
        return newRoot;
    }
};
```

</details>

# 428 序列化和反序列化N叉树

序列化是指将一个数据结构转化为位序列的过程，因此可以将其存储在文件中或内存缓冲区中，以便稍后在相同或不同的计算机环境中恢复结构。

设计一个序列化和反序列化 N 叉树的算法。一个 N 叉树是指每个节点都有不超过 N 个孩子节点的有根树。序列化 / 反序列化算法的算法实现没有限制。你只需要保证 N 叉树可以被序列化为一个字符串并且该字符串可以被反序列化成原树结构即可。

<details>

```cpp
class WrappableInt {
public:
    int value;
    WrappableInt(int x) : value(x) {}

    int getValue() {
        return value;
    }

    void increment(int x) {
        value += x;
    }
};

class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(Node* root) {
        string sb;
        _serializeHelper(root, sb);
        return sb;
    }

    // Helper function for serialization
    void _serializeHelper(Node* root, string& sb) {
        if (root == nullptr) {
            return;
        }
        // Append the node's value
        sb += "@" + to_string(root->val);
        // Append the number of children
        sb += "@" + to_string(root->children.size());
        // Recursively serialize the children
        for (Node* child : root->children) {
            _serializeHelper(child, sb);
        }
    }

    // Decodes your encoded data to tree.
    Node* deserialize(string data) {
        if (data.empty()) {
            return nullptr;
        }
        WrappableInt index(0); // Wrapper for the current index in the data
        return _deserializeHelper(data, index);
    }

    // Helper function for deserialization
    Node* _deserializeHelper(const string& data, WrappableInt& index) {
        if (index.getValue() == data.length()) {
            return nullptr;
        }

        // Create the node using the current character
        size_t pos = 0;
        index.increment(1);
        int val = stoi(data.substr(index.getValue(), 5), &pos);
        Node* node = new Node(val);
        index.increment(pos);
        index.increment(1);
        int numChildren = stoi(data.substr(index.getValue(), 5), &pos);
        index.increment(pos);
        // Recursively deserialize the children
        for (int i = 0; i < numChildren; i++) {
            node->children.push_back(_deserializeHelper(data, index));
        }

        return node;
    }
};
```

</details>

# 2196 根据描述创建二叉树

给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：

    如果 isLefti == 1 ，那么 childi 就是 parenti 的左子节点。
    如果 isLefti == 0 ，那么 childi 就是 parenti 的右子节点。

请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。

测试用例会保证可以构造出 有效 的二叉树。

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    unordered_map<int,TreeNode*> treeMap;
    unordered_map<int,bool> is_root;
public:
    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {
        TreeNode *root;
        for(auto & each: descriptions){
            auto rValue=each[0];
            if(!is_root.contains(rValue)){
                is_root[rValue]=true;
            }
            is_root[each[1]]=false;
            TreeNode* cur;
            if(treeMap.contains(rValue)){
                cur=treeMap[rValue];
            }else{
                cur=new TreeNode(rValue);
                treeMap[rValue]=cur;
            }
            TreeNode* child;
            if(treeMap.contains(each[1])){
                child=treeMap[each[1]];
            }else{
                child=new TreeNode(each[1]);
                treeMap[each[1]]=child;
            }
            if(each[2]){
                cur->left=child;
            }else{
                cur->right=child;
            }
        }
        for(auto& [index,r]: is_root){
            if(r){
                return treeMap[index];
            }
        }
        return nullptr;
    }
};
```

</details>

# 958 二叉树的完全性检验

给你一棵二叉树的根节点 root ，请你判断这棵树是否是一棵 完全二叉树 。

在一棵 完全二叉树 中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都尽可能靠左。最后一层（第 h 层）中可以包含 1 到 2h 个节点。

<details>

```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        queue<TreeNode*> qu;
        qu.push(root);
        bool flag=false;
        while(qu.size()){
            auto node=qu.front();
            qu.pop();
            if(node==nullptr){
                flag=true;
                continue;
            }else{
                if(flag){
                    return false;
                }
                qu.emplace(node->left);
                qu.emplace(node->right);
            }
        }
        return true;
    }
};
```

</details>

# 1644 二叉树的最近公共祖先Ⅱ

给定一棵二叉树的根节点 root，返回给定节点 p 和 q 的最近公共祖先（LCA）节点。如果 p 或 q 之一 不存在 于该二叉树中，返回 null。树中的每个节点值都是互不相同的。

根据维基百科中对最近公共祖先节点的定义：“两个节点 p 和 q 在二叉树 T 中的最近公共祖先节点是 后代节点 中既包括 p 又包括 q 的最深节点（我们允许 一个节点为自身的一个后代节点 ）”。一个节点 x 的 后代节点 是节点 x 到某一叶节点间的路径中的节点 y。

<details>

```cpp
class Solution {
    bool flag_p=false,flag_q=false;
public:
    void dfs(TreeNode *root,TreeNode *p,TreeNode *q){
        if(root==p) flag_p=true;
        if(root==q) flag_q=true;
        if(root->left) dfs(root->left,p,q);
        if(root->right) dfs(root->right,p,q);
    }
    TreeNode *dfs_LRN(TreeNode *root,TreeNode *p,TreeNode *q){
        if(!root || root==p || root==q) return root;
        auto l=dfs_LRN(root->left,p,q);
        auto r=dfs_LRN(root->right,p,q);
        if(l && r){
            return root;
        }else if(l){
            return l;
        }else if(r){
            return r;
        }else{
            return nullptr;
        }
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root,p,q);
        if(!(flag_p && flag_q)) return nullptr;
        return dfs_LRN(root,p,q);
    }
};
```

</details>

# 1530 好叶子节点对的数量

给你二叉树的根节点 root 和一个整数 distance 。

如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。

返回树中 好叶子节点对的数量 。

<details>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int ans=0;
public:
    int countPairs(TreeNode* root, int distance) {
        dfs(root,distance);
        return ans;
    }
    vector<int> dfs(TreeNode *root,int distance){
        if(!root){
            return {};
        }
        if(!root->left && !root->right){
            return {0};
        }
        vector<int> res;
        auto left=dfs(root->left,distance);
        for(auto& n:left){
            if(++n>distance) continue;
            res.push_back(n);
        }
        auto right=dfs(root->right,distance);
        for(auto& n:right){
            if(++n>distance) continue;
            res.push_back(n);
        }
        for(auto l:left){
            for(auto r:right){
                ans+=(l+r<=distance);
            }
        }
        return res;
    }
};
```

</details>

# 666 路径总和Ⅳ

对于一棵深度小于 5 的树，可以用一组三位十进制整数来表示。给定一个由三位数组成的 递增 的数组 nums 表示一棵深度小于 5 的二叉树，对于每个整数：

    百位上的数字表示这个节点的深度 d，1 <= d <= 4。
    十位上的数字表示这个节点在当前层所在的位置 p， 1 <= p <= 8。位置编号与一棵 满二叉树 的位置编号相同。
    个位上的数字表示这个节点的权值 v，0 <= v <= 9。

返回从 根 到所有 叶子结点 的 路径 之 和。

保证 给定的数组表示一个有效的连接二叉树。

<details>

```cpp
class Solution {
public:
    int pathSum(vector<int>& nums) {
        unordered_map<int,int> map;
        int allSum=0;
        for(int num:nums){
            map[num/10]=num%10;
        }
        auto traverse=[&](this auto&& traverse,int dp,int sum)->int{
            if(!map.contains(dp)) return 0;
            sum+=map[dp];
            int depth=dp/10;
            int pos=dp%10;
            int left=(depth+1)*10+2*pos-1;
            int right=left+1;
            if(!map.contains(left) && !map.contains(right)){
                allSum+=sum;
            }else{
                traverse(left,sum);
                traverse(right,sum);
            }
            return 0;
        };
        traverse(nums[0]/10,0);
        return allSum;
    }
};
```

</details>
