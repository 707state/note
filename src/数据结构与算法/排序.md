# 280 摆动序列

给你一个的整数数组 nums, 将该数组重新排序后使 nums[0] <= nums[1] >= nums[2] <= nums[3]... 

输入数组总是有一个有效的答案。
```cpp
class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        ranges::sort(nums);
        for(int i=1;i<nums.size()-1;i+=2){
            swap(nums[i],nums[i+1]);
        }
    }
};
```

# 324 摆动序列 2 

给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

```cpp
class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        int n=nums.size();
        vector<int> arr=nums;
        ranges::sort(arr);
        int x=(n+1)/2;
        for(int i=0,j=x-1,k=n-1;i<n;i+=2,j--,k--){
            nums[i]=arr[j];
            if(i+1<n){
                nums[i+1]=arr[k];
            }
        }
    }
};
```
# 327 区间和的个数

给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。

区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

```cpp
class Solution {
public:
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        long s=0;
        vector<long> sum{0};
        for(auto& v:nums){
            s+=v;
            sum.emplace_back(s);
        }
        function<int(int,int,int,int)> countRangeSumRecur=[&](int lower,int upper,int left,int right)->int{
            if(left==right) return 0;
            int mid=(left+right)/2;
            int n1=countRangeSumRecur(lower,upper,left,mid);
            int n2=countRangeSumRecur(lower,upper,mid+1,right);
            int ret=n1+n2;
            int i=left;
            int l=mid+1;
            int r=mid+1;
            while(i<=mid){
                while(l<=right&&sum[l]-sum[i]<lower) l++;
                while(r<=right&&sum[r]-sum[i]<=upper) r++;
                ret+=(r-l);
                i++;
            }
            vector<long> sorted(right-left+1);
            int p1=left,p2=mid+1;
            int p=0;
            while(p1<=mid||p2<=right){
                if(p1>mid) sorted[p++]=sum[p2++];
                else if(p2>right) sorted[p++]=sum[p1++];
                else {
                    if(sum[p1]<sum[p2]) sorted[p++]=sum[p1++];
                    else sorted[p++]=sum[p2++];
                }
            }
            for(int i=0;i<sorted.size();i++) sum[left+i]=sorted[i];
            return ret;
        };
        return countRangeSumRecur(lower,upper,0,sum.size()-1);
    }
};
```



