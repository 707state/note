<!--toc:start-->
- [200 岛屿数量](#200-岛屿数量)
- [310 最小高度树](#310-最小高度树)
- [1436 旅行终点站](#1436-旅行终点站)
- [1293 网格中的最短路径](#1293-网格中的最短路径)
- [801 找到最终的安全状态](#801-找到最终的安全状态)
- [841 钥匙与房间](#841-钥匙与房间)
- [797 所有可能路径](#797-所有可能路径)
- [2093 前往目标城市的最小费用](#2093-前往目标城市的最小费用)
- [1192 查找集群内的关键连接](#1192-查找集群内的关键连接)
- [127 单词接龙](#127-单词接龙)
- [218 扫描线问题](#218-扫描线问题)
- [505 迷宫 2](#505-迷宫-2-505-迷宫-2)
- [1557 可以到达所有点的最少点数目](#1557-可以到达所有点的最少点数目)
- [864 获取所有钥匙的最短路径](#864-获取所有钥匙的最短路径)
- [721 账户合并](#721-账户合并)
- [839 相似字符串组](#839-相似字符串组)
- [210 课程表 2 {#210-课程表 2}](#210-课程表-2-210-课程表-2)
- [269 火星词典](#269-火星词典)
- [1203 项目管理](#1203-项目管理)
- [1857 有向图中最大颜色值](#1857-有向图中最大颜色值)
- [994. 腐烂的橘子](#994-腐烂的橘子)
- [684. 冗余连接](#684-冗余连接)
- [685 冗余连接 2](#685-冗余连接-2-685-冗余连接-2)
- [499 迷宫 3](#499-迷宫-3-499-迷宫-3)
- [1168 水资源分配优化](#1168-水资源分配优化)
- [1489. 找到最小生成树里的关键边和伪关键边](#1489-找到最小生成树里的关键边和伪关键边)
- [UNSOLVED 936 戳印序列](#unsolved-936-戳印序列)
  - [思路](#思路)
- [133 克隆图](#133-克隆图)
- [785 判断二分图](#785-判断二分图)
- [UNSOLVED 787 K 站中转内最便宜的航班](#unsolved-787-k-站中转内最便宜的航班)
- [741 网络延迟时间](#741-网络延迟时间)
- [85 最大矩形](#85-最大矩形)
- [913 猫和老鼠](#913-猫和老鼠)
- [1059 从起点到终点的所有路径](#1059-从起点到终点的所有路径)
- [305 岛屿数量Ⅱ](#305-岛屿数量ⅱ)
- [694 不同岛屿的数量](#694-不同岛屿的数量)
- [1136 并行课程](#1136-并行课程)
- [UNSOLVED 1728 猫和老鼠Ⅱ](#unsolved-1728-猫和老鼠ⅱ)
- [1197 进击的骑士](#1197-进击的骑士)
- [286 墙与门](#286-墙与门)
- [UNSOLVED 499 迷宫3](#unsolved-499-迷宫3)
- [317 UNSOLVED 离建筑物最近的距离](#317-unsolved-离建筑物最近的距离)
<!--toc:end-->


# 200 岛屿数量
给你一个由 \'1\'（陆地）和
\'0\'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    constexpr static array<int, 4> dx{1, 0, -1, 0};
    constexpr static array<int, 4> dy{0, 1, 0, -1};

public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        std::function<void(int, int)> dfs = [&](int x, int y) {
            grid[x][y] = '0';
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (nx >= 0 && nx < n && ny >= 0 && ny < m &&
                    grid[nx][ny] == '1') {
                    dfs(nx, ny);
                }
            }
        };
        for (int x = 0; x < n; x++) {
            for (int y = 0; y < m; y++) {
                if (grid[x][y] == '1') {
                    ans++;
                    dfs(x, y);
                }
            }
        }
        return ans;
    }
};
```

</details>

# 310 最小高度树

树是一个无向图，其中任何两个顶点只通过一条路径连接。
换句话说，任何一个没有简单环路的连通图都是一棵树。

给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1
条无向边的 edges 列表（每一个边都是一对标签），其中 edges\[i\] = \[ai,
bi\] 表示树中节点 ai 和 bi 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 x
作为根节点时，设结果树的高度为 h
。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。

请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树的
高度 是指根节点和叶子节点之间最长向下路径上边的数量。

广度优先搜索法：

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int findLongestNode(int u, vector<int>& parent,
                        vector<vector<int>>& graph) {
        int n = graph.size();
        queue<int> qu;
        vector<bool> visited(n);
        qu.emplace(u);
        visited[u] = true;
        int node = -1;
        while (!qu.empty()) {
            int curr = qu.front();
            qu.pop();
            node = curr;
            for (auto& v : graph[curr]) {
                if (!visited[v]) {
                    visited[v] = true;
                    parent[v] = curr;
                    qu.emplace(v);
                }
            }
        }
        return node;
    }
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        if (n == 1)
            return {0};
        vector<vector<int>> graph(n);
        for (auto& each : edges) {
            graph[each[0]].emplace_back(each[1]);
            graph[each[1]].emplace_back(each[0]);
        }
        vector<int> parent(n, -1);
        int x = findLongestNode(0, parent, graph);
        int y = findLongestNode(x, parent, graph);
        vector<int> path;
        parent[x] = -1;
        while (y != -1) {
            path.emplace_back(y);
            y = parent[y];
        }
        int m = path.size();
        if (m & 1) {
            return {path[m / 2]};
        } else {
            return {path[m / 2 - 1], path[m / 2]};
        }
    }
};
```

</details>

拓扑排序解法：

<details><summary>Click to expand</summary>

```cpp
class Solution {
    vector<vector<int>> graph;
    vector<int> degree;

public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        degree.resize(n);
        graph.resize(n);
        for (auto& each : edges) {
            graph[each[0]].emplace_back(each[1]);
            graph[each[1]].emplace_back(each[0]);
            degree[each[0]]++;
            degree[each[1]]++;
        }
        queue<int> qu;
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            if (degree[i] == 1)
                qu.push(i);
        }
        int remainNodes = n;
        while (remainNodes > 2) {
            int size = qu.size();
            remainNodes -= size;
            for (int i = 0; i < size; i++) {
                int curr = qu.front();
                qu.pop();
                for (auto& v : graph[curr]) {
                    if (--degree[v] == 1) {
                        qu.emplace(v);
                    }
                }
            }
        }
        while (!qu.empty()) {
            ans.emplace_back(qu.front());
            qu.pop();
        }
        return ans;
    }
};
```

</details>

# 1436 旅行终点站
给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中
paths\[i\] = \[cityAi, cityBi\] 表示该线路将会从 cityAi 直接前往 cityBi
。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。

题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_map<string, int> degree;
        unordered_map<string, vector<string>> graph;
        for (auto& edge : paths) {
            graph[edge[0]].emplace_back(edge[1]);
            if (degree.find(edge[0]) == degree.end()) {
                degree[edge[0]] = 0;
            }
            degree[edge[1]]++;
        }
        queue<string> que;
        for (auto& each : degree) {
            if (each.second == 0) {
                que.emplace(each.first);
            }
        }
        string ans;
        while (que.size()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                auto cur = que.front();
                ans = cur;
                que.pop();
                for (auto& each : graph[cur]) {
                    if (--degree[each] == 0) {
                        que.emplace(each);
                    }
                }
            }
        }
        return ans;
    }
};
```

</details>

# 1293 网格中的最短路径
给你一个 m \* n 的网格，其中每个单元格不是 0（空）就是
1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。

如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1,
n-1)
的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1
。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    using triple = std::array<int, 3>;
    static constexpr std::array<int, 4> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};

public:
    int shortestPath(vector<vector<int>>& grid, int k) {
        int n = grid.size();
        int m = grid[0].size();
        if (m == 1 && n == 1)
            return 0;
        k = min(k, m + n - 3);
        vector<vector<vector<bool>>> visited(
            n, vector<vector<bool>>(m, vector<bool>(k + 1, false)));
        queue<triple> q;
        q.emplace(array{0, 0, k});
        visited[0][0][k] = true;
        for (int step = 1; q.size() > 0; step++) {
            int cnt_size = q.size();
            for (int i = 0; i < cnt_size; i++) {
                auto [x, y, rest] = q.front();
                q.pop();
                for (int j = 0; j < 4; j++) {
                    int nx = x + dx[j];
                    int ny = y + dy[j];
                    if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                        if (grid[nx][ny] == 0 && !visited[nx][ny][rest]) {
                            if (nx == n - 1 && ny == m - 1) {
                                return step;
                            }
                            q.emplace(array{nx, ny, rest});
                            visited[nx][ny][rest] = true;
                        } else if (grid[nx][ny] == 1 && rest > 0 &&
                                   !visited[nx][ny][rest - 1]) {
                            q.emplace(array{nx, ny, rest - 1});
                            visited[nx][ny][rest - 1] = true;
                        }
                    }
                }
            }
        }
        return -1;
    }
};
```

</details>

# 801 找到最终的安全状态
有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0
开始 的 2D 整数数组 graph 表示， graph\[i\]是与节点 i
相邻的节点的整数数组，这意味着从节点 i 到
graph\[i\]中的每个节点都有一条边。

如果一个节点没有连出的有向边，则该节点是 终端节点
。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。

返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按
升序 排列。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n=graph.size();
        vector<int> color(n,0);
        function<bool(int)> safe=[&](int x)->bool{
            if(color[x]>0){
                return color[x]==2;
            }
            color[x]=1;
            for(auto& y:graph[x]){
                if(!safe(y)) return false;
            }
            color[x]=2;
            return true;
        };
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(safe(i)) ans.emplace_back(i);
        }
        return ans;
    }
};
```

</details>

# 841 钥匙与房间
有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0
号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。

当你进入一个房间，你可能会在里面找到一套
不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。

给你一个数组 rooms 其中 rooms\[i\] 是你进入 i
号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回
false。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n=rooms.size();
        vector<int> room_id(n,0);
        function<void(int)> next_foor=[&](int n){
            room_id[n]=1;
            for(auto& y:rooms[n]){
                if(!room_id[y]) next_foor(y);
            }
        };
        next_foor(0);
        for(int i=0;i<n;i++){
            if(room_id[i]==0) return false;
        }
        return true;
    }
};
```

</details>

# 797 所有可能路径
给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1
的路径并输出（不要求按特定顺序）

graph\[i\] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点
graph\[i\]\[j\]存在一条有向边）。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        int n=graph.size();
        vector<vector<int>> result;
        vector<int> path;
        function<void(int)> find_path=[&](int x){
            if(x==n-1){
                result.emplace_back(path);
                return;
            }
            for(auto & n: graph[x]){
                path.emplace_back(n);
                find_path(n);
                path.pop_back();
            }
        };
        path.push_back(0);
        find_path(0);

        return result;
    }
};
```

</details>

# 2093 前往目标城市的最小费用
一组公路连接 n 个城市，城市编号为从 0 到 n - 1 。 输入包含一个二维数组
highways ，其中 highways\[i\] = \[city1i, city2i, tolli\]
表示有一条连接城市 city1i 和 city2i 的双向公路，允许汽车缴纳值为 tolli
的费用从 city1i 前往 city2i 或 从 city2i 前往 city1i 。

另给你一个整数 discounts
表示你最多可以使用折扣的次数。你可以使用一次折扣使通过第 ith
条公路的费用降低至 tolli / 2（向下取整）。 最多只可使用 discounts
次折扣， 且 每条公路最多只可使用一次折扣 。

返回从城市 0 前往城市 n - 1 的 最小费用 。如果不存在从城市 0 前往城市 n -
1 的路径，返回 -1 。

分层图最短路问题。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& highways, int discounts) {
        vector<vector<vector<int>>> graph(n);
        for(auto& v: highways){
            graph[v[0]].emplace_back(vector{v[1],v[2]});
            graph[v[1]].emplace_back(vector{v[0],v[2]});
        }
        priority_queue<vector<int>,vector<vector<int>> ,greater<vector<int>>> pq;
        vector<vector<int>> dist(n,vector(discounts+1,INT_MAX));
        dist[0][0]=0;
        pq.push({0,0,0});
        while(!pq.empty()){
            auto t=pq.top();
            pq.pop();
            int w=t[0],u=t[1],cnt=t[2];
            if(w>dist[u][cnt]) continue;
            if(cnt<discounts&&dist[u][cnt+1]>w){//同一个节点，不同的折扣层次
                dist[u][cnt+1]=w;
                pq.push({w,u,cnt+1});
            }
            for(auto& e: graph[u]){//遍历相邻的点
                int v=e[0],d=e[1];
                if(dist[v][cnt]>w+d){//同层不打折
                    dist[v][cnt]=w+d;
                    pq.push({w+d,v,cnt});
                }
                if(cnt<discounts&&dist[v][cnt+1]>w+d/2){//下一层且打折
                    dist[v][cnt+1]=w+d/2;
                    pq.push({w+d/2,v,cnt+1});
                }
            }
        }
        return dist[n-1][discounts]==INT_MAX? -1: dist[n-1][discounts];
    }
};
```

</details>

# 1192 查找集群内的关键连接
力扣数据中心有 n 台服务器，分别按从 0 到 n-1
的方式进行了编号。它们之间以 服务器到服务器
的形式相互连接组成了一个内部集群，连接是无向的。用 connections
表示集群网络，connections\[i\] = \[a, b\] 表示服务器 a 和 b
之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。

关键连接
是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。

请你以任意顺序返回该集群内的所有 关键连接 。

思路：

[Tarjan 算法](https://www.youtube.com/watch?v=_1TDxihjtoE)

[割边割点](https://oi-wiki.org/graph/cut/)

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<vector<int>> criticalConnections(int n,
                                            vector<vector<int>>& connections) {
        vector<vector<int>> graph(n);
        for (auto& con : connections) {
            int u = con.at(0);
            int v = con.at(1);
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
        vector<vector<int>> ans;
        vector<int> time(n);//dfs过程中，初次访问某个节点时的时间戳
        vector<int> low(n);//每个节点的最小追溯值
        int num{0};//自增数字，用来赋值给节点的时间戳
        dfs(0, 0, graph, time, low, ans, num);//从顶点0开始，并认为其前去节点是0
        return ans;
    }
    void dfs(int u, int pa, vector<vector<int>>& graph, vector<int>& time,
             vector<int>& low, vector<vector<int>>& ans, int& num) {
        low[u] = time[u] = ++num;
        for (auto v : graph[u]) {
            if (time[v] == 0) { // 发现新节点v
                dfs(v, u, graph, time, low, ans, num);
                low[u] = min(low[u], low[v]);
                if (low[v] > time[u]) { // 发现桥边，添加到结果集
                    ans.emplace_back(vector{u, v});
                }
            } else if (
                time[v] < time[u] &&
                v !=
                    pa) { // v在u之前已经被访问过了，因为是无向图，u可以反向访问到其dfs搜索树上的父节点，此时需要跳过
                low[u] = min(low[u], time[v]);
            }
        }
    }
};
```

</details>

# 127 单词接龙
字典 wordList 中从单词 beginWord 到 endWord 的 转换序列
是一个按下述规格形成的序列 beginWord -\> s1 -\> s2 -\> \... -\> sk：

每一对相邻的单词只差一个字母。 对于 1 \<= i \<= k 时，每个 si 都在
wordList 中。注意， beginWord 不需要在 wordList 中。

给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从
beginWord 到 endWord 的 最短转换序列 中的 单词数目
。如果不存在这样的转换序列，返回 0。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    unordered_map<string,int> wordId;
    vector<vector<int>> graph;
    int nodeNum=0;
    void addWord(string& str){
        if(!wordId.count(str)){
            wordId[str]=nodeNum++;
            graph.emplace_back();
        }
    }
    void addEdge(string& word){
        addWord(word);
        int id1=wordId[word];
        for(char& it: word){
            char tmp=it;
            it='*';
            addWord(word);
            int id2=wordId[word];
            graph[id1].push_back(id2);
            graph[id2].push_back(id1);
            it=tmp;
        }
    }
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        for(auto& word: wordList){
            addEdge(word);
        }
        addEdge(beginWord);
        if(!wordId.count(endWord)){
            return 0;
        }
        vector<int> dis(nodeNum,INT_MAX);
        int beginId=wordId[beginWord];
        int endId=wordId[endWord];
        dis[beginId]=0;
        queue<int> que;
        que.push(beginId);
        while(!que.empty()){
            int x=que.front();
            que.pop();
            if(x==endId){
                return dis[endId]/2+1;
            }
            for(auto& it: graph[x]){
                if(dis[it]==INT_MAX){
                    dis[it]=dis[x]+1;
                    que.push(it);
                }
            }
        }
        return 0;
    }
};
```

</details>

# 218 扫描线问题
城市的 天际线
是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回
由这些建筑物形成的 天际线 。

每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings\[i\] =
\[lefti, righti, heighti\] 表示：

    lefti 是第 i 座建筑物左边缘的 x 坐标。
    righti 是第 i 座建筑物右边缘的 x 坐标。
    heighti 是第 i 座建筑物的高度。

你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。

天际线 应该表示为由 "关键点" 组成的列表，格式
\[\[x1,y1\],\[x2,y2\],\...\] ，并按 x 坐标 进行 排序
。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y
坐标始终为 0
，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

注意：输出天际线中不得有连续的相同高度的水平线。例如 \[\...\[2 3\], \[4
5\], \[7 5\], \[11 5\], \[12 7\]\...\] 是不正确的答案；三条高度为 5
的线应该在最终输出中合并为一个：\[\...\[2 3\], \[4 5\], \[12 7\], \...\]

思路：

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        auto cmp = [](const pair<int, int>& a,
                      const pair<int, int>& b) -> bool {
            return a.second < b.second;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>> ,decltype(cmp)> que(cmp);
        vector<int> boundaries;
        for(auto& building: buildings){
            boundaries.emplace_back(building[0]);
            boundaries.emplace_back(building[1]);
        }
        ranges::sort(boundaries);
        vector<vector<int>> ans;
        int n=buildings.size();
        int idx=0;
        for(auto& boundary: boundaries){
            while(idx<n && buildings[idx][0]<=boundary){
                que.emplace(buildings[idx][1],buildings[idx][2]);
                idx++;
            }
            while(!que.empty()&&que.top().first<=boundary){
                que.pop();
            }
            int maxn=que.empty()?0:que.top().second;
            if(ans.size()==0||maxn!=ans.back()[1]){
                ans.push_back({boundary,maxn});
            }
        }
        return ans;
    }
};
```

</details>

# 505 迷宫 2 {#505-迷宫 2}

迷宫中有一个球，它有空地 (表示为 0) 和墙 (表示为 1)。球可以向上、向下、向左或向右滚过空地，但直到撞上墙之前它都不会停止滚动。当球停止时，它才可以选择下一个滚动方向。

给定 m × n 的迷宫(maze)，球的起始位置 (start = \[startrow, startcol\])
和目的地 (destination = \[destinationrow,
destinationcol\])，返回球在目的地 (destination)
停止的最短距离。如果球不能在目的地 (destination) 停止，返回 -1。

距离是指球从起始位置 ( 不包括 ) 到终点 ( 包括 ) 所经过的空地数。

你可以假设迷宫的边界都是墙 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int ans=INT_MAX;
        int n=maze.size();
        int m=maze.front().size();
        vector<vector<int>> graph(n,vector<int>(m,INT_MAX));
        graph[start[0]][start[1]]=0;
        queue<pair<int,int>> que;
        que.emplace(start[0],start[1]);
        while(!que.empty()){
            auto [x,y]=que.front();
            que.pop();
            for(auto [dx,dy]: vector<pair<int,int>>{{1,0},{-1,0},{0,1},{0,-1}}){
                auto nx=x+dx;
                auto ny=y+dy;
                int step=1;
                while(nx>=0&&nx<n&&ny>=0&&ny<m&&maze[nx][ny]==0){
                    nx+=dx;
                    ny+=dy;
                    step++;
                }
                nx-=dx;
                ny-=dy;
                step--;
                if(graph[x][y]+step<graph[nx][ny]){
                    graph[nx][ny]=graph[x][y]+step;
                    que.emplace(nx,ny);
                }
            }
        }
        if(graph[destination[0]][destination[1]]==INT_MAX) return -1;
        return graph[destination[0]][destination[1]];
    }
};
```

</details>

# 1557 可以到达所有点的最少点数目
给你一个 有向无环图 ， n 个节点编号为 0 到 n-1 ，以及一个边数组 edges
，其中 edges\[i\] = \[fromi, toi\] 表示一条从点 fromi 到点 toi
的有向边。

找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。

你可以以任意顺序返回这些节点编号。

思路：

寻找入度为零的节点就完事。

<details><summary>Click to expand</summary>

```cpp
class Solution {
 public:
  vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {
    vector<int> inDegree(n + 1, 0);
    vector<int> outDegree(n + 1, 0);
    for (auto&& k : edges) {
      inDegree[k[1]]++;
      outDegree[k[0]]++;
    }
    vector<int> ans;
    for (int i = 0; i < n; i++) {
      if (inDegree[i] == 0 && outDegree[i] != 0) ans.push_back(i);
    }
    return ans;
  }
};
```

</details>

# 864 获取所有钥匙的最短路径
给定一个二维网格 grid ，其中：

    '.' 代表一个空房间
    '#' 代表一堵墙
    '@' 是起点
    小写字母代表钥匙
    大写字母代表锁

我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。

假设 k 为 钥匙/锁 的个数，且满足 1 \<= k \<= 6，字母表中的前 k
个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。

返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    static constexpr array<int,4> dx={0,1,0,-1};
    static constexpr array<int,4> dy={1,0,-1,0};
public:
    int shortestPathAllKeys(vector<string>& grid) {
        int n=grid.size(),m=grid[0].size();
        int sx=0,sy=0;
        unordered_map<char,int> key_to_idx;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]=='@'){
                    sx=i;sy=j;
                }else if(islower(grid[i][j])){
                    if(!key_to_idx.count(grid[i][j])){
                        int idx=key_to_idx.size();
                        key_to_idx[grid[i][j]]=idx;
                    }
                }
            }
        }
        queue<tuple<int,int,int>> q;
        vector<vector<vector<int>>> dist(n,vector<vector<int>>(m,vector<int>(1<<key_to_idx.size(),-1)));
        q.emplace(sx,sy,0);
        dist[sx][sy][0]=0;
        while(!q.empty()){
            auto [x,y,mask]=q.front();
            q.pop();
            for(int i=0;i<4;i++){
                int nx=x+dx[i];
                int ny=y+dy[i];
                if(nx>=0&&nx<n&&ny>=0&&ny<m&&grid[nx][ny]!='#'){
                    if(grid[nx][ny]=='.'||grid[nx][ny]=='@'){
                        if(dist[nx][ny][mask]==-1){
                            dist[nx][ny][mask]=dist[x][y][mask]+1;
                            q.emplace(nx,ny,mask);
                        }
                    }else if(islower(grid[nx][ny])){
                        int idx=key_to_idx[grid[nx][ny]];
                        if(dist[nx][ny][mask|1<<idx]==-1){
                            dist[nx][ny][mask|(1<<idx)]=dist[x][y][mask]+1;
                            if((mask|(1<<idx))==(1<<key_to_idx.size())-1){
                                return dist[nx][ny][mask|(1<<idx)];
                            }
                            q.emplace(nx,ny,mask|(1<<idx));
                        }
                    }else{
                        int idx=key_to_idx[tolower(grid[nx][ny])];
                        if((mask&(1<<idx))&&dist[nx][ny][mask]==-1){
                            dist[nx][ny][mask]=dist[x][y][mask]+1;
                            q.emplace(nx,ny,mask);
                        }
                    }
                }
            }
        }
        return -1;
    }
};
```

</details>

# 721 账户合并
给定一个列表 accounts，每个元素 accounts\[i\]
是一个字符串列表，其中第一个元素 accounts\[i\]\[0\] 是 名称
(name)，其余元素是 emails 表示该账户的邮箱地址。

现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。

合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是
按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。

<details><summary>Click to expand</summary>

```cpp
class UnionFind{
    vector<int> parent;
    public:
    UnionFind(int n){
        parent.resize(n);
        iota(parent.begin(),parent.end(),0);
    }
    void unionSet(int i1,int i2){
        parent[find(i2)]=find(i1);
    }
    int find(int index){
        if(parent[index]!=index){
            parent[index]=find(parent[index]);
        }
        return parent[index];
    }
};
class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        map<string,string> emailToName;
        map<string,int> emailToIndex;
        int emailsCount=0;
        for(auto& a: accounts){
            auto name=a[0];
            int size=a.size();
            for(int i=1;i<size;i++){
                string& email=a[i];
                if(!emailToIndex.count(email)){
                    emailToIndex[email]=emailsCount++;
                    emailToName[email]=name;
                }
            }
        }
        UnionFind uf(emailsCount);
        for(auto &account: accounts){
            string& firstEmail=account[1];
            int firstIndex=emailToIndex[firstEmail];
            int size=account.size();
            for(int i=2;i<size;i++){
                string& nextEmail=account[i];
                int nextIndex=emailToIndex[nextEmail];
                uf.unionSet(firstIndex, nextIndex);
            }
        }
        map<int,vector<string>> indexToEmails;
        for(auto &[email,_]: emailToIndex){
            int index=uf.find(emailToIndex[email]);
            vector<string>& account=indexToEmails[index];
            account.emplace_back(email);
            indexToEmails[index]=account;
        }
        vector<vector<string>> merged;
        for(auto& [_,emails]: indexToEmails){
            ranges::sort(emails);
            string& name=emailToName[emails[0]];
            vector<string> account;
            account.emplace_back(name);
            for(auto& email: emails){
                account.emplace_back(email);
            }
            merged.emplace_back(account);
        }
        return merged;
    }
};
```

</details>

# 839 相似字符串组
如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X
和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。

例如，\"tars\" 和 \"rats\" 是相似的 (交换 0 与 2 的位置)； \"rats\" 和
\"arts\" 也是相似的，但是 \"star\" 不与 \"tars\"，\"rats\"，或 \"arts\"
相似。

总之，它们通过相似性形成了两个关联组：{\"tars\", \"rats\", \"arts\"} 和
{\"star\"}。注意，\"tars\" 和 \"arts\"
是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 strs。列表中的每个字符串都是 strs
中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？

<details><summary>Click to expand</summary>

```cpp
class Solution {
    vector<int> parent;
    int find(int index) {
        if (parent[index] != index) {
            parent[index] = find(parent[index]);
        }
        return parent[index];
    }
    bool check(string& a, string& b) {
        int num = 0;
        for (int i = 0; i < a.size(); i++) {
            if (a[i] != b[i]) {
                num++;
            }
            if (num > 2)
                return false;
        }
        return true;
    }

public:
    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        int m = strs[0].length();
        parent.resize(n);
        iota(parent.begin(), parent.end(), 0);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int find_i = find(i), find_j = find(j);
                if (find_i == find_j)
                    continue;
                if (check(strs[i], strs[j])) {
                    parent[find_i] = find_j;
                }
            }
        }
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (parent[i] == i)
                ret++;
        }
        return ret;
    }
};
```

</details>

# 210 课程表 2 {#210-课程表 2}

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses -
1。给你一个数组 prerequisites ，其中 prerequisites\[i\] = \[ai, bi\]
，表示在选修课程 ai 前 必须 先选修 bi 。

    例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回
任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> count(numCourses);
        vector<vector<int>> graph(numCourses);
        for(auto& each: prerequisites){
            count[each[0]]++;
            graph[each[1]].emplace_back(each[0]);
        }
        queue<int> que;
                vector<int> ans;
        for(int i=0;i<numCourses;i++){
            if(count[i]==0) {que.emplace(i);ans.push_back(i);}
        }
        if(que.empty()){
            return {};
        }
        int visited=0;
        while(!que.empty()){
            auto top=que.front();
            que.pop();
            visited++;
            for(auto& each: graph[top]){
                if(--count[each]==0){
                    que.emplace(each);
                                ans.push_back(each);
                }
            }
        }
        return numCourses==visited?ans:vector<int>{};
    }
};
```

</details>

# 269 火星词典
现有一种使用英语字母的火星语言，这门语言的字母顺序对你来说是未知的。

给你一个来自这种外星语言字典的字符串列表 words ，words 中的字符串已经
按这门新语言的 字典序 进行了排序 。

如果这种说法是错误的，并且给出的 words 不能对应任何字母的顺序，则返回
\"\" 。

否则，返回一个按新语言规则的 字典递增顺序
排序的独特字符串。如果有多个解决方案，则返回其中 任意一个 。

思路：

words 中的字符串按照字典序排序，就说明对于相邻的字符串 a,b,
其中第一个不相同的字符 a\[i\],
b\[i\]就表示他们在图中的位置，前者在后者之上。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    unordered_map<char,vector<char>> edges;
    unordered_map<char,int> indegree;
    bool valid=true;
public:
    void add_edge(string& a,string& b){
        int len1=a.length(),len2=b.length();
        int len=min(len1,len2);
        int index=0;
        while(index<len){
            auto c1=a[index],c2=b[index];
            if(c1!=c2){
                edges[c1].emplace_back(c2);
                indegree[c2]++;
                break;
            }
            index++;
        }
        if(index==len&&len1>len2) valid=false;//不满足任何字母顺序
    }
    string alienOrder(vector<string>& words) {
        int len=words.size();
        for(auto& word:words){
            for(auto& c: word){
                if(edges.count(c)==0){
                    edges[c]=vector<char>();
                }
            }
        }
        for(int i=1;i<len;i++){
            add_edge(words[i-1],words[i]);
        }
        if(!valid) return "";
        queue<char> que;
        for(auto& [u,_]: edges){//如果u这个点的入度为0
            if(!indegree.count(u)) que.emplace(u);
        }
        string order;
        while(!que.empty()){
            auto u=que.front();
            que.pop();
            order.push_back(u);
            for(auto& v: edges[u]){
                if(--indegree[v]==0){
                    que.emplace(v);
                }
            }
        }
        return order.size()==edges.size()? order: "";
    }
};
```

</details>

# 1203 项目管理
有 n 个项目，每个项目或者不属于任何小组，或者属于 m
个小组之一。group\[i\] 表示第 i 个项目所属的小组，如果第 i
个项目不属于任何小组，则 group\[i\] 等于
-1。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。

请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：

同一小组的项目，排序后在列表中彼此相邻。

项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中
beforeItems\[i\] 表示在进行第 i 个项目前（位于第 i
个项目左侧）应该完成的所有项目。

如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个
空列表 。

思路：

这道题实际上有两个拓扑关系：

1.  组内的每一个 item 之间存在拓扑关系

2.  每一个组之间因为 item 的关系也会存在依赖关系

将每一个 group\[i\]为-1 的 item 设置为一个独立的 groupId,
然后先将每一个组之间进行排序，再对每一个组进行排序。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    vector<int> topSort(vector<int>& indegree, vector<vector<int>>& graph,
                        vector<int>& items) {
        queue<int> que;
        vector<int> sorted;
        for (auto& item : items) {
            if (indegree[item] == 0) {
                que.push(item);
            }
        }
        while (!que.empty()) {
            auto top = que.front();
            que.pop();
            sorted.emplace_back(top);
            for (auto& each : graph[top]) {
                if (--indegree[each] == 0) {
                    que.emplace(each);
                }
            }
        }
        return sorted.size() == items.size() ? sorted : vector<int>{};
    }

public:
    vector<int> sortItems(int n, int m, vector<int>& group,
                          vector<vector<int>>& beforeItems) {
        vector<vector<int>> groupItem(n + m);
        vector<vector<int>> groupGraph(m + n);
        vector<vector<int>> itemGraph(n);
        vector<int> groupDegree(n + m);
        vector<int> itemIndegree(n);
        vector<int> id(n + m);
        iota(id.begin(), id.end(), 0);
        int leftId = m;
        // 给没有分配组的item分配一个groupId(视为每个一组)
        for (int i = 0; i < n; i++) {
            if (group[i] == -1) {
                group[i] = (leftId++);
            }
            groupItem[group[i]].emplace_back(i);
        }
        // 依赖关系建图
        for (int i = 0; i < n; i++) {
            auto& curGroup = group[i];
            for (auto& item : beforeItems[i]) {
                int beforeGroupItemId = group[item];
                if (beforeGroupItemId == curGroup) {
                    itemIndegree[i] += 1;
                    itemGraph[item].emplace_back(i);
                } else {
                    groupDegree[curGroup] += 1;
                    groupGraph[beforeGroupItemId].emplace_back(curGroup);
                }
            }
        }
        // 组间拓扑关系排序
        vector<int> groupTopSorted = topSort(groupDegree, groupGraph, id);
        if (groupTopSorted.size() == 0) {
            return vector<int>();
        }
        vector<int> ans;
        // 组内拓扑关系排序
        for (auto& curGroupId : groupTopSorted) {
            int size = groupItem[curGroupId].size();
            if (size == 0)
                continue;
            vector<int> res =
                topSort(itemIndegree, itemGraph, groupItem[curGroupId]);
            if (res.size() == 0) {
                return {};
            }
            for (auto& item : res) {
                ans.emplace_back(item);
            }
        }
        return ans;
    }
};
```

</details>

# 1857 有向图中最大颜色值
给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。

给你一个字符串 colors ，其中 colors\[i\] 是小写英文字母，表示图中第 i
个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中
edges\[j\] = \[aj, bj\] 表示从节点 aj 到节点 bj 有一条 有向边 。

图中一条有效 路径 是一个点序列 x1 -\> x2 -\> x3 -\> \... -\> xk
，对于所有 1 \<= i \< k ，从 xi 到 xi+1 在图中有一条有向边。路径的
颜色值 是路径中 出现次数最多 颜色的节点数目。

请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。

思路：

拓扑排序上进行动态规划。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int largestPathValue(string colors, vector<vector<int>>& edges) {
        int n=colors.length();
        vector<vector<int>> graph(n);
        //邻接表
        //入度
        vector<int> indegree(n);
        for(auto&& edge: edges){
            ++indegree[edge[1]];
            graph[edge[0]].emplace_back(edge[1]);
        }
        //记录拓扑排序过程中遇到的节点个数
        //如果found的值不是n, 说明途中存在环
        int found=0;
        vector<array<int,26>> f(n);
        queue<int> que;
        for(int i=0;i<n;i++){
            if(!indegree[i]) que.push(i);
        }
        while(!que.empty()){
            ++found;
            int u=que.front();
            que.pop();
            ++f[u][colors[u]-'a'];
            for(auto& v: graph[u]){
                --indegree[v];
                for(int c=0;c<26;cpp){
                    f[v][c]=max(f[v][c],f[u][c]);
                }
                if(!indegree[v]) que.push(v);
            }
        }
        if(found!=n) return -1;
        int ans=0;
        for(int i=0;i<n;i++) ans=max(ans,ranges::max(f[i]));
        return ans;
    }
};
```

</details>

# 994. 腐烂的橘子
在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：

    值 0 代表空单元格；
    值 1 代表新鲜橘子；
    值 2 代表腐烂的橘子。

每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。

返回
直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1
。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    constexpr static array<int,4> dx={0,1,0,-1};
    constexpr static array<int,4> dy={1,0,-1,0};
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int cnt=0;
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>> dis(m,vector<int>(n,-1));
        queue<pair<int,int>> que;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==2){
                    que.emplace(i,j);
                    dis[i][j]=0;
                }else if(grid[i][j]==1){
                    cnt+=1;
                }
            }
        }
        int ans=0;
        while(que.size()){
            auto [r,c]=que.front();
            que.pop();
            for(int i=0;i<4;++i){
                int nr=r+dx[i];
                int nc=c+dy[i];
                if(nr<0||nr>=m||nc<0||nc>=n||~dis[nr][nc]||!grid[nr][nc]){
                    continue;
                }
                dis[nr][nc]=dis[r][c]+1;
                que.emplace(nr,nc);
                if(grid[nr][nc]==1){
                    cnt-=1;
                    ans=dis[nr][nc];
                    if(!cnt) break;
                }
            }
        }
        return cnt?-1:ans;
    }
};
```

</details>

# 684. 冗余连接
树可以看成是一个连通且 无环 的 无向 图。

给定往一棵 n 个节点 (节点值 1 ～ n)
的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n
中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n
的二维数组 edges ，edges\[i\] = \[ai, bi\] 表示图中在 ai 和 bi
之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n
个节点的树。如果有多个答案，则返回数组 edges 中最后出现的那个。

<details><summary>Click to expand</summary>

```cpp
class UnionSet{
    public:
    vector<int> parent;
    UnionSet(int n){
        parent.resize(n);
        iota(parent.begin(),parent.end(),0);
    }
    void us_union(int index1,int index2){
        parent[find(index1)]=find(index2);
    }
    int find(int index){
        return parent[index]!=index?(parent[index]=find(parent[index])):parent[index];
    }
};
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int nodeCount=edges.size();
        UnionSet us(nodeCount);
        for(auto& edge: edges){
            int n1=edge[0]-1,n2=edge[1]-1;
            if(us.find(n1)!=us.find(n2)) us.us_union(n1, n2);
            else return edge;
        }
        return {};
    }
};
```

</details>

# 685 冗余连接 2 {#685-冗余连接 2}

在本问题中，有根树指满足以下条件的 有向
图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到
n）的树及一条附加的有向边构成。附加的边包含在 1 到 n
中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 edges 。 每个元素是一对 \[ui,
vi\]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi
的一个父节点。

返回一条能删除的边，使得剩下的图是有 n
个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    class UF{
        vector<int> parents;
        public:
        UF(int n){
            parents.resize(n);
            iota(parents.begin(),parents.end(),0);
        }
        int find(int index){
            return index==parents[index]?index: parents[index]=find(parents[index]);
        }
        void merge(int u,int v){
            parents[find(u)]=find(v);
        }
    };
public:
    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int n=edges.size();
        UF uf(n+1);
        auto parent=vector<int>(n+1);
        iota(parent.begin(),parent.end(),0);
        int conflict=-1;
        int cycle=-1;
        for(int i=0;i<n;i++){
            auto edge=edges[i];
            int node1=edge[0],node2=edge[1];
            //说明node2有两个父节点，当前边node1->node2为冲突边
            if(parent[node2]!=node2){
                conflict=i;
            }else{
                parent[node2]=node1;
                //在并查集中查找node1, node2的祖先，如果祖先相同，说明这条边导致环路出现；否则将node1, node2合并
                if(uf.find(node2)==uf.find(node1)){
                    cycle=i;
                }else{
                    uf.merge(node1, node2);
                }
            }
        }
        if(conflict<0){
            return edges[cycle];
        }else{
            auto conflictEdge=edges[conflict];
            if(cycle>=0){
                return vector<int>{parent[conflictEdge[1]],conflictEdge[1]};
            }else{
                return conflictEdge;
            }
        }
    }
};
```

</details>

# 499 迷宫 3 {#499-迷宫 3}

由空地和墙组成的迷宫中有一个球。球可以向上（u）下（d）左（l）右（r）四个方向滚动，但在遇到墙壁前不会停止滚动。当球停下时，可以选择下一个方向。迷宫中还有一个洞，当球运动经过洞时，就会掉进洞里。

给定球的起始位置，目的地和迷宫，找出让球以最短距离掉进洞里的路径。
距离的定义是球从起始位置（不包括）到目的地（包括）经过的空地个数。通过\'u\',
\'d\', \'l\' 和 \'r\'输出球的移动方向。 由于可能有多条最短路径，
请输出字典序最小的路径。如果球无法进入洞，输出\"impossible\"。

迷宫由一个 0 和 1 的二维数组表示。
1 表示墙壁，0 表示空地。你可以假定迷宫的边缘都是墙壁。起始位置和目的地的坐标通过行号和列号给出。

<details><summary>Click to expand</summary>

```cpp

class Solution {
public:
    class node {
        public:
        node(int row,int col,int dist,string path):row(row),col(col),dist(dist),path(path){}
        bool operator< (const node& other) const{
            return dist > other.dist;
        }
        int row,col,dist;
        string path;
    };
private:
//下左右上
    int dir[4][2] = {{1,0},{0,-1},{0,1},{-1,0}};
    char dict[4] = {'d','l','r','u'};
public:
    string findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) {
        int mazeRow = maze.size();
        int mazeCol = maze[0].size();
        int INF = mazeRow * mazeCol;
        priority_queue<node> pq;
        vector<vector<int>> dist(mazeRow,vector<int>(mazeCol,INF));
        vector<vector<string>> paths(mazeRow,vector<string>(mazeCol));
        pq.push(node(ball[0],ball[1],0,""));
        dist[ball[0]][ball[1]] = 0;
        while(pq.size()){
            auto [row,col,curDist,path] = pq.top();
            pq.pop();
            if(row == hole[0] && col == hole[1] ){
                return paths[row][col];
            }
            if(curDist > dist[row][col] || (curDist == dist[row][col] && path != paths[row][col])) continue;
            for(int i = 0;i < 4;i++){
                int nextRow = row + dir[i][0];
                int nextCol = col + dir[i][1];
                int nextDist = curDist;
                while(nextRow >=0 && nextRow < mazeRow && nextCol >= 0 && nextCol < mazeCol && maze[nextRow][nextCol] == 0){
                    nextDist++;
                    if(nextRow == hole[0] && nextCol == hole[1]) {
                        nextRow += dir[i][0];
                        nextCol += dir[i][1];
                        break;
                    }
                    nextRow += dir[i][0];
                    nextCol += dir[i][1];
                }
                nextRow -= dir[i][0];
                nextCol -= dir[i][1];
                if((nextDist < dist[nextRow][nextCol])||(nextDist == dist[nextRow][nextCol]&&paths[nextRow][nextCol] > path+dict[i] )) {
                    dist[nextRow][nextCol] = nextDist;
                    paths[nextRow][nextCol] = path + dict[i];
                    pq.push(node(nextRow,nextCol,nextDist,path+dict[i]));
                }
            }
        }
        return "impossible";
    }
};
```

</details>

# 1168 水资源分配优化
村里面一共有 n 栋房子。我们希望通过建造水井和铺设管道来为所有房子供水。

对于每个房子
i，我们有两种可选的供水方案：一种是直接在房子内建造水井，成本为
wells\[i - 1\] （注意 -1 ，因为 索引从 0 开始
）；另一种是从另一口井铺设管道引水，数组 pipes
给出了在房子间铺设管道的成本，其中每个 pipes\[j\] = \[house1j, house2j,
costj\] 代表用管道将 house1j 和 house2j 连接在一起的成本。连接是双向的。

请返回 为所有房子都供水的最低总成本 。

> 概述
> 由于问题描述涉及到连接房子（顶点）使用管道（边），我们可以确定这个问题与图论问题有关。本题要求为所有房子都供水的最低总成本，我们把房子看成是图的节点，管道看成是图的边，那么这题很显然就是最小生成树的问题。唯一的区别是可以直接在房子内造水井。
> 关于 MST 问题，存在几种经典的算法。 特别地，我们将展示其中的两种，即
> Prim 的算法和 Kruskal
> 的算法，这两种算法可以说是最受欢迎的，并且在面试中可行。 简单介绍
> 首先，让我们介绍最小生成树的问题。 给定一个 连通、 边加权 的 无向
> 图，最小生成树是一组 子集
> 的边，它连接所有的顶点，同时这些边的总权重在所有可能的子集中是最小的。我们可以从上述定义和我们这里的问题中找到一些相似性。
> 具体来说，我们可以将每个房子视为图中的一个顶点，而房子之间的管道视为图中的边。然而，它们之间有一个主要的
> 差异。 在我们的问题中，每个顶点和每个边都有一个成本。 而在 MST
> 的设置中，只有边与成本相关联。为了弥合这个
> 差距，就如提示所建议的，技巧是在现有图中添加
> 一个虚拟顶点。随着顶点的增加，我们还在虚拟顶点和其余顶点之间添加了边。
> 最后，我们将每个顶点的成本重新分配给对应的新增边。

<details><summary>Click to expand</summary>

```cpp
class Solution {
    constexpr static int MAX_N = 10005;
    int f[10005];
    void init() {
        for (int i = 0; i < MAX_N; ++i)
            f[i] = i;
    }
    int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }
    void merge(int u, int v) { f[find(u)] = find(v); }
public:
    int minCostToSupplyWater(int n, vector<int>& wells,
                             vector<vector<int>>& pipes) {
        init();
        for (int i = 1; i <= n; ++i)
            pipes.push_back(vector<int>({0, i, wells[i - 1]}));
        sort(pipes.begin(), pipes.end(),
             [](const vector<int>& u, const vector<int>& v) {
                 return u[2] < v[2];
             });
        int ret = 0;
        for (auto u : pipes) {
            if (find(u[0]) != find(u[1])) {
                merge(u[0], u[1]);
                ret += u[2];
            }
        }
        return ret;
    }
};
```

</details>

# 1489. 找到最小生成树里的关键边和伪关键边
给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组
edges ，其中 edges\[i\] = \[fromi, toi, weighti\] 表示在 fromi 和 toi
节点之间有一条带权无向边。最小生成树 (MST)
是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。

请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。

请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。

<details><summary>Click to expand</summary>

```cpp
// 并查集模板
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    int n;
    // 当前连通分量数目
    int setCount;

public:
    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }

    int findset(int x) {
        return parent[x] == x ? x : parent[x] = findset(parent[x]);
    }

    bool unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            swap(x, y);
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }

    bool connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
};

class Solution {
public:
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        int m = edges.size();
        for (int i = 0; i < m; ++i) {
            edges[i].push_back(i);
        }
        sort(edges.begin(), edges.end(), [](const auto& u, const auto& v) {
            return u[2] < v[2];
        });
        // 计算 value
        UnionFind uf_std(n);
        int value = 0;
        for (int i = 0; i < m; ++i) {
            if (uf_std.unite(edges[i][0], edges[i][1])) {
                value += edges[i][2];
            }
        }

        vector<vector<int>> ans(2);

        for (int i = 0; i < m; ++i) {
            // 判断是否是关键边
            UnionFind uf(n);
            int v = 0;
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {
                ans[0].push_back(edges[i][3]);
                continue;
            }

            // 判断是否是伪关键边
            uf = UnionFind(n);
            uf.unite(edges[i][0], edges[i][1]);
            v = edges[i][2];
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (v == value) {
                ans[1].push_back(edges[i][3]);
            }
        }

        return ans;
    }
};
```

</details>

# UNSOLVED 936 戳印序列

你想要用小写字母组成一个目标字符串 target。

开始的时候，序列由 target.length 个 \'?\'
记号组成。而你有一个小写字母印章 stamp。

在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行
10 \* target.length 个回合。

举个例子，如果初始序列为 \"?????\"，而你的印章 stamp 是
\"abc\"，那么在第一回合，你可以得到
\"abc??\"、\"?abc?\"、\"??abc\"。（请注意，印章必须完全包含在序列的边界内才能盖下去。）

如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。

例如，如果序列是 \"ababc\"，印章是 \"abc\"，那么我们就可以返回与操作
\"?????\" -\> \"abc??\" -\> \"ababc\" 相对应的答案 \[0, 2\]；

另外，如果可以印出序列，那么需要保证可以在 10 \* target.length
个回合内完成。任何超过此数字的答案将不被接受。

## 思路

我们记字母印章长度为 m ，目标字符串长度为 n
。我们拿字母印章在目标字符串上进行滑动，那么在目标字符串中总共将会有
n−m+1
个窗口。另外，我们将逆序操作过程中所得到的各窗口的起始端点值记录在列表
ans 中，最后只需将 ans 反转即可得到答案。

那么我们可以将本题和拓扑排序的相关概念进行映射：

    「入度」：每个窗口中对应字符不相同的总数，起始默认为 m。当入度为 0 时，说明这个窗口的所有字符都与目标字符串相对应，我们就可以把这个窗口放入到队列（不一定是 FIFO 的队列，任意容器均可）中。
    「边」：对于目标字符串的每个位置上，有不一致字符的窗口。我们用邻接表的方式存储边，如果一个滑动窗口的某一个字符与目标字符串不一致，那么我们就连一条边。

至此，我们通过拓扑排序，就可以得到最终的结果了：

    遍历一遍所有的窗口，如果该位置上的字符与目标字符不一致，那么我们在邻接表中连接一条边；相反如果字符一致，那么该窗口的入度减 1。
    当某个窗口的入度为 0 时，那么这个窗口的所有字符都与目标字符串相对应，我们可以将该窗口的起始端点放入到队列中。
    将队列中的窗口依次出队，每次出队时，我们在 ans 列表中记录该窗口的起始端点。
    我们可以想象该窗口中的字符全部替换为 '*' ，表示可以匹配任意字符。那么我们可以从邻接表中将之前与该位置不同的窗口的入度都减 1。
    重复（2），直到队列为空。
    当队列为空时，判断 ans 的长度是否与 n−m+1 相等，相等则完成了拓扑排序；不相等则说明无法印出目标字符串。
    如果完成了拓扑排序，那么 ans 的长度一定是小于 10∗n 的，符合题目要求，我们只需返回逆序的 ans 即可（逆序分析）。相反，我们返回一个空列表。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<int> movesToStamp(string stamp, string target) {
        auto m=stamp.size();
        auto n=target.size();
        vector<int> inDegreee(n-m+1,m);
        vector<vector<int>> edges(n);
        vector<int> seen(n);
        vector<int> q;
        for(auto i=0;i<n-m+1;i++){
            for(auto j=0;j<m;j++){
                if(target[i+j]==stamp[j]){
                    inDegreee[i]-=1;
                    if(inDegreee[i]==0) q.emplace_back(i);
                }else{
                    edges[i+j].emplace_back(i);
                }
            }
        }
        vector<int> ans;
        while(!q.empty()){
            int cur=q.back();
            q.pop_back();
            ans.emplace_back(cur);
            for(size_t i=0;i<m;i++){
                if(!seen[cur+i]){
                    seen[cur+i]=true;
                    for(auto &&edge: edges[cur+i]){
                        inDegreee[edge]-=1;
                        if(inDegreee[edge]==0) q.emplace_back(edge);
                    }
                }
            }
        }
        if(ans.size()<n-m+1) return {};
        ranges::reverse(ans);
        return ans;
    }
};
```

</details>

# 133 克隆图
给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list\[Node\]）。
Node 定义如下：

<details><summary>Click to expand</summary>

```cpp
class Node {
    public int val;
    public List<Node> neighbors;
}
```

</details>
<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    unordered_map<Node *,Node*> visited;
    Node* cloneGraph(Node* node) {
        if(!node) return node;
        if(visited.find(node)!=visited.end()) return visited[node];
        Node *cloneNode=new Node(node->val);
        visited[node]=cloneNode;
        for(auto& nodes: node->neighbors) cloneNode->neighbors.emplace_back(cloneGraph(nodes));
        return cloneNode;
    }
};
```

</details>

# 785 判断二分图
存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1
之间的唯一编号。给你一个二维数组 graph ，其中 graph\[u\]
是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph\[u\]
中的每个 v ，都存在一条位于节点 u 和节点 v
之间的无向边。该无向图同时具有以下属性：

    不存在自环（graph[u] 不包含 u）。
    不存在平行边（graph[u] 不包含重复值）。
    如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）
    这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。

二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B
，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B
集合，就将这个图称为 二分图 。

如果图是二分图，返回 true ；否则，返回 false 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n=graph.size();
        vector<int> node_color(n,0);
        bool valid=true;
        function<void(int,int)> dfs=[&](int i,int color){
            node_color[i]=color;
            int cur_color=color==1?2:1;
            for(auto n:graph[i]){
                if(node_color[n]==0){
                    dfs(n,cur_color);
                    if(!valid) return;
                }else if(node_color[n]!=cur_color){
                    valid=false;
                    return;
                }
            }
        };
        for(int i=0;i<n;i++){
            if(node_color[i]==0){
                dfs(i,1);
            }
        }
        return valid;
    }
};
```

</details>

# UNSOLVED 787 K 站中转内最便宜的航班

有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights\[i\] =
\[fromi, toi, pricei\] ，表示该航班都从城市 from\[i\] 开始，以价格
price\[i\] 抵达 to\[i\]。

现在给定所有的城市和航班，以及出发城市 src 和目的地
dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的
价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,
                        int k) {
    vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX / 2));
    dp[0][src] = 0;
    int res = INT_MAX / 2;
    for (int t = 1; t <= k + 1; t++) {
      for (const auto& flight : flights) {
        int from = flight[0], to = flight[1], cost = flight[2];
        dp[t][to] = std::min(dp[t][to], dp[t - 1][from] + cost);
        if (to == dst) res = std::min(res, dp[t][to]);
      }
    }
    return res == INT_MAX / 2 ? -1 : res;
  }
};
```

</details>

# 741 网络延迟时间
有 n 个网络节点，标记为 1 到 n。

给你一个列表 times，表示信号经过 有向 边的传递时间。 times\[i\] = (ui,
vi, wi)，其中 ui 是源节点，vi 是目标节点， wi
是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K
发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回
-1 。

<details>

```cpp
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<vector<int>> graph(n,vector<int>(n,INT_MAX/2));
        for(auto &t: times){
            graph[t[0]-1][t[1]-1]=t[2];
        }
        vector<int> dis(n,INT_MAX/2),done(n);
        dis[k-1]=0;
        while(true){
            int x=-1;
            for(int i=0;i<n;i++){
                if(!done[i]&&(x<0||dis[i]<dis[x])){
                    x=i;
                }
            }
            if(x<0){
                return ranges::max(dis);
            }
            if(dis[x]==INT_MAX/2){//节点无法到达
                return -1;
            }
            done[x]=true;
            for(int y=0;y<n;y++){
                dis[y]=min(dis[y],dis[x]+graph[x][y]);
            }
        }
    }
};
```

</details>

# 85 最大矩形
给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含
1 的最大矩形，并返回其面积。

<details>

<summary>
柱状图
</summary>

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m=matrix.size();
        if(m==0){
            return 0;
        }
        int n=matrix[0].size();
        vector<vector<int>> left(m,vector<int>(n,0));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]=='1'){
                    left[i][j]=(j==0?0:left[i][j-1])+1;
                }
            }
        }
        int ret=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]=='0'){
                    continue;
                }
                int width=left[i][j];
                int area=width;
                for(int k=i-1;k>=0;k--){
                    width=min(width,left[k][j]);
                    area=max(area,(i-k+1)*width);
                }
                ret=max(ret,area);
            }
        }
        return ret;
    }
};
```

</details>

<details>

<summary>
单调栈
</summary>

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if (m == 0) {
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> left(m, vector<int>(n, 0));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;
                }
            }
        }

        int ret = 0;
        for (int j = 0; j < n; j++) { // 对于每一列，使用基于柱状图的方法
            vector<int> up(m, 0), down(m, 0);

            stack<int> stk;
            for (int i = 0; i < m; i++) {
                while (!stk.empty() && left[stk.top()][j] >= left[i][j]) {
                    stk.pop();
                }
                up[i] = stk.empty() ? -1 : stk.top();
                stk.push(i);
            }
            stk = stack<int>();
            for (int i = m - 1; i >= 0; i--) {
                while (!stk.empty() && left[stk.top()][j] >= left[i][j]) {
                    stk.pop();
                }
                down[i] = stk.empty() ? m : stk.top();
                stk.push(i);
            }

            for (int i = 0; i < m; i++) {
                int height = down[i] - up[i] - 1;
                int area = height * left[i][j];
                ret = max(ret, area);
            }
        }
        return ret;
    }
};
```

</details>

# 913 猫和老鼠

两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。

图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。

老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。

在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。

此外，猫无法移动到洞中（节点 0）。

然后，游戏在出现以下三种情形之一时结束：

    如果猫和老鼠出现在同一个节点，猫获胜。
    如果老鼠到达洞中，老鼠获胜。
    如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。

给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：

    如果老鼠获胜，则返回 1；
    如果猫获胜，则返回 2；
    如果平局，则返回 0 。

<details>

```cpp
class Solution {
    constexpr static int MOUSE_TURN=0,CAT_TURN=1;
    constexpr static int DRAW=0,MOUSE_WIN=1,CAT_WIN=2;
    vector<vector<int>> graph;
    vector<vector<vector<int>>> degrees;
    vector<vector<vector<int>>> results;
    struct d{
        int a,b,c;
    };
public:
    int catMouseGame(vector<vector<int>>& graph) {
        int n=graph.size();
        this->graph=graph;
        this->degrees=vector<vector<vector<int>>>(n,vector<vector<int>>(n,vector<int>(2)));
        this->results=vector<vector<vector<int>>>(n,vector<vector<int>>(n,vector<int>(2)));
        queue<d> qu;
        for(int i=0;i<n;i++){
            for(int j=1;j<n;j++){
                degrees[i][j][MOUSE_TURN]=graph[i].size();
                degrees[i][j][CAT_TURN]=graph[j].size();
            }
        }
        for(int node:graph[0]){
            for(int i=0;i<n;i++){
                degrees[i][node][CAT_TURN]--;
            }
        }
        for(int j=1;j<n;j++){
            results[0][j][MOUSE_TURN]=MOUSE_WIN;
            results[0][j][CAT_TURN]=MOUSE_WIN;
            qu.emplace(0,j,MOUSE_TURN);
            qu.emplace(0,j,CAT_TURN);
        }
        for(int i=1;i<n;i++){
            results[i][i][MOUSE_TURN]=CAT_WIN;
            results[i][i][CAT_TURN]=CAT_WIN;
            qu.emplace(i,i,MOUSE_TURN);
            qu.emplace(i,i,CAT_TURN);
        }
        while(qu.size()){
            auto [mouse,cat,turn]=qu.front();
            qu.pop();
            int result=results[mouse][cat][turn];
            vector<d> prevStates=getPrevStates(mouse, cat, turn);
            for(auto &[prevMouse,prevCat,prevTurn]:prevStates){
                if(results[prevMouse][prevCat][prevTurn]==DRAW){
                    bool canWin=(result==MOUSE_WIN && prevTurn==MOUSE_TURN) || (result==CAT_WIN && prevTurn==CAT_TURN);
                    if(canWin){
                        results[prevMouse][prevCat][prevTurn]=result;
                        qu.emplace(prevMouse,prevCat,prevTurn);
                    }else if(--degrees[prevMouse][prevCat][prevTurn]==0){
                        int loseResult=prevTurn==MOUSE_TURN?CAT_WIN:MOUSE_WIN;
                        results[prevMouse][prevCat][prevTurn]=loseResult;
                        qu.emplace(prevMouse,prevCat,prevTurn);
                    }
                }
            }
        }
        return results[1][2][MOUSE_TURN];
    }
    vector<d> getPrevStates(int mouse,int cat,int turn){
        vector<d> prevStates;
        int prevTurn=turn==MOUSE_TURN?CAT_TURN:MOUSE_TURN;
        if(prevTurn==MOUSE_TURN){
            for(int &prev: graph[mouse]){
                prevStates.emplace_back(prev,cat,prevTurn);
            }
        }else{
            for(int &prev: graph[cat]){
                if(prev!=0){
                    prevStates.emplace_back(mouse,prev,prevTurn);
                }
            }
        }
        return prevStates;
    }
};
```

</details>

# 1059 从起点到终点的所有路径

给定有向图的边 edges，以及该图的始点 source 和目标终点 destination，确定从始点 source 出发的所有路径是否最终结束于目标终点 destination，即：

    从始点 source 到目标终点 destination 存在至少一条路径
    如果存在从始点 source 到没有出边的节点的路径，则该节点就是路径终点。
    从始点source到目标终点 destination 可能路径数是有限数字

当从始点 source 出发的所有路径都可以到达目标终点 destination 时返回 true，否则返回 false。

<details>

```cpp
class Solution {
public:
    bool leadsToDestination(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>> graph(n);
        vector<int> indegree(n);
        for(auto&& x:edges){
            graph[x[1]].emplace_back(x[0]);
            indegree[x[0]]++;
        }
        if(indegree[destination]) return false;
        queue<int> q;
        q.push(destination);
        while(q.size()){
            int now=q.front();q.pop();
            if(now==source) return true;
            for(int next:graph[now]){
                if(--indegree[next]==0){
                    q.push(next);
                }
            }
        }
        return false;
    }
};
```

</details>

# 305 岛屿数量Ⅱ

给你一个大小为 m x n 的二维二进制网格 grid 。网格表示一个地图，其中，0 表示水，1 表示陆地。最初，grid 中的所有单元格都是水单元格（即，所有单元格都是 0）。

可以通过执行 addLand 操作，将某个位置的水转换成陆地。给你一个数组 positions ，其中 positions[i] = [ri, ci] 是要执行第 i 次操作的位置 (ri, ci) 。

返回一个整数数组 answer ，其中 answer[i] 是将单元格 (ri, ci) 转换为陆地后，地图中岛屿的数量。

岛屿 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。

<details>

```cpp
class DJset{
    vector<int> parent;
    int count=0;
    public:
    DJset(int n){
        parent.resize(n);
        iota(parent.begin(),parent.end(),0);
    }
    bool isConnected(int x,int y){
        return find(x)==find(y);
    }
    int find(int x){
        if(parent[x]!=x) parent[x]=find(parent[x]);
        return parent[x];
    }
    int getCount(){
        return count;
    }
    void addCount(){
        count++;
    }
    void connect(int x,int y){
        int px=find(x);
        int py=find(y);
        if(px==py){
            return;
        }
        parent[px]=py;
        count--;
    }
};
class Solution{
    int m,n;
    bool inArea(int x,int y){
        return x>=0&&x<m&&y>=0&&y<n;
    }
    constexpr static int  dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
public:
    vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
        this->m=m;
        this->n=n;
        DJset uf(m*n);
        vector<bool> visited(m*n);
        vector<int> res;
        for(auto& pos: positions){
            int curX=pos[0];
            int curY=pos[1];
            int index=curX*n+curY;
            if(!visited[index]){
                uf.addCount();
                visited[index]=true;
                for(auto& d:dir){
                    int newX=curX+d[0];
                    int newY=curY+d[1];
                    int newIndex=newX*n+newY;
                    if(inArea(newX,newY)&&
                    visited[newIndex]
                    &&!uf.isConnected(index, newIndex)){
                        uf.connect(index, newIndex);
                    }
                }
            }
            res.push_back(uf.getCount());
        }
        return res;
    }
};
```

</details>

# 694 不同岛屿的数量

给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。

请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。

<details>

```cpp
class Solution {
    using pii=pair<int,int>;
    bool equalIslands(const vector<pii>& i1,const vector<pii>& i2){
        if(i1.size()!=i2.size()){
            return false;
        }
        for(int i=0;i<i1.size();i++){
            auto [x1,y1]=i1[i];
            auto [x2,y2]=i2[i];
            if(x1!=x2 || y1!=y2){
                return false;
            }
        }
        return true;
    }
public:
    int numDistinctIslands(vector<vector<int>>& grid) {
        set<pii> seen;
        vector<vector<pii>> uniqueIslands;
        vector<pii> currentIsland;
        auto currentIslandUnique=[&]()->bool{
            for(auto& otherIsland: uniqueIslands){
                if(equalIslands(otherIsland, currentIsland)){
                    return false;
                }
            }
            return true;
        };
        function<void(int,int)> dfs=[&](int row,int col){
            if(row<0||col<0||row>=grid.size()||col>=grid[0].size()){
                return;
            }
            if(seen.count(make_pair(row,col))||!grid[row][col]){
                return;
            }
            seen.emplace(row,col);
            currentIsland.emplace_back(row,col);
            dfs(row+1,col);
            dfs(row-1,col);
            dfs(row,col+1);
            dfs(row,col-1);
        };
        for(int row=0;row<grid.size();row++){
            for(int col=0;col<grid[0].size();col++){
                currentIsland=vector<pii>();
                dfs(row,col);
                if(currentIsland.empty()){
                    continue;
                }
                int minCol=grid[0].size()-1;
                for(int i=0;i<currentIsland.size();i++){
                    minCol=min(minCol,currentIsland[i].second);
                }
                for(auto& [x,y]:currentIsland){
                    x-=row;
                    y-=minCol;
                }
                if(currentIslandUnique()){
                    uniqueIslands.emplace_back(currentIsland);
                }
            }
        }
        return uniqueIslands.size();
    }
};
```

</details>

# 1136 并行课程

给你一个整数 n ，表示编号从 1 到 n 的 n 门课程。另给你一个数组 relations ，其中 relations[i] = [prevCoursei, nextCoursei] ，表示课程 prevCoursei 和课程 nextCoursei 之间存在先修关系：课程 prevCoursei 必须在 nextCoursei 之前修读完成。

在一个学期内，你可以学习 任意数量 的课程，但前提是你已经在 上 一学期修读完待学习课程的所有先修课程。

请你返回学完全部课程所需的 最少 学期数。如果没有办法做到学完全部这些课程的话，就返回 -1。

<details>

```cpp
class Solution {
public:
    int minimumSemesters(int n, vector<vector<int>>& relations) {
        vector<vector<int>> graph(n+1);
        vector<int> indegree(n+1);
        for(auto& r:relations){
            graph[r[0]].emplace_back(r[1]);
            indegree[r[1]]++;
        }
        int step=0;
        int studiedCount=0;
        vector<int> bfsQueue;
        for(int node=1;node<n+1;node++){
            if(indegree[node]==0) bfsQueue.emplace_back(node);
        }
        while(bfsQueue.size()){
            step++;
            vector<int> nextQueue;
            for(auto& node:bfsQueue){
                studiedCount++;
                for(auto& endNode: graph[node]){
                    if(--indegree[endNode]==0){
                        nextQueue.emplace_back(endNode);
                    }
                }
            }
            bfsQueue=nextQueue;
        }
        return studiedCount==n?step:-1;
    }
};
```

</details>

# UNSOLVED 1728 猫和老鼠Ⅱ

一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。

它们所处的环境设定是一个 rows x cols 的方格 grid ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。

    玩家由字符 'C' （代表猫）和 'M' （代表老鼠）表示。
    地板由字符 '.' 表示，玩家可以通过这个格子。
    墙用字符 '#' 表示，玩家不能通过这个格子。
    食物用字符 'F' 表示，玩家可以通过这个格子。
    字符 'C' ， 'M' 和 'F' 在 grid 中都只会出现一次。

猫和老鼠按照如下规则移动：

    老鼠 先移动 ，然后两名玩家轮流移动。
    每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 grid 。
    catJump 和 mouseJump 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。
    它们可以停留在原地。
    老鼠可以跳跃过猫的位置。

游戏有 4 种方式会结束：

    如果猫跟老鼠处在相同的位置，那么猫获胜。
    如果猫先到达食物，那么猫获胜。
    如果老鼠先到达食物，那么老鼠获胜。
    如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。

给你 rows x cols 的矩阵 grid 和两个整数 catJump 和 mouseJump ，双方都采取最优策略，如果老鼠获胜，那么请你返回 true ，否则返回 false 。

<details>

```cpp
static const int MOUSE_TURN = 0, CAT_TURN = 1;
static const int UNKNOWN = 0, MOUSE_WIN = 1, CAT_WIN = 2;
static const int MAX_MOVES = 1000;

class Solution {
public:
    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int rows, cols;
    vector<string> grid;
    int catJump, mouseJump;
    int food;
    int degrees[64][64][2];
    int results[64][64][2][2];

    bool canMouseWin(vector<string> grid, int catJump, int mouseJump) {
        this->rows = grid.size();
        this->cols = grid[0].size();
        this->grid = grid;
        this->catJump = catJump;
        this->mouseJump = mouseJump;
        int startMouse = -1, startCat = -1;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                char c = grid[i][j];
                if (c == 'M') {
                    startMouse = getPos(i, j);
                } else if (c == 'C') {
                    startCat = getPos(i, j);
                } else if (c == 'F') {
                    food = getPos(i, j);
                }
            }
        }
        int total = rows * cols;
        memset(degrees, 0, sizeof(degrees));
        memset(results, 0, sizeof(results));
        queue<tuple<int, int, int>> qu;
        // 计算每个状态的度
        for (int mouse = 0; mouse < total; mouse++) {
            int mouseRow = mouse / cols, mouseCol = mouse % cols;
            if (grid[mouseRow][mouseCol] == '#') {
                continue;
            }
            for (int cat = 0; cat < total; cat++) {
                int catRow = cat / cols, catCol = cat % cols;
                if (grid[catRow][catCol] == '#') {
                    continue;
                }
                degrees[mouse][cat][MOUSE_TURN]++;
                degrees[mouse][cat][CAT_TURN]++;
                for (auto & dir : dirs) {
                    for (int row = mouseRow + dir[0], col = mouseCol + dir[1], jump = 1; row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] != '#' && jump <= mouseJump; row += dir[0], col += dir[1], jump++) {
                        int nextMouse = getPos(row, col), nextCat = getPos(catRow, catCol);
                        degrees[nextMouse][nextCat][MOUSE_TURN]++;
                    }
                    for (int row = catRow + dir[0], col = catCol + dir[1], jump = 1; row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] != '#' && jump <= catJump; row += dir[0], col += dir[1], jump++) {
                        int nextMouse = getPos(mouseRow, mouseCol), nextCat = getPos(row, col);
                        degrees[nextMouse][nextCat][CAT_TURN]++;
                    }
                }
            }
        }
        // 猫和老鼠在同一个单元格，猫获胜
        for (int pos = 0; pos < total; pos++) {
            int row = pos / cols, col = pos % cols;
            if (grid[row][col] == '#') {
                continue;
            }
            results[pos][pos][MOUSE_TURN][0] = CAT_WIN;
            results[pos][pos][MOUSE_TURN][1] = 0;
            results[pos][pos][CAT_TURN][0] = CAT_WIN;
            results[pos][pos][CAT_TURN][1] = 0;
            qu.emplace(pos, pos, MOUSE_TURN);
            qu.emplace(pos, pos, CAT_TURN);
        }
        // 猫和食物在同一个单元格，猫获胜
        for (int mouse = 0; mouse < total; mouse++) {
            int mouseRow = mouse / cols, mouseCol = mouse % cols;
            if (grid[mouseRow][mouseCol] == '#' || mouse == food) {
                continue;
            }
            results[mouse][food][MOUSE_TURN][0] = CAT_WIN;
            results[mouse][food][MOUSE_TURN][1] = 0;
            results[mouse][food][CAT_TURN][0] = CAT_WIN;
            results[mouse][food][CAT_TURN][1] = 0;
            qu.emplace(mouse, food, MOUSE_TURN);
            qu.emplace(mouse, food, CAT_TURN);
        }
        // 老鼠和食物在同一个单元格且猫和食物不在同一个单元格，老鼠获胜
        for (int cat = 0; cat < total; cat++) {
            int catRow = cat / cols, catCol = cat % cols;
            if (grid[catRow][catCol] == '#' || cat == food) {
                continue;
            }
            results[food][cat][MOUSE_TURN][0] = MOUSE_WIN;
            results[food][cat][MOUSE_TURN][1] = 0;
            results[food][cat][CAT_TURN][0] = MOUSE_WIN;
            results[food][cat][CAT_TURN][1] = 0;
            qu.emplace(food, cat, MOUSE_TURN);
            qu.emplace(food, cat, CAT_TURN);
        }
        // 拓扑排序
        while (!qu.empty()) {
            auto [mouse, cat, turn] = qu.front();
            qu.pop();
            int result = results[mouse][cat][turn][0];
            int moves = results[mouse][cat][turn][1];
            vector<tuple<int, int, int>> prevStates = getPrevStates(mouse, cat, turn);
            for (auto [prevMouse, prevCat, prevTurn] : prevStates) {
                if (results[prevMouse][prevCat][prevTurn][0] == UNKNOWN) {
                    bool canWin = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);
                    if (canWin) {
                        results[prevMouse][prevCat][prevTurn][0] = result;
                        results[prevMouse][prevCat][prevTurn][1] = moves + 1;
                        qu.emplace(prevMouse, prevCat, prevTurn);
                    } else {
                        degrees[prevMouse][prevCat][prevTurn]--;
                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {
                            int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN;
                            results[prevMouse][prevCat][prevTurn][0] = loseResult;
                            results[prevMouse][prevCat][prevTurn][1] = moves + 1;
                            qu.emplace(prevMouse, prevCat, prevTurn);
                        }
                    }
                }
            }
        }
        return results[startMouse][startCat][MOUSE_TURN][0] == MOUSE_WIN && results[startMouse][startCat][MOUSE_TURN][1] <= MAX_MOVES;
    }

    vector<tuple<int, int, int>> getPrevStates(int mouse, int cat, int turn) {
        vector<tuple<int, int, int>> prevStates;
        int mouseRow = mouse / cols, mouseCol = mouse % cols;
        int catRow = cat / cols, catCol = cat % cols;
        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;
        int maxJump = prevTurn == MOUSE_TURN ? mouseJump : catJump;
        int startRow = prevTurn == MOUSE_TURN ? mouseRow : catRow;
        int startCol = prevTurn == MOUSE_TURN ? mouseCol : catCol;
        prevStates.emplace_back(mouse, cat, prevTurn);
        for (auto & dir : dirs) {
            for (int i = startRow + dir[0], j = startCol + dir[1], jump = 1; i >= 0 && i < rows && j >= 0 && j < cols && grid[i][j] != '#' && jump <= maxJump; i += dir[0], j += dir[1], jump++) {
                int prevMouseRow = prevTurn == MOUSE_TURN ? i : mouseRow;
                int prevMouseCol = prevTurn == MOUSE_TURN ? j : mouseCol;
                int prevCatRow = prevTurn == MOUSE_TURN ? catRow : i;
                int prevCatCol = prevTurn == MOUSE_TURN ? catCol : j;
                int prevMouse = getPos(prevMouseRow, prevMouseCol);
                int prevCat = getPos(prevCatRow, prevCatCol);
                prevStates.emplace_back(prevMouse, prevCat, prevTurn);
            }
        }
        return prevStates;
    }

    int getPos(int row, int col) {
        return row * cols + col;
    }
};
```

</details>

# 1197 进击的骑士

一个坐标可以从 -infinity 延伸到 +infinity 的 无限大的 棋盘上，你的 骑士 驻扎在坐标为 [0, 0] 的方格里。

骑士的走法和中国象棋中的马相似，走 “日” 字：即先向左（或右）走 1 格，再向上（或下）走 2 格；或先向左（或右）走 2 格，再向上（或下）走 1 格。

每次移动，他都可以按图示八个方向之一前进。

<details>

```cpp
class Solution {
    constexpr static array<pair<int,int>,8> dxy=
    {
        {
            {2,1},
            {2,-1},
            {1,2},
            {1,-2},
            {-1,2},
            {-1,-2},
            {-2,1},
            {-2,-1}
        }
    };
public:
    int minKnightMoves(int x, int y) {
        array<array<bool,607>,607> visited;
        visited.fill({false});
        visited[302][302]=true;
        deque<pair<int,int>> q;
        q.emplace_back(0,0);
        int step=0;
        int cSize;
        while((cSize=q.size())>0){
            for(int i=0;i<cSize;i++){
                auto [curX,curY]=q.front();
                q.pop_front();
                if(curX==x && curY==y){
                    return step;
                }
                for(auto& [dx,dy]:dxy){
                    int nx=curX+dx;
                    int ny=curY+dy;
                    if(!visited[nx+302][ny+302]){
                        visited[nx+302][ny+302]=true;
                        q.emplace_back(nx,ny);
                    }
                }
            }
            step++;
        }
        return step;
    }
};
```

</details>

# 286 墙与门

你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：

    -1 表示墙或是障碍物
    0 表示一扇门
    INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。

你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。

<details>

```cpp
class Solution {
    vector<vector<int>> used;
    constexpr static array<pair<int, int>, 4> dxy = {
        {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}};

public:
    void wallsAndGates(vector<vector<int>>& rooms) {
        int n = rooms.size();
        int m = rooms[0].size();
        if (m == 0)
            return;
        queue<pair<int, int>> q;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (rooms[i][j] == 0) {
                    q.emplace(i, j);
                }
            }
        }

        int cSize;
        while ((cSize = q.size()) > 0) {
            auto [curRow, curCol] = q.front();
            q.pop();
            for (auto [dx, dy] : dxy) {
                int nx = curRow + dx;
                int ny = curCol + dy;
                if (nx < 0 || ny < 0 || nx >= n || ny >= m ||
                    rooms[nx][ny] != INT_MAX) {
                    continue;
                }
                rooms[nx][ny] = rooms[curRow][curCol] + 1;
                q.emplace(nx, ny);
            }
        }
    }
};
```

</details>

# UNSOLVED 499 迷宫3

由空地和墙组成的迷宫中有一个球。球可以向上（u）下（d）左（l）右（r）四个方向滚动，但在遇到墙壁前不会停止滚动。当球停下时，可以选择下一个方向。迷宫中还有一个洞，当球运动经过洞时，就会掉进洞里。

给定球的起始位置，目的地和迷宫，找出让球以最短距离掉进洞里的路径。 距离的定义是球从起始位置（不包括）到目的地（包括）经过的空地个数。通过'u', 'd', 'l' 和 'r'输出球的移动方向。 由于可能有多条最短路径， 请输出字典序最小的路径。如果球无法进入洞，输出"impossible"。

迷宫由一个0和1的二维数组表示。 1表示墙壁，0表示空地。你可以假定迷宫的边缘都是墙壁。起始位置和目的地的坐标通过行号和列号给出。

<details>

```java
class Solution {
    public int[][] dirs = { { 1, 0 }, { 0, -1 }, { 0, 1 }, { -1, 0 }, { 0, 0 } };
    public String[] action = { "d", "l", "r", "u" }; // 下左右上四个方向, 对应上面dirs
    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {
        int N = maze.length, M = maze[0].length;
        // visited [行][列][方向] 球当前的位置可能是由4个不同方向来到的，一个坐标有4个方向状态
        boolean[][][] visited = new boolean[N][M][4];
        Node start = new Node(ball[0], ball[1], 4, ""); // 起始节点
        Queue<Node> queue = new LinkedList<>();
        queue.offer(start);
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size-- > 0) {
                Node node = queue.poll();
                // 遇到了洞，终止，返回到当前为止做过的所有决定
                if (node.x == hole[0] && node.y == hole[1])
                    return node.path;
                bfs(maze, node, queue, visited, N, M); // 否则继续广搜
            }
        }
        return "impossible";
    }
    // cur: 当前来到的节点
    public void bfs(int[][] maze, Node cur, Queue<Node> queue, boolean[][][] visited, int N, int M) {
        int dir = cur.dir;
        int x = cur.x + dirs[dir][0], y = cur.y + dirs[dir][1]; // 沿着来的方向继续走
        // 球处于初始状态 或 越界撞墙，改变方向继续走
        if (dir == 4 || x < 0 || x == N || y < 0 || y == M || maze[x][y] == 1) {
            for (int i = 0; i < 4; i++) {
                if (i == dir)
                    continue;
                x = cur.x + dirs[i][0];
                y = cur.y + dirs[i][1];
                if (x >= 0 && x < N && y >= 0 && y < M && maze[x][y] == 0 && !visited[x][y][i]) {
                    visited[x][y][i] = true;
                    queue.offer(new Node(x, y, i, cur.path + action[i])); // 入队
                }
            }
        } else if (!visited[x][y][dir]) { // 非初始状态 && 也没越界, 沿着当前方向dir一直走！
            visited[x][y][dir] = true;
            queue.offer(new Node(x, y, dir, cur.path)); // 入队
        }
    }
    public class Node {
        public int x; // 球当前的坐标位置
        public int y;
        public int dir; // 从哪个方向来的！0 1 2 3 4，4表示初始状态
        public String path; // 之前做了哪些决定让你来到这个位置。
        public Node(int row, int col, int dir, String path) {
            x = row;
            y = col;
            this.dir = dir;
            this.path = path;
        }
    }
}
```

</details>

# 317 UNSOLVED 离建筑物最近的距离

给你一个 m × n 的网格，值为 0 、 1 或 2 ，其中:

    每一个 0 代表一块你可以自由通过的 空地
    每一个 1 代表一个你不能通过的 建筑
    每个 2 标记一个你不能通过的 障碍

你想要在一块空地上建造一所房子，在 最短的总旅行距离 内到达所有的建筑。你只能上下左右移动。

返回到该房子的 最短旅行距离 。如果根据上述规则无法建造这样的房子，则返回 -1 。

总旅行距离 是朋友们家到聚会地点的距离之和。

使用 曼哈顿距离 计算距离，其中距离 (p1, p2) = |p2.x - p1.x | + | p2.y - p1.y | 。

<details>

```cpp
class Solution {
private:
    int bfs(vector<vector<int>>& grid, int row, int col, int totalHouses) {
        // 下一步的四个方向。
        int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int rows = grid.size();
        int cols = grid[0].size();
        int distanceSum = 0;
        int housesReached = 0;
        // 用一个队列开始 BFS，从(r,c)单元格开始
        queue<pair<int, int>> q;
        q.push({row, col});
        // 跟踪访问过的单元格
        vector<vector<bool>> vis(rows, vector<bool>(cols, false));
        vis[row][col] = true;
        int steps = 0;
        while (!q.empty() && housesReached != totalHouses) {
            for (int i = q.size(); i > 0; --i) {
                auto curr = q.front();
                q.pop();
                row = curr.first;
                col = curr.second;
                // 如果此单元格是房屋，则添加从源到此单元格的距离
                // 然后我们从这个单元格经过。
                if (grid[row][col] == 1) {
                    distanceSum += steps;
                    housesReached++;
                    continue;
                }
                // 此单元格为空单元格，因此遍历下一个单元格，这不是阻塞。
                for (auto& dir : dirs) {
                    int nextRow = row + dir[0];
                    int nextCol = col + dir[1];
                    if (nextRow >= 0 && nextCol >= 0 && nextRow < rows &&
                        nextCol < cols) {
                        if (!vis[nextRow][nextCol] &&
                            grid[nextRow][nextCol] != 2) {
                            vis[nextRow][nextCol] = true;
                            q.push({nextRow, nextCol});
                        }
                    }
                }
            }
            // 遍历一级单元格后，将步数加 1 以到达下一级。
            steps++;
        }
        // 如果我们没有到达所有的房子，那么任何被访问的小区也不能到达所有的房子。
        // 将所有已查看的单元格设置为 2，这样我们就不会再次检查它们并返回
        // INT_MAX。
        if (housesReached != totalHouses) {
            for (row = 0; row < rows; row++) {
                for (col = 0; col < cols; col++) {
                    if (grid[row][col] == 0 && vis[row][col]) {
                        grid[row][col] = 2;
                    }
                }
            }
            return INT_MAX;
        }
        // 如果我们已到达所有房屋，则返回计算出的总距离。
        return distanceSum;
    }

public:
    int shortestDistance(vector<vector<int>>& grid) {
        int minDistance = INT_MAX;
        int rows = grid.size();
        int cols = grid[0].size();
        int totalHouses = 0;
        for (int row = 0; row < rows; ++row) {
            for (int col = 0; col < cols; ++col) {
                if (grid[row][col] == 1) {
                    totalHouses++;
                }
            }
        }
        // 求出每个空单元格的最小距离和。
        for (int row = 0; row < rows; ++row) {
            for (int col = 0; col < cols; ++col) {
                if (grid[row][col] == 0) {
                    minDistance =
                        min(minDistance, bfs(grid, row, col, totalHouses));
                }
            }
        }
        // 如果不可能从任何空单元格到达所有房屋，则返回 -1。
        if (minDistance == INT_MAX) {
            return -1;
        }
        return minDistance;
    }
};
```

</details>
