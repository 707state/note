# 200 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

```c++ 
class Solution {
    constexpr static array<int, 4> dx{1, 0, -1, 0};
    constexpr static array<int, 4> dy{0, 1, 0, -1};

public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        std::function<void(int, int)> dfs = [&](int x, int y) {
            grid[x][y] = '0';
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (nx >= 0 && nx < n && ny >= 0 && ny < m &&
                    grid[nx][ny] == '1') {
                    dfs(nx, ny);
                }
            }
        };
        for (int x = 0; x < n; x++) {
            for (int y = 0; y < m; y++) {
                if (grid[x][y] == '1') {
                    ans++;
                    dfs(x, y);
                }
            }
        }
        return ans;
    }
};
```

# 310 最小高度树

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，任何一个没有简单环路的连通图都是一棵树。

给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。

请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。
树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。

广度优先搜索法：

```c++ 
class Solution {
public:
    int findLongestNode(int u, vector<int>& parent,
                        vector<vector<int>>& graph) {
        int n = graph.size();
        queue<int> qu;
        vector<bool> visited(n);
        qu.emplace(u);
        visited[u] = true;
        int node = -1;
        while (!qu.empty()) {
            int curr = qu.front();
            qu.pop();
            node = curr;
            for (auto& v : graph[curr]) {
                if (!visited[v]) {
                    visited[v] = true;
                    parent[v] = curr;
                    qu.emplace(v);
                }
            }
        }
        return node;
    }
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        if (n == 1)
            return {0};
        vector<vector<int>> graph(n);
        for (auto& each : edges) {
            graph[each[0]].emplace_back(each[1]);
            graph[each[1]].emplace_back(each[0]);
        }
        vector<int> parent(n, -1);
        int x = findLongestNode(0, parent, graph);
        int y = findLongestNode(x, parent, graph);
        vector<int> path;
        parent[x] = -1;
        while (y != -1) {
            path.emplace_back(y);
            y = parent[y];
        }
        int m = path.size();
        if (m & 1) {
            return {path[m / 2]};
        } else {
            return {path[m / 2 - 1], path[m / 2]};
        }
    }
};
```

拓扑排序解法：

```c++ 
class Solution {
    vector<vector<int>> graph;
    vector<int> degree;

public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        degree.resize(n);
        graph.resize(n);
        for (auto& each : edges) {
            graph[each[0]].emplace_back(each[1]);
            graph[each[1]].emplace_back(each[0]);
            degree[each[0]]++;
            degree[each[1]]++;
        }
        queue<int> qu;
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            if (degree[i] == 1)
                qu.push(i);
        }
        int remainNodes = n;
        while (remainNodes > 2) {
            int size = qu.size();
            remainNodes -= size;
            for (int i = 0; i < size; i++) {
                int curr = qu.front();
                qu.pop();
                for (auto& v : graph[curr]) {
                    if (--degree[v] == 1) {
                        qu.emplace(v);
                    }
                }
            }
        }
        while (!qu.empty()) {
            ans.emplace_back(qu.front());
            qu.pop();
        }
        return ans;
    }
};
```

# 1436 旅行终点站

给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。

题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。

```c++ 
class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_map<string, int> degree;
        unordered_map<string, vector<string>> graph;
        for (auto& edge : paths) {
            graph[edge[0]].emplace_back(edge[1]);
            if (degree.find(edge[0]) == degree.end()) {
                degree[edge[0]] = 0;
            }
            degree[edge[1]]++;
        }
        queue<string> que;
        for (auto& each : degree) {
            if (each.second == 0) {
                que.emplace(each.first);
            }
        }
        string ans;
        while (que.size()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                auto cur = que.front();
                ans = cur;
                que.pop();
                for (auto& each : graph[cur]) {
                    if (--degree[each] == 0) {
                        que.emplace(each);
                    }
                }
            }
        }
        return ans;
    }
};
```

# 1293 网格中的最短路径

给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。

如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1 。

```c++ 
class Solution {
    using triple = std::array<int, 3>;
    static constexpr std::array<int, 4> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};

public:
    int shortestPath(vector<vector<int>>& grid, int k) {
        int n = grid.size();
        int m = grid[0].size();
        if (m == 1 && n == 1)
            return 0;
        k = min(k, m + n - 3);
        vector<vector<vector<bool>>> visited(
            n, vector<vector<bool>>(m, vector<bool>(k + 1, false)));
        queue<triple> q;
        q.emplace(array{0, 0, k});
        visited[0][0][k] = true;
        for (int step = 1; q.size() > 0; step++) {
            int cnt_size = q.size();
            for (int i = 0; i < cnt_size; i++) {
                auto [x, y, rest] = q.front();
                q.pop();
                for (int j = 0; j < 4; j++) {
                    int nx = x + dx[j];
                    int ny = y + dy[j];
                    if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                        if (grid[nx][ny] == 0 && !visited[nx][ny][rest]) {
                            if (nx == n - 1 && ny == m - 1) {
                                return step;
                            }
                            q.emplace(array{nx, ny, rest});
                            visited[nx][ny][rest] = true;
                        } else if (grid[nx][ny] == 1 && rest > 0 &&
                                   !visited[nx][ny][rest - 1]) {
                            q.emplace(array{nx, ny, rest - 1});
                            visited[nx][ny][rest - 1] = true;
                        }
                    }
                }
            }
        }
        return -1;
    }
};
```
# 801 找到最终的安全状态

有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。

如果一个节点没有连出的有向边，则该节点是 终端节点 。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。

返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。

```c++ 
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n=graph.size();
        vector<int> color(n,0);
        function<bool(int)> safe=[&](int x)->bool{
            if(color[x]>0){
                return color[x]==2;
            }
            color[x]=1;
            for(auto& y:graph[x]){
                if(!safe(y)) return false;
            }
            color[x]=2;
            return true;
        };
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(safe(i)) ans.emplace_back(i);
        }
        return ans;
    }
};
```

# 841 钥匙与房间

有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。

当你进入一个房间，你可能会在里面找到一套 不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。

给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。

```c++ 
class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n=rooms.size();
        vector<int> room_id(n,0);
        function<void(int)> next_foor=[&](int n){
            room_id[n]=1;
            for(auto& y:rooms[n]){
                if(!room_id[y]) next_foor(y);
            }
        };
        next_foor(0);
        for(int i=0;i<n;i++){
            if(room_id[i]==0) return false;
        }
        return true;
    }
};
```

# 797 所有可能路径

给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）

 graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。


```c++ 
class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        int n=graph.size();
        vector<vector<int>> result;
        vector<int> path;
        function<void(int)> find_path=[&](int x){
            if(x==n-1){
                result.emplace_back(path);
                return;
            }
            for(auto & n: graph[x]){
                path.emplace_back(n);
                find_path(n);
                path.pop_back();
            }
        };
        path.push_back(0);
        find_path(0);
        
        return result;
    }
};
```
# 2093 前往目标城市的最小费用

一组公路连接 n 个城市，城市编号为从 0 到 n - 1 。 输入包含一个二维数组 highways ，其中 highways[i] = [city1i, city2i, tolli] 表示有一条连接城市 city1i 和 city2i 的双向公路，允许汽车缴纳值为 tolli 的费用从  city1i 前往 city2i 或 从  city2i 前往 city1i 。

另给你一个整数 discounts 表示你最多可以使用折扣的次数。你可以使用一次折扣使通过第 ith 条公路的费用降低至 tolli / 2（向下取整）。 最多只可使用 discounts 次折扣， 且 每条公路最多只可使用一次折扣 。

返回从城市0 前往城市 n - 1 的 最小费用 。如果不存在从城市0 前往城市 n - 1 的路径，返回 -1 。


分层图最短路问题。

```c++ 
class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& highways, int discounts) {
        vector<vector<vector<int>>> graph(n);
        for(auto& v: highways){
            graph[v[0]].emplace_back(vector{v[1],v[2]});
            graph[v[1]].emplace_back(vector{v[0],v[2]});
        }
        priority_queue<vector<int>,vector<vector<int>> ,greater<vector<int>>> pq;
        vector<vector<int>> dist(n,vector(discounts+1,INT_MAX));
        dist[0][0]=0;
        pq.push({0,0,0});
        while(!pq.empty()){
            auto t=pq.top();
            pq.pop();
            int w=t[0],u=t[1],cnt=t[2];
            if(w>dist[u][cnt]) continue;
            if(cnt<discounts&&dist[u][cnt+1]>w){//同一个节点，不同的折扣层次
                dist[u][cnt+1]=w;
                pq.push({w,u,cnt+1});
            }
            for(auto& e: graph[u]){//遍历相邻的点
                int v=e[0],d=e[1];
                if(dist[v][cnt]>w+d){//同层不打折
                    dist[v][cnt]=w+d;
                    pq.push({w+d,v,cnt});
                }
                if(cnt<discounts&&dist[v][cnt+1]>w+d/2){//下一层且打折
                    dist[v][cnt+1]=w+d/2;
                    pq.push({w+d/2,v,cnt+1});
                }
            }
        }
        return dist[n-1][discounts]==INT_MAX? -1: dist[n-1][discounts];
    }
};
```


# 1192 查找集群内的关键连接

力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。它们之间以 服务器到服务器 的形式相互连接组成了一个内部集群，连接是无向的。用  connections 表示集群网络，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。

关键连接 是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。

请你以任意顺序返回该集群内的所有 关键连接 。

思路：

[Tarjan算法](https://www.youtube.com/watch?v=_1TDxihjtoE)

[割边割点](https://oi-wiki.org/graph/cut/)

```c++ 
class Solution {
public:
    vector<vector<int>> criticalConnections(int n,
                                            vector<vector<int>>& connections) {
        vector<vector<int>> graph(n);
        for (auto& con : connections) {
            int u = con.at(0);
            int v = con.at(1);
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
        vector<vector<int>> ans;
        vector<int> time(n);//dfs过程中，初次访问某个节点时的时间戳
        vector<int> low(n);//每个节点的最小追溯值
        int num{0};//自增数字，用来赋值给节点的时间戳
        dfs(0, 0, graph, time, low, ans, num);//从顶点0开始，并认为其前去节点是0
        return ans;
    }
    void dfs(int u, int pa, vector<vector<int>>& graph, vector<int>& time,
             vector<int>& low, vector<vector<int>>& ans, int& num) {
        low[u] = time[u] = ++num;
        for (auto v : graph[u]) {
            if (time[v] == 0) { // 发现新节点v
                dfs(v, u, graph, time, low, ans, num);
                low[u] = min(low[u], low[v]);
                if (low[v] > time[u]) { // 发现桥边，添加到结果集
                    ans.emplace_back(vector{u, v});
                }
            } else if (
                time[v] < time[u] &&
                v !=
                    pa) { // v在u之前已经被访问过了，因为是无向图，u可以反向访问到其dfs搜索树上的父节点，此时需要跳过
                low[u] = min(low[u], time[v]);
            }
        }
    }
};
```

# 127 单词接龙

字典 wordList 中从单词 beginWord 到 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：


每一对相邻的单词只差一个字母。

对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。

sk == endWord

给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。

```c++ 
class Solution {
    unordered_map<string,int> wordId;
    vector<vector<int>> graph;
    int nodeNum=0;
    void addWord(string& str){
        if(!wordId.count(str)){
            wordId[str]=nodeNum++;
            graph.emplace_back();
        }
    }
    void addEdge(string& word){
        addWord(word);
        int id1=wordId[word];
        for(char& it: word){
            char tmp=it;
            it='*';
            addWord(word);
            int id2=wordId[word];
            graph[id1].push_back(id2);
            graph[id2].push_back(id1);
            it=tmp;
        }
    }
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        for(auto& word: wordList){
            addEdge(word);
        }
        addEdge(beginWord);
        if(!wordId.count(endWord)){
            return 0;
        }
        vector<int> dis(nodeNum,INT_MAX);
        int beginId=wordId[beginWord];
        int endId=wordId[endWord];
        dis[beginId]=0;
        queue<int> que;
        que.push(beginId);
        while(!que.empty()){
            int x=que.front();
            que.pop();
            if(x==endId){
                return dis[endId]/2+1;
            }
            for(auto& it: graph[x]){
                if(dis[it]==INT_MAX){
                    dis[it]=dis[x]+1;
                    que.push(it);
                }
            }
        }
        return 0;
    }
};
```

# 218 扫描线问题

城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。

每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：

    lefti 是第 i 座建筑物左边缘的 x 坐标。
    righti 是第 i 座建筑物右边缘的 x 坐标。
    heighti 是第 i 座建筑物的高度。

你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。

天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

注意：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]

思路：

[扫描线问题](https://oi-wiki.org/geometry/scanning/)

```c++ 
class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        auto cmp = [](const pair<int, int>& a,
                      const pair<int, int>& b) -> bool {
            return a.second < b.second;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>> ,decltype(cmp)> que(cmp);
        vector<int> boundaries;
        for(auto& building: buildings){
            boundaries.emplace_back(building[0]);
            boundaries.emplace_back(building[1]);
        }
        ranges::sort(boundaries);
        vector<vector<int>> ans;
        int n=buildings.size();
        int idx=0;
        for(auto& boundary: boundaries){
            while(idx<n && buildings[idx][0]<=boundary){
                que.emplace(buildings[idx][1],buildings[idx][2]);
                idx++;
            }
            while(!que.empty()&&que.top().first<=boundary){
                que.pop();
            }
            int maxn=que.empty()?0:que.top().second;
            if(ans.size()==0||maxn!=ans.back()[1]){
                ans.push_back({boundary,maxn});
            }
        }
        return ans;
    }
};
```

# 505 迷宫2 

迷宫中有一个球，它有空地 (表示为 0) 和墙 (表示为 1)。球可以向上、向下、向左或向右滚过空地，但直到撞上墙之前它都不会停止滚动。当球停止时，它才可以选择下一个滚动方向。

给定 m × n 的迷宫(maze)，球的起始位置 (start = [startrow, startcol]) 和目的地 (destination = [destinationrow, destinationcol])，返回球在目的地 (destination) 停止的最短距离。如果球不能在目的地 (destination) 停止，返回 -1。

距离是指球从起始位置 ( 不包括 ) 到终点 ( 包括 ) 所经过的空地数。

你可以假设迷宫的边界都是墙 。

```c++ 
class Solution {
public:
    int shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int ans=INT_MAX;
        int n=maze.size();
        int m=maze.front().size();
        vector<vector<int>> graph(n,vector<int>(m,INT_MAX));
        graph[start[0]][start[1]]=0;
        queue<pair<int,int>> que;
        que.emplace(start[0],start[1]);
        while(!que.empty()){
            auto [x,y]=que.front();
            que.pop();
            for(auto [dx,dy]: vector<pair<int,int>>{{1,0},{-1,0},{0,1},{0,-1}}){
                auto nx=x+dx;
                auto ny=y+dy;
                int step=1;
                while(nx>=0&&nx<n&&ny>=0&&ny<m&&maze[nx][ny]==0){
                    nx+=dx;
                    ny+=dy;
                    step++;
                }
                nx-=dx;
                ny-=dy;
                step--;
                if(graph[x][y]+step<graph[nx][ny]){
                    graph[nx][ny]=graph[x][y]+step;
                    que.emplace(nx,ny);
                }
            }
        }
        if(graph[destination[0]][destination[1]]==INT_MAX) return -1;
        return graph[destination[0]][destination[1]];
    }
};
```

# 1557 可以到达所有点的最少点数目

给你一个 有向无环图 ， n 个节点编号为 0 到 n-1 ，以及一个边数组 edges ，其中 edges[i] = [fromi, toi] 表示一条从点  fromi 到点 toi 的有向边。

找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。

你可以以任意顺序返回这些节点编号。

思路：

寻找入度为零的节点就完事。

```c++ 
class Solution {
 public:
  vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {
    vector<int> inDegree(n + 1, 0);
    vector<int> outDegree(n + 1, 0);
    for (auto&& k : edges) {
      inDegree[k[1]]++;
      outDegree[k[0]]++;
    }
    vector<int> ans;
    for (int i = 0; i < n; i++) {
      if (inDegree[i] == 0 && outDegree[i] != 0) ans.push_back(i);
    }
    return ans;
  }
};
```

# 864 获取所有钥匙的最短路径

给定一个二维网格 grid ，其中：

    '.' 代表一个空房间
    '#' 代表一堵墙
    '@' 是起点
    小写字母代表钥匙
    大写字母代表锁

我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。

假设 k 为 钥匙/锁 的个数，且满足 1 <= k <= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。

返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。

```c++ 
class Solution {
    static constexpr array<int,4> dx={0,1,0,-1};
    static constexpr array<int,4> dy={1,0,-1,0};
public:
    int shortestPathAllKeys(vector<string>& grid) {
        int n=grid.size(),m=grid[0].size();
        int sx=0,sy=0;
        unordered_map<char,int> key_to_idx;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]=='@'){
                    sx=i;sy=j;
                }else if(islower(grid[i][j])){
                    if(!key_to_idx.count(grid[i][j])){
                        int idx=key_to_idx.size();
                        key_to_idx[grid[i][j]]=idx;
                    }
                }
            }
        }
        queue<tuple<int,int,int>> q;
        vector<vector<vector<int>>> dist(n,vector<vector<int>>(m,vector<int>(1<<key_to_idx.size(),-1)));
        q.emplace(sx,sy,0);
        dist[sx][sy][0]=0;
        while(!q.empty()){
            auto [x,y,mask]=q.front();
            q.pop();
            for(int i=0;i<4;i++){
                int nx=x+dx[i];
                int ny=y+dy[i];
                if(nx>=0&&nx<n&&ny>=0&&ny<m&&grid[nx][ny]!='#'){
                    if(grid[nx][ny]=='.'||grid[nx][ny]=='@'){
                        if(dist[nx][ny][mask]==-1){
                            dist[nx][ny][mask]=dist[x][y][mask]+1;
                            q.emplace(nx,ny,mask);
                        }
                    }else if(islower(grid[nx][ny])){
                        int idx=key_to_idx[grid[nx][ny]];
                        if(dist[nx][ny][mask|1<<idx]==-1){
                            dist[nx][ny][mask|(1<<idx)]=dist[x][y][mask]+1;
                            if((mask|(1<<idx))==(1<<key_to_idx.size())-1){
                                return dist[nx][ny][mask|(1<<idx)];
                            }
                            q.emplace(nx,ny,mask|(1<<idx));
                        }
                    }else{
                        int idx=key_to_idx[tolower(grid[nx][ny])];
                        if((mask&(1<<idx))&&dist[nx][ny][mask]==-1){
                            dist[nx][ny][mask]=dist[x][y][mask]+1;
                            q.emplace(nx,ny,mask);
                        }
                    }
                }
            }
        }
        return -1;
    }
};
```
# 721 账户合并

给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。

现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。

合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。

```c++ 
class UnionFind{
    vector<int> parent;
    public:
    UnionFind(int n){
        parent.resize(n);
        iota(parent.begin(),parent.end(),0);
    }
    void unionSet(int i1,int i2){
        parent[find(i2)]=find(i1);
    }
    int find(int index){
        if(parent[index]!=index){
            parent[index]=find(parent[index]);
        }
        return parent[index];
    }
};
class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        map<string,string> emailToName;
        map<string,int> emailToIndex;
        int emailsCount=0;
        for(auto& a: accounts){
            auto name=a[0];
            int size=a.size();
            for(int i=1;i<size;i++){
                string& email=a[i];
                if(!emailToIndex.count(email)){
                    emailToIndex[email]=emailsCount++;
                    emailToName[email]=name;
                }
            }
        }
        UnionFind uf(emailsCount);
        for(auto &account: accounts){
            string& firstEmail=account[1];
            int firstIndex=emailToIndex[firstEmail];
            int size=account.size();
            for(int i=2;i<size;i++){
                string& nextEmail=account[i];
                int nextIndex=emailToIndex[nextEmail];
                uf.unionSet(firstIndex, nextIndex);
            }
        }
        map<int,vector<string>> indexToEmails;
        for(auto &[email,_]: emailToIndex){
            int index=uf.find(emailToIndex[email]);
            vector<string>& account=indexToEmails[index];
            account.emplace_back(email);
            indexToEmails[index]=account;
        }
        vector<vector<string>> merged;
        for(auto& [_,emails]: indexToEmails){
            ranges::sort(emails);
            string& name=emailToName[emails[0]];
            vector<string> account;
            account.emplace_back(name);
            for(auto& email: emails){
                account.emplace_back(email);
            }
            merged.emplace_back(account);
        }
        return merged;
    }
};
```

# 839 相似字符串组

如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。

例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。

总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？

```c++ 
class Solution {
    vector<int> parent;
    int find(int index) {
        if (parent[index] != index) {
            parent[index] = find(parent[index]);
        }
        return parent[index];
    }
    bool check(string& a, string& b) {
        int num = 0;
        for (int i = 0; i < a.size(); i++) {
            if (a[i] != b[i]) {
                num++;
            }
            if (num > 2)
                return false;
        }
        return true;
    }

public:
    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        int m = strs[0].length();
        parent.resize(n);
        iota(parent.begin(), parent.end(), 0);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int find_i = find(i), find_j = find(j);
                if (find_i == find_j)
                    continue;
                if (check(strs[i], strs[j])) {
                    parent[find_i] = find_j;
                }
            }
        }
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (parent[i] == i)
                ret++;
        }
        return ret;
    }
};
```

# 210 课程表2 

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

    例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

```c++ 
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> count(numCourses);
        vector<vector<int>> graph(numCourses);
        for(auto& each: prerequisites){
            count[each[0]]++;
            graph[each[1]].emplace_back(each[0]);
        }
        queue<int> que;
                vector<int> ans;
        for(int i=0;i<numCourses;i++){
            if(count[i]==0) {que.emplace(i);ans.push_back(i);}
        }
        if(que.empty()){
            return {};
        }
        int visited=0;
        while(!que.empty()){
            auto top=que.front();
            que.pop();
            visited++;
            for(auto& each: graph[top]){
                if(--count[each]==0){
                    que.emplace(each);
                                ans.push_back(each);
                }
            }
        }
        return numCourses==visited?ans:vector<int>{};
    }
};
```

# 269 火星词典

现有一种使用英语字母的火星语言，这门语言的字母顺序对你来说是未知的。

给你一个来自这种外星语言字典的字符串列表 words ，words 中的字符串已经 按这门新语言的
字典序
进行了排序 。

如果这种说法是错误的，并且给出的 words 不能对应任何字母的顺序，则返回 "" 。

否则，返回一个按新语言规则的 字典递增顺序 排序的独特字符串。如果有多个解决方案，则返回其中 任意一个 。

思路：

words中的字符串按照字典序排序，就说明对于相邻的字符串a,b, 其中第一个不相同的字符a\[i\], b\[i\]就表示他们在图中的位置，前者在后者之上。

```c++ 
class Solution {
    unordered_map<char,vector<char>> edges;
    unordered_map<char,int> indegree;
    bool valid=true;
public:
    void add_edge(string& a,string& b){
        int len1=a.length(),len2=b.length();
        int len=min(len1,len2);
        int index=0;
        while(index<len){
            auto c1=a[index],c2=b[index];
            if(c1!=c2){
                edges[c1].emplace_back(c2);
                indegree[c2]++;
                break;
            }
            index++;
        }
        if(index==len&&len1>len2) valid=false;//不满足任何字母顺序
    }
    string alienOrder(vector<string>& words) {
        int len=words.size();
        for(auto& word:words){
            for(auto& c: word){
                if(edges.count(c)==0){
                    edges[c]=vector<char>();
                }
            }
        }
        for(int i=1;i<len;i++){
            add_edge(words[i-1],words[i]);
        }
        if(!valid) return "";
        queue<char> que;
        for(auto& [u,_]: edges){//如果u这个点的入度为0
            if(!indegree.count(u)) que.emplace(u);
        }
        string order;
        while(!que.empty()){
            auto u=que.front();
            que.pop();
            order.push_back(u);
            for(auto& v: edges[u]){
                if(--indegree[v]==0){
                    que.emplace(v);
                }
            }
        }
        return order.size()==edges.size()? order: "";
    }
};
```

# 1203 项目管理

有 n 个项目，每个项目或者不属于任何小组，或者属于 m 个小组之一。group[i] 表示第 i 个项目所属的小组，如果第 i 个项目不属于任何小组，则 group[i] 等于 -1。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。

请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：


同一小组的项目，排序后在列表中彼此相邻。

项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。

如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。

思路：

这道题实际上有两个拓扑关系：

1. 组内的每一个item之间存在拓扑关系

2. 每一个组之间因为item的关系也会存在依赖关系

将每一个group\[i\]为-1的item设置为一个独立的groupId, 然后先将每一个组之间进行排序，再对每一个组进行排序。

```c++ 
class Solution {
    vector<int> topSort(vector<int>& indegree, vector<vector<int>>& graph,
                        vector<int>& items) {
        queue<int> que;
        vector<int> sorted;
        for (auto& item : items) {
            if (indegree[item] == 0) {
                que.push(item);
            }
        }
        while (!que.empty()) {
            auto top = que.front();
            que.pop();
            sorted.emplace_back(top);
            for (auto& each : graph[top]) {
                if (--indegree[each] == 0) {
                    que.emplace(each);
                }
            }
        }
        return sorted.size() == items.size() ? sorted : vector<int>{};
    }

public:
    vector<int> sortItems(int n, int m, vector<int>& group,
                          vector<vector<int>>& beforeItems) {
        vector<vector<int>> groupItem(n + m);
        vector<vector<int>> groupGraph(m + n);
        vector<vector<int>> itemGraph(n);
        vector<int> groupDegree(n + m);
        vector<int> itemIndegree(n);
        vector<int> id(n + m);
        iota(id.begin(), id.end(), 0);
        int leftId = m;
        // 给没有分配组的item分配一个groupId(视为每个一组)
        for (int i = 0; i < n; i++) {
            if (group[i] == -1) {
                group[i] = (leftId++);
            }
            groupItem[group[i]].emplace_back(i);
        }
        // 依赖关系建图
        for (int i = 0; i < n; i++) {
            auto& curGroup = group[i];
            for (auto& item : beforeItems[i]) {
                int beforeGroupItemId = group[item];
                if (beforeGroupItemId == curGroup) {
                    itemIndegree[i] += 1;
                    itemGraph[item].emplace_back(i);
                } else {
                    groupDegree[curGroup] += 1;
                    groupGraph[beforeGroupItemId].emplace_back(curGroup);
                }
            }
        }
        // 组间拓扑关系排序
        vector<int> groupTopSorted = topSort(groupDegree, groupGraph, id);
        if (groupTopSorted.size() == 0) {
            return vector<int>();
        }
        vector<int> ans;
        // 组内拓扑关系排序
        for (auto& curGroupId : groupTopSorted) {
            int size = groupItem[curGroupId].size();
            if (size == 0)
                continue;
            vector<int> res =
                topSort(itemIndegree, itemGraph, groupItem[curGroupId]);
            if (res.size() == 0) {
                return {};
            }
            for (auto& item : res) {
                ans.emplace_back(item);
            }
        }
        return ans;
    }
};
```

# 1857 有向图中最大颜色值

给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。

给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。

图中一条有效 路径 是一个点序列 x1 -> x2 -> x3 -> ... -> xk ，对于所有 1 <= i < k ，从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。

请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。

思路：

拓扑排序上进行动态规划。

```c++ 
class Solution {
public:
    int largestPathValue(string colors, vector<vector<int>>& edges) {
        int n=colors.length();
        vector<vector<int>> graph(n);
        //邻接表
        //入度
        vector<int> indegree(n);
        for(auto&& edge: edges){
            ++indegree[edge[1]];
            graph[edge[0]].emplace_back(edge[1]);
        }
        //记录拓扑排序过程中遇到的节点个数
        //如果found的值不是n, 说明途中存在环
        int found=0;
        vector<array<int,26>> f(n);
        queue<int> que;
        for(int i=0;i<n;i++){
            if(!indegree[i]) que.push(i);
        }
        while(!que.empty()){
            ++found;
            int u=que.front();
            que.pop();
            ++f[u][colors[u]-'a'];
            for(auto& v: graph[u]){
                --indegree[v];
                for(int c=0;c<26;c++){
                    f[v][c]=max(f[v][c],f[u][c]);
                }
                if(!indegree[v]) que.push(v);
            }
        }
        if(found!=n) return -1;
        int ans=0;
        for(int i=0;i<n;i++) ans=max(ans,ranges::max(f[i]));
        return ans;
    }
};
```
