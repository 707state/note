# Aho-Corasick Algorithm

字符串搜索算法：用于在输入的一串字符串中匹配有限组“字典”中的子串。

它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。

算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。然而由于需要找到所有匹配数，如果每个子串互相匹配（如字典为a，aa，aaa，aaaa，输入的字符串为aaaa），算法的时间复杂度会近似于匹配的二次函数。 


该算法主要依靠构造一个有限状态机（类似于在一个trie树中添加失配指针）来实现。这些额外的失配指针允许在查找字符串失败时进行回退（例如设Trie树的单词cat匹配失败，但是在Trie树中存在另一个单词cart，失配指针就会指向前缀ca），转向某前缀的其他分支，免于重复匹配前缀，提高算法效率。 

## 前缀函数


一个长度为n的字符串s，前缀函数就是一个长度为n的数组n。其中n[i]的定义：

如果字串t[0..i]有一对相等的真前缀和真后缀：s[0..k-1]和s[i-(k-1)..i]，那么n[i]就是这个相等的真前缀的长度k，即n[i]=k。

如果有不止一对相等的，那么n[i]就是其中最长的那一对的长度。

如果没有相等的，那么n[i]就是0。

规定: n[0]=0。

朴素实现：

<details>

```cpp
vector<int> prefix_function(string s) {
  int n = (int)s.length();
  vector<int> pi(n);
  for (int i = 1; i < n; i++)
    for (int j = i; j >= 0; j--)
      if (s.substr(0, j) == s.substr(i - j + 1, j)) {
        pi[i] = j;
        break;
      }
  return pi;
}
```
</details>
 
这个算法的时间复杂度是O(n^3)。

第一个优化：

相邻的前缀函数值至多增加1。所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。

这时的实现：

<details>

```cpp
vector<int> prefix_function(string s) {
  int n = (int)s.length();
  vector<int> pi(n);
  for (int i = 1; i < n; i++)
    for (int j = pi[i - 1] + 1; j >= 0; j--)  // improved: j=i => j=pi[i-1]+1
      if (s.substr(0, j) == s.substr(i - j + 1, j)) {
        pi[i] = j;
        break;
      }
  return pi;
}
```

</details>

这里，再计算每一个n[i]时，最好的情况是第一次字符串比较就完成匹配。

由此我们可以得出字符串比较次数最多的一种情况：至少 1 次字符串比较次数的消耗和最多 n-2 次比较次数的积累，此时字符串比较次数为 n-1 + n-2 = 2n-3。

可见经过此次优化，计算前缀函数只需要进行 O(n) 次字符串比较，总复杂度降为了 O(n^2) 。
 

第二个优化：

当s[i+1]!=s[n[i]]时怎么跳转，也就是失配时怎么跳转。

失配时，我们希望找到对于字串s[0..i]仅次于n[i]的第二长度j, 使得在位置i的前缀性质仍然能够保持，也就是s[0..j-1]=s[i-j+1..i。

如果我们找到这样的j，那么仅需要比较s[i+1]和s[j]，就有n[i+1]=j+1。否则就需要找到字串s[0..i]仅次于j的第二长度k, 使得前缀树的性质能够保持，反复之后，如果s[i+1]!=s[0]。，则n[i+1]=0。

这是可以注意到：

因为s[0..n[i]-1]=s[i-n[i]+1..i]，所以对于s[0..i]的第二长度j，有如下性质：

s[0..j-1]=s[i-k+1..i]=s[n[i]-j..n[i]-1]。

也就是说，j等价于字串s[n[i]-1]的前缀函数值，即j=n[n[i]-1]；同理，次于j的第二长度k=n[j-1]。

因此就可以得到转移方程：

\\\( j^{n}=n[j^{n-1}-1]   \\\)

最终实现：

```cpp
vector<int> prefix_function(string s) {
  int n = (int)s.length();
  vector<int> pi(n);
  for (int i = 1; i < n; i++) {
    int j = pi[i - 1];
    while (j > 0 && s[i] != s[j]) j = pi[j - 1];
    if (s[i] == s[j]) j++;
    pi[i] = j;
  }
  return pi;
}
```

这是一个 在线 算法，即其当数据到达时处理它——举例来说，你可以一个字符一个字符的读取字符串，立即处理它们以计算出每个字符的前缀函数值。该算法仍然需要存储字符串本身以及先前计算过的前缀函数值，但如果我们已经预先知道该字符串前缀函数的最大可能取值 [M] ，那么我们仅需要存储该字符串的前 [M + 1] 个字符以及对应的前缀函数值。

# 应用

## Knuth-Morris-Pratt算法

### 过程

给定一个文本 [t] 和一个字符串 [s] ，我们尝试找到并展示 [s] 在 [t] 中的所有出现（occurrence）。

为了简便起见，我们用 [n] 表示字符串 [s] 的长度，用 [m] 表示文本 [t] 的长度。

我们构造一个字符串 [s + \# + t] ，其中 [\#] 为一个既不出现在 [s] 中也不出现在 [t] 中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始 [n + 1] 个值（即属于字符串 [s] 和分隔符的函数值）后其余函数值的意义。

根据定义，n[i]为右端点在i且同时为一个前缀的最长真子串的长度，其值为与s的前缀相同且右端点位于i的最长子串的长度。

由于分隔符的存在，该长度不可能超过 n。而如果等式 n[i] = n 成立，则意味着 [s] 完整出现在该位置（即其右端点位于位置 [i] ）。注意该位置的下标是对字符串 [s + \# + t] 而言的。

因此如果在某一处位置i有n[i]==n出现，则字符串s在字符串t的i-(n-1)-(n+1)=i-2*n的位置出现。

正如在前缀函数的计算中已经提到的那样，如果我们知道前缀函数的值永远不超过一特定值，那么我们不需要存储整个字符串以及整个前缀函数，而只需要二者开头的一部分。在我们这种情况下这意味着只需要存储字符串 [s + \#] 以及相应的前缀函数值即可。我们可以一次读入字符串 [t] 的一个字符并计算当前位置的前缀函数值。

实现如下：

```cpp
vector<int> find_occurrences(string text, string pattern) {
  string cur = pattern + '#' + text;
  int sz1 = text.size(), sz2 = pattern.size();
  vector<int> v;
  vector<int> lps = prefix_function(cur);
  for (int i = sz2 + 1; i <= sz1 + sz2; i++) {
    if (lps[i] == sz2) v.push_back(i - 2 * sz2);
  }
  return v;
}
```

### 字符串的周期

对于字符串s和0 < p < |s|，如果s[i]=s[i+p]对0到|s|-p-1的i都成立，就称p是s的周期。

对于字符串s和0<=r<=|s| , 若s长度为r的前缀和长度为r的后缀相等，就称s长度为r的前缀是s的Border。

简单来说，一个“border”是指既是一个前缀又是一个后缀的非空子串，但不包括整个字符串本身。

由s有长度为r的border可以推导出|s|-r是s的周期。

根据前缀函数的定义，可以得到s所有的border长度，即n[n-1], n[n[n-1]-1]。

所以根据前缀函数可以在 O(n) 的时间内计算出 [s] 所有的周期。

# AC自动机

AC 自动机本质上是 Trie 上的自动机。

建立一个AC自动机有两个步骤：

1. 基础的Trie结构：将所有的模式构建成一个Trie；

2. KMP的思想：对Trie上的所有节点构造失配指针。

建立完毕后，就可以利用它进行多模式匹配。


