
# 1005 k次取反后最大化的数组和

给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：

    选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。

重复这个过程恰好 k 次。可以多次选择同一个下标 i 。

以这种方式修改数组后，返回数组 可能的最大和 。


```cpp 
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end(),[](int a,int b){
            return abs(a)>abs(b);
        });
        for(int i=0;i<nums.size();i++){
            if(nums[i]<0&&k>0){
                nums[i]=-nums[i];
                k--;
            }
        }
        if(k%2==1) nums[nums.size()-1]*=-1;
        int result=0;
        for(auto& a: nums){
            result+=a;
        }
        return result;
    }
};
```

# 45 跳跃游戏 2 

给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:


0 <= j <= nums[i] 

i + j < n

返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

```cpp 
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) {
            return 0;
        }
        int cur_dist = 0;
        int ans = 0;
        int next_dist = 0;
        for (int i = 0; i < nums.size(); i++) {
            next_dist = max(next_dist, nums[i] + i);
            if (i == cur_dist) {
                if (cur_dist != nums.size() - 1) {
                    ans++;
                    cur_dist = next_dist;
                    if (next_dist >= nums.size() - 1)
                        break;
                } else {
                    break;
                }
            }
        }
        return ans;
    }
};
```
简化逻辑：
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans=0;
        int cur_right=0;
        int next_right=0;
        for(int i=0;i+1<nums.size();i++){
            next_right=max(next_right,i+nums[i]);
            if(i==cur_right){
                cur_right=next_right;
                ans++;
            }
        }
        return ans;
    }
};
```


# 134 加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的

```cpp 
class Solution {
    public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int curSum = 0;
    int totalSum = 0;
    int start = 0;
    for (int i = 0; i < gas.size(); i++) {
        curSum += gas[i] - cost[i];
        totalSum += gas[i] - cost[i];
        if (curSum < 0) {
        // 当前累加rest[i]和 curSum一旦小于0
            start = i + 1;// 起始位置更新为i+1
            curSum = 0;// curSum从0开始
        }
    }
    if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
    return start;
}
};
```

# 135 分发糖果

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

    每个孩子至少分配到 1 个糖果。
    相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

思路：


这道题目一定是要确定一边之后,再确定另一边,例如比较每一个孩子的左边,然后再比较右边,如果两边一起考虑一定会顾此失彼。

先确定右边评分大于左边的情况(也就是从前向后遍历)此时局部最优:只要右边评分比左边大,右边的孩子就多一个糖果,全局最优:相邻的孩子中,评分高的右孩子获得比左边孩子更多的糖果局部最优可以推出全局最优。
如果ratings[i] > ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个,所以贪心:candyVec[i] = candyVec[i - 1] + 1


再确定左孩子大于右孩子的情况(从后向前遍历)

遍历顺序这里有同学可能会有疑问,为什么不能从前向后遍历呢?

因为如果从前向后遍历,根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果,那么每次都不能利用上前一次的比较结果了。

所以确定左孩子大于右孩子的情况一定要从后向前遍历!如果 ratings[i] > ratings[i + 1],此时candyVec[i](第i个小孩的糖果数量)就有两个选择了,一个是candyVec[i +1] + 1(从右边这个加1得到的糖果数量),一个是candyVec[i](之前比较右孩子大于左孩子得到的糖果数量)。
那么又要贪心了,局部最优:取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量,保证第i个小孩的糖果数量即
大于左边的也大于右边的。全局最优:相邻的孩子中,评分高的孩子获得更多的糖果。
局部最优可以推出全局最优。
所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量,candyVec[i]只有取最大的才能既保持对左边
candyVec[i - 1]的糖果多,也比右边candyVec[i + 1]的糖果多。

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(),1);
        //从前向后
        for(int i=1;i<ratings.size();i++){
            if(ratings[i]>ratings[i-1]) candyVec[i]=candyVec[i-1]+1;
        }
        //从后向前
        for(int i=ratings.size()-2;i>=0;i--){
            if(ratings[i]>ratings[i+1]){
                candyVec[i]=max(candyVec[i],candyVec[i+1]+1);
            }
        }
        return accumulate(candyVec.begin(), candyVec.end(),0);
    }
};
```

# 406 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。


思路：

按照身高排序之后,优先按身高高的people的k来插入,后序插入节点也不会影响前面已经插入的节点,最终按照k
的规则完成了队列。
所以在按照身高从大到小排序后:
局部最优:优先按身高高的people的k来插入。插入操作过后的people满足队列属性
全局最优:最后都做完插入操作,整个队列满足题目队列属性



```cpp
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        auto cmp=[](vector<int>& a,vector<int>& b)->bool{
            if(a[0]==b[0]) return a[1]<b[1];
            return a[0]>b[0];
        };
        sort(people.begin(),people.end(),cmp);
        vector<vector<int>> queue;
        for(int i=0;i<people.size();i++){
            int position=people[i][1];
            queue.insert(queue.begin()+position, people[i]);
        }
        return queue;
    }
};
```

# 452 最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

```cpp
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        auto cmp=[](vector<int>& a,vector<int>& b)->bool{
            return a[0]<b[0];
        };
        if(points.size()==0) return 0;
        sort(points.begin(),points.end(),cmp);
        int result=1;
        for(int i=1;i<points.size();i++){
            if(points[i][0]>points[i-1][1]){
                result++;
            }else{
                points[i][1]=min(points[i-1][1],points[i][1]);
            }
        }
        return result;
    }
};
```

# 435 无重叠区间

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。



```cpp 
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        auto cmp=[](vector<int>& a,vector<int>& b)->bool{
        return a[1]<b[1];
        };
        sort(intervals.begin(),intervals.end(),cmp);
        int count=1;
        int end=intervals[0][1];
        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0]>=end){
                end=intervals[i][1];
                count++;
            }
        }
        return intervals.size()-count;
    }
};
```

# 763 划分字母区间

给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。

```cpp 
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int hash[27]{};
        for(int i=0;i<s.size();i++){
            hash[s[i]-'a']=i;
        }
        vector<int> result;
        int left=0,right=0;
        for(int i=0;i<s.size();i++){
            right=max(right,hash[s[i]-'a']);
            if(i==right){
                result.push_back(right-left+1);
                left=i+1;
            }
        }
        return result;
    }
};
```

# 56 合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        auto cmp=[](vector<int>& a,vector<int>& b)->bool{
            return a[0]<b[0];
        };
        sort(intervals.begin(),intervals.end(),cmp);
        auto left=intervals[0][0];
        auto right=intervals[0][1];
        vector<vector<int>> result;
        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0]>right){
                result.push_back({left,right});
                left=intervals[i][0];
                right=intervals[i][1];
            }
            right=max(right,intervals[i][1]);
        }
         result.push_back({left,right});
        return result;
    }
};
```

# 738 单调递增的数字

当且仅当每个相邻位数上的数字 x 和 y 满足 x 小于等于 y 时，我们称这个整数是单调递增的。

给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        auto num=to_string(n);
        int flag=num.size();
        for(int i=num.size()-1;i>0;i--){
            if(num[i-1]>num[i]){
                flag=i;
                num[i-1]--;
            }
        }
        for(int i=flag;i<num.size();i++){
            num[i]='9';
        }
        return stoi(num);
    }
};
```

# 968 监控二叉树

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。


所以我们要从下往上看,局部最优:让叶子节点的父节点安摄像头,所用摄像头最少,整体最优:全部摄像头数量
所用最少!

```cpp
class Solution {
    int result=0;
    int traversal(TreeNode *cur){
        if(!cur) return 2;
        int left=traversal(cur->left);
        int right=traversal(cur->right);
        if(left==2&&right==2) return 0;
        else if(left==0||right==0){
            result++;
            return 1;
        }else return 2;
    }
public:
    int minCameraCover(TreeNode* root) {
        if(traversal(root)==0){//root无覆盖
            result++;
        }
        return result;
    }
};
```

# 455 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int ans=0;
        ranges::sort(g);
        ranges::sort(s);
        int m=g.size();
        int n=s.size();
        for(int i=0,j=0;i<m&&j<n;i++,j++){
            while(j<n&&g[i]>s[j]){
                j++;
            }
            if(j<n) ans++;
        }
        return ans;
    }
};
```

# 871 最低加油次数

汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。

沿途有加油站，用数组 stations 表示。其中 stations[i] = [positioni, fueli] 表示第 i 个加油站位于出发位置东面 positioni 英里处，并且有 fueli 升汽油。

假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。

为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。

注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。


思路：

当汽车行驶到第 i 个加油站时，视作获取了一个装有 fueli升汽油的油桶。

在后续的行驶过程中，可以在没油时，把油桶中的油加到汽车中。

选哪个（哪些）油桶？

为了让加油次数尽量少，贪心地选油量多的油桶。

由于有添加和删除操作，用最大堆维护这些油桶。

```cpp 
class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        stations.push_back({target,0});
        int ans=0,pre_position=0,cur_fuel=startFuel;
        priority_queue<int> fuel_heap;
        for(auto& station:stations){
            int position=station[0];
            cur_fuel-=(position-pre_position);
            while(!fuel_heap.empty()&&cur_fuel<0){
                cur_fuel+=fuel_heap.top();
                fuel_heap.pop();
                ans++;
            }
            if(cur_fuel<0){
                return -1;
            }
            fuel_heap.push(station[1]);
            pre_position=position;
        }
        return ans;
    }
};
```

# 1090 受标签影响的最大值

以两个整数数组  values 和 labels 给定 n 个项的值和标签，并且给出两个整数 numWanted 和 useLimit 。

你的任务是从这些项中找到一个值的和 最大 的子集使得：

    项的数量 最多 为 numWanted。
    相同标签的项的数量 最多 为 useLimit。

返回最大的和。

```cpp 
class Solution {
public:
    int largestValsFromLabels(vector<int>& values, vector<int>& labels, int numWanted, int useLimit) {
        int n=values.size();
        vector<pair<int,int>> pairs(n);
        for(int i=0;i<n;++i){
            pairs[i]={-values[i],labels[i]};
        }
        sort(pairs.begin(),pairs.end());
        unordered_map<int,int> cnt;
        int ans=0,num=0;
        for(int i=0;i<n&&num<numWanted;i++){
            int v=-pairs[i].first,l=pairs[i].second;
            if(cnt[l]<useLimit){
                ++cnt[l];
                ++num;
                ans+=v;
            }
        }
        return ans;
    }
};
```
# 3255 长度为k的子数组的能量值2

给你一个长度为 n 的整数数组 nums 和一个正整数 k 。

一个数组的 能量值 定义为：

    如果 所有 元素都是依次 连续 且 上升 的，那么能量值为 最大 的元素。
    否则为 -1 。

你需要求出 nums 中所有长度为 k 的 
子数组
 的能量值。

请你返回一个长度为 n - k + 1 的整数数组 results ，其中 results[i] 是子数组 nums[i..(i + k - 1)] 的能量值。

```cpp
class Solution {
public:
    vector<int> resultsArray(vector<int>& nums, int k) {
        vector<int> ans(nums.size()-k+1,-1);
        int cnt=0;
        for(int i=0;i<nums.size();i++){
            cnt=i==0||nums[i]==nums[i-1]+1?cnt+1:1;
            if(cnt>=k){
                ans[i-k+1]=nums[i];
            }
        }
        return ans;
    }
};
```

# UNSOLVED 2071 你可以安排的最多任务数目

给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] >= tasks[i] ）。

除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。

给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。
```cpp
class Solution {
public:
    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {
        int n=tasks.size(),m=workers.size();
        ranges::sort(tasks);
        ranges::sort(workers);
        auto check=[&](int mid)->bool{
            int p=pills;
            multiset<int> ws;
            for(int i=m-mid;i<m;i++){
                ws.insert(workers[i]);
            }
            for(int i=mid-1;i>=0;i--){
                if(auto it=prev(ws.end());*it>=tasks[i]){
                    ws.erase(it);
                }else{
                    if(!p){
                        return false;
                    }
                    auto rep=ws.lower_bound(tasks[i]-strength);
                    if(rep==ws.end()){
                        return false;
                    }
                    --p;
                    ws.erase(rep);
                }
            }
            return true;
        };
        int left=1,right=min(m,n),ans=0;
        while(left<=right){
            int mid=(left+right)/2;
            if(check(mid)){
                ans=mid;
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return ans;
    }
};
```
