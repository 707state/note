<!--toc:start-->
- [1150 检查大多数](#1150-检查大多数)
- [153 寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)
- [2187 完成旅途的最少时间](#2187-完成旅途的最少时间)
- [2529 正整数和负整数的最大计数](#2529-正整数和负整数的最大计数)
- [2563 统计公平数对的数目](#2563-统计公平数对的数目)
- [2576 求出最多标记下标](#2576-求出最多标记下标)
- [正方形的最多点数](#正方形的最多点数)
- [33 搜索旋转排序数组](#33-搜索旋转排序数组)
- [852 山脉数组的峰顶索引](#852-山脉数组的峰顶索引)
- [LCR 170 交易逆序对的总数](#lcr-170-交易逆序对的总数)
- [4 UNSOLVED 寻找两个正序数组的中位数](#4-unsolved-寻找两个正序数组的中位数)
- [268 丢失的数字](#268-丢失的数字)
- [162 寻找峰值](#162-寻找峰值)
- [436 寻找右区间](#436-寻找右区间)
- [403 青蛙过河](#403-青蛙过河)
- [378 有序矩阵中第 K 小的元素](#378-有序矩阵中第-k-小的元素)
- [74 搜索二维矩阵](#74-搜索二维矩阵)
- [1060 有序数组中的缺失元素](#1060-有序数组中的缺失元素)
- [1760 袋里最少数目的球](#1760-袋里最少数目的球)
- [1287 有序数组中超过1/4的元素](#1287-有序数组中超过14的元素)
- [2080 区间查询数字的频率](#2080-区间查询数字的频率)
- [29 两数相除](#29-两数相除)
- [81 搜索旋转排序数组Ⅱ](#81-搜索旋转排序数组ⅱ)
- [UNSOLVED 923 漂亮数组](#unsolved-923-漂亮数组)
- [给定一个非空升序数列 S，请你实现一个函数，找到其中绝对值最小的数字。](#给定一个非空升序数列-s请你实现一个函数找到其中绝对值最小的数字)
- [1283 使结果不超过阈值的最小除数](#1283-使结果不超过阈值的最小除数)
- [1870 准时到达的列车最小时速](#1870-准时到达的列车最小时速)
- [410 分割数组的最大值](#410-分割数组的最大值)
- [UNSOLVED 1231 分享巧克力](#unsolved-1231-分享巧克力)
- [UNSOLVED 1631 最小体力消耗路径](#unsolved-1631-最小体力消耗路径)
- [1802 有界数组中指定下标处的最大值](#1802-有界数组中指定下标处的最大值)
- [UNSOLVED 1235 规划兼职工作](#unsolved-1235-规划兼职工作)
- [887 鸡蛋掉落](#887-鸡蛋掉落)
- [287 寻找重复数](#287-寻找重复数)
<!--toc:end-->

# 1150 检查大多数

给出一个按 非递减 顺序排列的数组 nums，和一个目标数值 target。假如数组 nums 中绝大多数元素的数值都等于 target，则返回 True，否则请返回 False。

所谓占绝大多数，是指在长度为 N 的数组中出现必须 超过 N/2 次。

<details>

```cpp
class Solution {
    int left(vector<int>& nums,int target){
        int left=0;
        int right=nums.size();
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]>=target){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
    int right(vector<int>& nums,int target){
        int left=0;
        int right=nums.size();
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]<=target){
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return left;
    }
public:
    bool isMajorityElement(vector<int>& nums, int target) {
        int vright=right(nums,target);
        int vleft=left(nums,target);
        return (vright-vleft)>(nums.size())/2;
    }
};
```

</details>

# 153 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转
后，得到输入数组。例如，原数组 nums = \[0,1,2,4,5,6,7\]
在变化后可能得到：

    若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
    若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 \[a\[0\], a\[1\], a\[2\], \..., a\[n-1\]\] 旋转一次
的结果为数组 \[a\[n-1\], a\[0\], a\[1\], a\[2\], \..., a\[n-2\]\] 。

给你一个元素值 互不相同 的数组 nums
，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的
最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        if(right==0) return nums.front();
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]<nums[right]){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return nums[left];
    }
};
```

</details>

# 2187 完成旅途的最少时间

给你一个数组 time ，其中 time\[i\] 表示第 i 辆公交车完成 一趟旅途
所需要花费的时间。

每辆公交车可以 连续
完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始
下一趟旅途。每辆公交车 独立
运行，也就是说可以同时有多辆公交车在运行且互不影响。

给你一个整数 totalTrips ，表示所有公交车 总共
需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少
时间。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        auto check=[&](long long x)->bool{
            long long sum=0;
            for(auto& t: time){
                sum+=x/t;
                if(sum>=totalTrips){
                    return true;
                }
            }
            return false;
        };
        long long min_t=ranges::min(time);
        long long left=min_t-1;//循环不变量
        long long right=totalTrips*min_t;
        while(left+1<right){
            auto mid=(right+left)/2;
            (check(mid)?right:left)=mid;
        }
        return right;
    }
};
```

</details>

# 2529 正整数和负整数的最大计数

给你一个按 非递减顺序 排列的数组 nums
，返回正整数数目和负整数数目中的最大值。

换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回
pos 和 neg 二者中的最大值。

注意：0 既不是正整数也不是负整数。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int maximumCount(vector<int>& nums) {
     int neg=0,pos=0;
     int left=0,right=nums.size()-1;
     auto lowerBound=[&](vector<int>& num,int val)->int{
        int l=0,r=num.size();
        while(l<r){
            int m=(r+l)/2;
            if(nums[m]>=val){
                r=m;
            }else if(nums[m]<val){
                l=m+1;
            }
        }
        return l;
     };
     left=lowerBound(nums,0);
     right=lowerBound(nums,1);
     return max(left,(int)nums.size()-right);
    }
};
```

</details>

# 2563 统计公平数对的数目

给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和
upper ，返回 公平数对的数目 。

如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：

0 \<= i \< j \< n，且

lower \<= nums\[i\] + nums\[j\] \<= upper

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        long long ans=0;
        ranges::sort(nums);
        for(int i=0;i<nums.size();++i){
            auto l=lower_bound(nums.begin(),nums.begin()+i,lower-nums[i]);
            auto r=upper_bound(nums.begin(),nums.begin()+i,upper-nums[i]);
            ans+=r-l;
        }
        return ans;
    }
};
```

</details>

# 2576 求出最多标记下标

给你一个下标从 0 开始的整数数组 nums 。

一开始，所有下标都没有被标记。你可以执行以下操作任意次：

    选择两个 互不相同且未标记 的下标 i 和 j ，满足 2 * nums[i] <= nums[j] ，标记下标 i 和 j 。

请你执行上述操作任意次，返回 nums 中最多可以标记的下标数目。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
      ranges::sort(nums);
      int n=nums.size();
      int l=0,r=n/2;
      auto check=[&](int m){
        for(int i=0;i<m;i++){
            if(nums[i]*2>nums[n-m+i]){
                return false;
            }
        }
        return true;
      };
      while(l<r){
        int m=r+l+1>>1;
        if(check(m)){
            l=m;
        }else{
            r=m-1;
        }
      }
      return l*2;
    }
};
```

</details>

# 正方形的最多点数

给你一个二维数组 points 和一个字符串 s ，其中 points\[i\] 表示第 i
个点的坐标，s\[i\] 表示第 i 个点的 标签 。

如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不
存在标签相同的两个点，那么我们称这个正方形是 合法 的。

请你返回 合法 正方形中可以包含的 最多 点数。

注意：

如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。

正方形的边长可以为零。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int maxPointsInsideSquare(vector<vector<int>>& points, string s) {
        int ans=0;
        auto check=[&](int size)->bool{
            int vis=0;
            for(int i=0;i<points.size();i++){
                if(abs(points[i][0])<=size && abs(points[i][1])<=size){
                    auto c=s[i]-'a';
                    if(vis>>c&1){//c在集合中
                        return false;
                    }
                    vis|=1<<c;
                }
            }
            ans=__builtin_popcount(vis);
            return true;
        };
        int left=-1,right=1'000'000'001;
        while(left+1<right){
            int mid=(left+right)/2;
            (check(mid)?left:right)=mid;
        }
        return ans;
    }
};
```

</details>

这个解法使用了位运算

# 33 搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 \<= k \<
nums.length）上进行了 旋转，使数组变为 \[nums\[k\], nums\[k+1\], \...,
nums\[n-1\], nums\[0\], nums\[1\], \..., nums\[k-1\]\]（下标 从 0 开始
计数）。例如， \[0,1,2,4,5,6,7\] 在下标 3 处经旋转后可能变为
\[4,5,6,7,0,1,2\] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(right-left)/2+left;
            if(nums[mid]==target) return mid;
            if(nums[0]<=nums[mid]){
                if(nums[0]<=target&&target<nums[mid]) right=mid-1;
                else left=mid+1;
            }else{
                if(nums[mid]<target&&target<=nums.back()) left=mid+1;
                else right=mid-1;
            }
        }
        return -1;
    }
};
```

</details>

# 852 山脉数组的峰顶索引
给定一个长度为 n 的整数 山脉 数组 arr ，其中的值递增到一个 峰值元素
然后递减。

返回峰值元素的下标。

你必须设计并实现时间复杂度为 O(log(n)) 的解决方案。

记满足题目要求的下标 i 为 ians。我们可以发现：

    当 i<ians 时，arri<arri+1 恒成立；

    当 i≥ians 时，arri>arri+1 恒成立。

因此 ians 即为「最小的满足 arri\>arri+1 的下标
i，我们可以用二分查找的方法来找出 ians。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int left = 1, right = arr.size() - 2, ans = 0;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (arr[mid] > arr[mid + 1]) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
};
```

</details>

# LCR 170 交易逆序对的总数

在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录
record，返回其中存在的「交易逆序对」总数。

思路： 归并排序

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int mergeSort(vector<int>& record, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }

        int mid = (l + r) / 2;
        int inv_count = mergeSort(record, tmp, l, mid) + mergeSort(record, tmp, mid + 1, r);
        int i = l, j = mid + 1, pos = l;
        while (i <= mid && j <= r) {
            if (record[i] <= record[j]) {
                tmp[pos] = record[i];
                ++i;
                inv_count += (j - (mid + 1));
            }
            else {
                tmp[pos] = record[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {
            tmp[pos++] = record[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {
            tmp[pos++] = record[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, record.begin() + l);
        return inv_count;
    }

    int reversePairs(vector<int>& record) {
        int n = record.size();
        vector<int> tmp(n);
        return mergeSort(record, tmp, 0, n - 1);
    }
};
```

</details>

# 4 UNSOLVED 寻找两个正序数组的中位数
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和
nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
 public:
  int getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {
    int m = nums1.size(), n = nums2.size();
    int index1 = 0, index2 = 0;
    while (true) {
      if (index1 == m) return nums2[index2 + k - 1];
      if (index2 == n) return nums1[index1 + k - 1];
      if (k == 1) return std::min(nums1[index1], nums2[index2]);
      int newindex1 = std::min(index1 + k / 2 - 1, m - 1);
      int newindex2 = std::min(index2 + k / 2 - 1, n - 1);
      int pivot1 = nums1.at(newindex1);
      int pivot2 = nums2.at(newindex2);
      if (pivot2 >= pivot1) {
        k -= newindex1 - index1 + 1;
        index1 = newindex1 + 1;
      } else {
        k -= newindex2 - index2 + 1;
        index2 = newindex2 + 1;
      }
    }
  }
  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int totallen = nums1.size() + nums2.size();
    if (totallen % 2 == 1)
      return getKthElement(nums1, nums2, (totallen + 1) / 2);
    else
      return getKthElement(nums1, nums2, totallen / 2) / 2.0 +
             getKthElement(nums1, nums2, totallen / 2 + 1) / 2.0;
  }
};
```

二分搜索版本

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n=nums1.size();
        int m=nums2.size();
        int index1=0,index2=0;
        int left=-1,right=-1;
        int len=n+m;
        for(int i=0;i<=len/2;i++){
            left=right;
            if(index1<n && (index2>=m||nums1[index1]<nums2[index2])){
                right=nums1[index1++];
            }else{
                right=nums2[index2++];
            }
        }
        if(len & 1){
            return right;
        }else{
            return (left+right)/2.0;
        }
    }
};
```

</details>

# 268 丢失的数字

给定一个包含 \[0, n\] 中 n 个数的数组 nums ，找出 \[0, n\]
这个范围内没有出现在数组中的那个数。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        ranges::sort(nums);
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(mid<nums[mid]){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
};
```

</details>

# 162 寻找峰值
峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组
nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回
任何一个峰值 所在位置即可。

你可以假设 nums\[-1\] = nums\[n\] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left=0,right=nums.size()-1;
        while(left+1<right){
            int mid=(left+right)/2;
            if(nums[mid-1]<nums[mid]){
                left=mid;
            }else{
                right=mid;
            }
        }
        return nums[left]>nums[right]?left:right;
    }
};
```

</details>

# 436 寻找右区间

给你一个区间数组 intervals ，其中 intervals\[i\] = \[starti, endi\]
，且每个 starti 都 不同 。

区间 i 的 右侧区间 可以记作区间 j ，并满足 startj \>= endi ，且 startj
最小化 。注意 i 可能等于 j 。

返回一个由每个区间 i 的 右侧区间 在 intervals
中对应下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i
处的值设为 -1 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
 public:
  vector<int> findRightInterval(vector<vector<int>>& intervals) {
    vector<pair<int, int>> startIntervals;
    int n = intervals.size();
    for (int i = 0; i < n; i++) {
      startIntervals.push_back({intervals[i][0], i});
    }
    std::sort(startIntervals.begin(), startIntervals.end());
    vector<int> ans(n, -1);
    for (int i = 0; i < n; i++) {
      auto it = std::lower_bound(startIntervals.begin(), startIntervals.end(),
                                 std::make_pair(intervals[i][1], 0));
      if (it != startIntervals.end()) {
        ans[i] = it->second;
      }
    }
    return ans;
  }
};
```

</details>

# 403 青蛙过河
一只青蛙想要过河。
假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。
青蛙可以跳上石子，但是不可以跳入水中。

给你石子的位置列表 stones（用单元格序号 升序 表示），
请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时，
青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1
个单位（即只能从单元格 1 跳至单元格 2 ）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k
或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

<details>

思路及算法

最直接的想法是使用深度优先搜索的方式尝试所有跳跃方案，直到我们找到一组可行解为止。但是不加优化的该算法的时间复杂度在最坏情况下是指数级的，因此考虑优化。

注意到当青蛙每次能够跳跃的距离仅取决于青蛙的「上一次跳跃距离」。而青蛙此后能否到达终点，只和它「现在所处的石子编号」以及「上一次跳跃距离」有关。因此我们可以将这两个维度综合记录为一个状态。使用记忆化搜索的方式优化时间复杂度。

具体地，当青蛙位于第 i 个石子，上次跳跃距离为 lastDis
时，它当前能够跳跃的距离范围为
\[lastDis−1,lastDis+1\]。我们需要分别判断这三个距离对应的三个位置是否存在石子。注意到给定的石子列表为升序，所以我们可以利用二分查找来优化查找石子的时间复杂度。每次我们找到了符合要求的位置，我们就尝试进行一次递归搜索即可。

为了优化编码，我们可以认为青蛙的初始状态为：「现在所处的石子编号」为
0（石子从 0 开始编号），「上一次跳跃距离」为
0（这样可以保证青蛙的第一次跳跃距离为 1）。

```cpp
class Solution {
public:
    vector<unordered_map<int,int>> rec;
    bool dfs(vector<int>& stones,int i,int lastDis){
        if(i==stones.size()-1){
            return true;
        }
        if(rec[i].count(lastDis)){
            return rec[i][lastDis];
        }
        for(int curDis=lastDis-1;curDis<=lastDis+1;curDis++){
            if(curDis>0){
                int j=lower_bound(stones.begin(),stones.end(),curDis+stones[i])-stones.begin();
                if(j!=stones.size()&&stones[j]==curDis+stones[i]&&dfs(stones,j,curDis)){
                    return rec[i][lastDis]=true;
                }
            }
        }
        return rec[i][lastDis]=false;
    }
    bool canCross(vector<int>& stones) {
        int n=stones.size();
        rec.resize(n);
        return dfs(stones,0,0);
    }
};
```

</details>

# 378 有序矩阵中第 K 小的元素

给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

你必须找到一个内存复杂度优于 O(n2) 的解决方案。

<details>

```cpp
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int left=matrix[0][0];
        int right=matrix.back().back();
        int row=matrix.size();
        int col=matrix[0].size();
        while(left<right){
            int mid=left+(right-left)/2;
            int count=noBiggerThanMid(matrix, mid, row,col);
            if(count<k){
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return right;
    }
    int noBiggerThanMid(vector<vector<int>> &mat,int mid,int row,int col){
        int i=row-1;
        int j=0;
        int count=0;
        while(i>=0&&j<col){
            if(mat[i][j]<=mid){
                count+=i+1;
                j++;
            }else{
                i--;
            }
        }
        return count;
    }
};
```

</details>

# 74 搜索二维矩阵

给你一个满足下述两条属性的 m x n 整数矩阵：

    每行中的整数从左到右按非严格递增顺序排列。
    每行的第一个整数大于前一行的最后一个整数。

给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。

<details>

```rust
impl Solution {
    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {
        let mut n=matrix.len();
        let mut m=matrix[0].len();
        let mut low=0;
        let mut high=n*m;
        while low<high{
            let mid:usize=(high-low)/2+low;
            let x=matrix[mid/m][mid%m];
            if x==target{
                return true;
            }
            if x>target{
                high=mid;
            }else{
                low=mid+1;
            }
        }
        return false;
    }
}
```

</details>

# 1060 有序数组中的缺失元素

现有一个按 升序 排列的整数数组 nums ，其中每个数字都 互不相同 。

给你一个整数 k ，请你找出并返回从数组最左边开始的第 k 个缺失数字。

<details>

```cpp
class Solution {
    //到nums[idx]之间有多少个缺失的数
    int missing(int idx,vector<int>& nums){
        return nums[idx]-nums[0]-idx;
    }
public:
    int missingElement(vector<int>& nums, int k) {
        int n=nums.size();
        if(k>missing(n-1, nums)){
            return nums[n-1]+k-missing(n-1, nums);
        }
        int idx=1;
        while(missing(idx, nums)<k) idx++;
        return nums[idx-1]+k-missing(idx-1, nums);
    }
};
```

注意到，missing 对于 idx 来说是单调不减的，所以：

```cpp
class Solution {
    //到nums[idx]之间有多少个缺失的数
    int missing(int idx,vector<int>& nums){
        return nums[idx]-nums[0]-idx;
    }
public:
    int missingElement(vector<int>& nums, int k) {
        int n=nums.size();
        if(k>missing(n-1, nums)){
            return nums[n-1]+k-missing(n-1, nums);
        }
        int left=0,right=n-1;
        int pivot;
        while(left!=right){
            pivot=(left+right)/2;
            if(missing(pivot, nums)<k) left=pivot+1;
            else right=pivot;
        }
        return nums[left-1]+k-missing(left-1,nums);
    }
};
```

</details>

# 1760 袋里最少数目的球

给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。

你可以进行如下操作至多 maxOperations 次：

    选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
        比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。

你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。

请你返回进行上述操作后的最小开销。

<details>

```cpp
class Solution {
public:
    int minimumSize(vector<int>& nums, int maxOperations) {
        int left=1,right=ranges::max(nums);
        int ans=0;
        while(left<right){
            int y=(left+right)/2;
            long long ops=0;
            for(int x:nums){
                ops+=(x-1)/y;
            }
            if(ops<=maxOperations){
                ans=y;
                right=y-1;
            }else{
                left=y+1;
            }
        }
        return ans;
    }
};
```

</details>

# 1287 有序数组中超过1/4的元素

给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。

请你找到并返回这个整数

<details>

```cpp
class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        int n=arr.size();
        int span=n/4+1;
        for(int i=0;i<n;i+=span){
            auto iter_l=lower_bound(arr.begin(),arr.end(),arr[i]);
            auto iter_r=upper_bound(arr.begin(),arr.end(),arr[i]);
            if(iter_r-iter_l>=span){
                return arr[i];
            }
        }
        return -1;
    }
};
```

</details>

# 2080 区间查询数字的频率

请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。

子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。

请你实现 RangeFreqQuery 类：

    RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。
    int query(int left, int right, int value) 返回子数组 arr[left...right] 中 value 的 频率 。

一个 子数组 指的是数组中一段连续的元素。arr[left...right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。

<details>

```cpp
class RangeFreqQuery {
    unordered_map<int,vector<int>> pos;
public:
    RangeFreqQuery(vector<int>& arr) {
        for(int i=0;i<arr.size();i++){
            pos[arr[i]].push_back(i);
        }
    }

    int query(int left, int right, int value) {
        auto it=pos.find(value);
        if(it==pos.end()){
            return 0;
        }
        auto &a=it->second;
        return ranges::upper_bound(a,right)-ranges::lower_bound(a,left);
    }
};
 ```

</details>

# 29 两数相除

给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。

返回被除数 dividend 除以除数 divisor 得到的 商 。

注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。

<details>

```cpp
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend==INT_MIN){
            if(divisor==1){
                return INT_MIN;
            }
            if(divisor==-1){
                return INT_MAX;
            }
        }
        if(divisor==INT_MIN){
            return dividend==INT_MIN?1:0;
        }
        if(dividend==0){
            return 0;
        }
        bool rev=false;
        if(dividend>0){
            dividend=-dividend;
            rev=!rev;
        }
        if(divisor>0){
            divisor=-divisor;
            rev=!rev;
        }
                // 快速乘
        auto quickAdd = [](int y, int z, int x) {
            // x 和 y 是负数，z 是正数
            // 需要判断 z * y >= x 是否成立
            int result = 0, add = y;
            while (z) {
                if (z & 1) {
                    // 需要保证 result + add >= x
                    if (result < x - add) {
                        return false;
                    }
                    result += add;
                }
                if (z != 1) {
                    // 需要保证 add + add >= x
                    if (add < x - add) {
                        return false;
                    }
                    add += add;
                }
                // 不能使用除法
                z >>= 1;
            }
            return true;
        };
        int left = 1, right = INT_MAX, ans = 0;
        while(left<=right){
            int mid=(right-left)/2+left;
            bool check=quickAdd(divisor, mid, dividend);
            if(check){
                ans=mid;
                if(mid==INT_MAX){
                    break;
                }
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return rev?-ans:ans;
    }
};
```

</details>

# 81 搜索旋转排序数组Ⅱ

已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。

给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。

你必须尽可能减少整个操作步骤。

<details>

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int n=nums.size();
        if(n==0){
            return false;
        }
        if(n==1){
            return nums[0]==target;
        }
        int left=0,right=n-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(nums[mid]==target){
                return true;
            }
            if(nums[left]==nums[mid]&&nums[mid]==nums[right]){
                left++,right--;
            }else if(nums[left]<=nums[mid]){
                if(nums[left]<=target && target<=nums[mid]){
                    right=mid-1;
                }else{
                    left=mid+1;
                }
            }else{
                if(nums[mid]<target && target<=nums.back()){
                    left=mid+1;
                }else{
                    right=mid-1;
                }
            }
        }
        return false;
    }
};
```

</details>

# UNSOLVED 923 漂亮数组

如果长度为 n 的数组 nums 满足下述条件，则认为该数组是一个 漂亮数组 ：

    nums 是由范围 [1, n] 的整数组成的一个排列。
    对于每个 0 <= i < j < n ，均不存在下标 k（i < k < j）使得 2 * nums[k] == nums[i] + nums[j] 。

给你整数 n ，返回长度为 n 的任一 漂亮数组 。本题保证对于给定的 n 至少存在一个有效答案。

<details>

对于一个正整数 N, 我们将其等分为两部分，left 和 right， 如果 left 部分是漂亮数组，right 部分也是漂亮数组， 同时 left 部分全部是奇数，right 部分全部是偶数，那么此时 left+right 组成的数组一定也是一个漂亮数组。

    所以可以采用分治算法，自顶向下

    先将数组分为两部分，将奇数放在 left，偶数放在 right

    同时保证 left 和 right 都是漂亮数组

    递归...

如果我现在知道了整数 N 的 漂亮数组，那么通过 k∗N+b 的变换可以让 N 变成 2N 的奇部（前半部分 left ), 同样通过 k∗N+b 的变换可以让 N 变成 2N 的偶部（后半部分 right )，只不过 k 和 b 可能取不同的值而已

    N=1 时，漂亮数组为 [1]

    N=2 时，通过 N=1 变换。 1∗2−1=1,1∗2=2, 所以漂亮数组为 [1,2]

    N=3 时，通过 N=2 和 N=1 变换得到。 N=2 变换得奇部 2∗1−1=1,2∗2−1=3; N=1 变换得到偶部分 2∗1=2。最后漂亮数组为 [1,3,2]。始终保证奇部在前，偶部在后。

    ......

    所以最后相当于是做了一个二分操作，始终寻找中点，然后将两边分治成漂亮数组。

```cpp
class Solution {
    unordered_map<int,vector<int>> cache;
public:
    vector<int> beautifulArray(int n) {
        return dfs(n);
    }
    vector<int> dfs(int N){
        vector<int> ans(N,0);
        int t=0;
        if(cache.find(N)!=cache.end()){
            return cache[N];
        }
        if(N!=1){
            // 左半部分
            for(auto x: dfs((N+1)/2)){
                ans[t++]=2*x-1;
            }
            // 右半部分
            for(auto x: dfs(N/2)){
                ans[t++]=2*x;
            }
        }else{
            ans[0]=1;
        }
        cache[N]=ans;
        return ans;
    }
};
```

</details>

# 给定一个非空升序数列 S，请你实现一个函数，找到其中绝对值最小的数字。

二分法的应用：由于数列是升序的，我们可以通过二分法来找到数列中第一个大于等于 0 的元素的位置。这个位置可能是绝对值最小的元素，或者它前面的元素是绝对值最小的元素。

边界条件：如果数列中所有元素都小于 0，那么绝对值最小的元素就是最后一个元素。如果所有元素都大于等于 0，那么绝对值最小的元素就是第一个元素。

比较：在二分法找到的位置附近，比较该位置的元素和它前面一个元素的绝对值，取较小的那个。

<details>

```cpp
#include <vector>
#include <cmath>
int AbsMin(const std::vector<int> &s) {
    int left = 0;
    int right = s.size() - 1;
    // 如果所有元素都小于0，返回最后一个元素
    if (s[right] < 0) {
        return s[right];
    }
    // 如果所有元素都大于等于0，返回第一个元素
    if (s[left] >= 0) {
        return s[left];
    }
    // 二分查找第一个大于等于0的元素
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (s[mid] < 0) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    // 比较找到的元素和它前面的元素，取绝对值较小的
    if (left < s.size() && (right >= 0)) {
        if (std::abs(s[left]) < std::abs(s[right])) {
            return s[left];
        } else {
            return s[right];
        }
    } else if (left < s.size()) {
        return s[left];
    } else {
        return s[right];
    }
}
int main() {
    std::vector<int> S = {-15, -2, 1, 3, 7};
    int result = AbsMin(S);
    // 输出结果
    return 0;
}
```

</details>

# 1283 使结果不超过阈值的最小除数

给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。

请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。

题目保证一定有解。

<details>

```cpp
class Solution {
public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        auto check=[&](int m)->bool{
            int sum=0;
            for(int x:nums){
                sum+=(x+m-1)/m;
                if(sum>threshold){
                    return false;
                }
            }
            return true;
        };
        int left=0,right=ranges::max(nums);
        while(left+1<right){
            int mid=left+(right-left)/2;
            (check(mid)?right:left)=mid;
        }
        return right;
    }
};
```

</details>

# 1870 准时到达的列车最小时速

给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。

每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。

    例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。

返回能满足你在时限前到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。

生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。

<details>

```cpp
class Solution {
public:
    int minSpeedOnTime(vector<int>& dist, double hour) {
        int n=dist.size();
        long long hr=llround(hour * 100);
        // 时间必须要大于路程段数-1
        if(hr<=(n-1)*100){
            return -1;
        }
        int l=1,r=1e7;
        while(l<r){
            int mid=l+(r-l)/2;
            //判断当前时速是否满足时间限制
            long long t=0;
            //前n-1段时间中第i段贡献的时间
            for(int i=0;i<n-1;i++){
                t+=(dist[i]-1)/mid+1;
            }
            //最后一段贡献的时间：dist[n-1]/mid
            t*=mid;
            t+=dist[n-1];
            if(t*100<=hr*mid){
                r=mid;
            }else{
                l=mid+1;
            }
        }
        return l;
    }
};
```

</details>

# 410 分割数组的最大值

给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组，使得这 k 个子数组各自和的最大值 最小。

返回分割后最小的和的最大值。

子数组 是数组中连续的部份。

<details>

看到「最大化最小值」或者「最小化最大值」就要想到二分答案，这是一个固定的套路。

为什么？「元素和的最大值」越小，需要划分出的段数就越多，反之越少。例如示例 1 的 nums=[7,2,5,10,8]，在最大和为 15 时，至少要划分 3 段，比如 [7,2,5],[10],[8]。而在最大和为 18 时，只需要划分 2 段，比如 [7,2,5],[10,8]。

一般地，二分的值越小，越不能/能满足要求；二分的值越大，越能/不能满足要求。有单调性的保证，就可以二分答案了。

把二分中点 mid 记作 mx，我们可以贪心地计算要划分出的段数：

    初始化 cnt=1,s=0。
    遍历 nums。
    如果 s+nums[i]≤mx，则把 nums[i] 加到 s 中。否则我们必须新划分出一段，把 cnt 加一，s 替换成 nums[i]。如果在 cnt 加一之前有 cnt=k，则说明我们划分了超过 k 段，返回 false。
    遍历结束，返回 true。

最后，如何确定二分的左右边界（开区间）？

设 nums 的元素和为 S。

    右边界可以设为 S，必定满足要求。
    左边界可以设为 max(nums)−1，必定不满足要求。更好的写法是考虑平均值 kS​，如果每一段的元素和都小于平均值，我们是不可能分出 k 段的。

```cpp
class Solution {
    bool check(vector<int>& nums,int mid,int k){
        int cnt=1;
        long long sum=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]+sum>mid){
                cnt++;
                sum=nums[i];
            }else{
                sum+=nums[i];
            }
        }
        return cnt<=k;
    }
public:
    int splitArray(vector<int>& nums, int k) {
        long long left=0,right=0;
        for(int n:nums){
            right+=n;
            if(left<n){
                left=n;
            }
        }
        while(left<right){
            long long mid=(left+right)>>1;
            if(check(nums,mid,k)){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
};
```

</details>

# UNSOLVED 1231 分享巧克力

你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组 sweetness 来表示每一小块的甜度。

你打算和 K 名朋友一起分享这块巧克力，所以你需要将切割 K 次才能得到 K+1 块，每一块都由一些 连续 的小块组成。

为了表现出你的慷慨，你将会吃掉 总甜度最小 的一块，并将其余几块分给你的朋友们。

请找出一个最佳的切割策略，使得你所分得的巧克力 总甜度最大，并返回这个 最大总甜度。

<details>

```cpp
class Solution {
public:
    int maximizeSweetness(vector<int>& sweetness, int k) {
        int num=k+1;
        int left=ranges::min(sweetness);
        int right=accumulate(sweetness.begin(),sweetness.end(),0)/num;
        while(left<right){
            int mid=(left+right+1)/2;
            int curSweetness=0;
            int peopleWithChocolate=0;
            for(int s:sweetness){
                curSweetness+=s;
                if(curSweetness>=mid){
                    peopleWithChocolate+=1;
                    curSweetness=0;
                }
            }
            if(peopleWithChocolate>=num){
                left=mid;
            }else{
                right=mid-1;
            }
        }
        return right;
    }
};
```

</details>

# UNSOLVED 1631 最小体力消耗路径

你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights\[row\]\[col\] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。

一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。

请你返回从左上角走到右下角的最小 体力消耗值 。

<details>

二分搜索

我们可以将这个问题转化成一个「判定性」问题，即：

    是否存在一条从左上角到右下角的路径，其经过的所有边权的最大值不超过 x？

这个判定性问题解决起来并不复杂，我们只要从左上角开始进行深度优先搜索或者广度优先搜索，在搜索的过程中只允许经过边权不超过 x 的边，搜索结束后判断是否能到达右下角即可。

随着 x 的增大，原先可以经过的边仍然会被保留，因此如果当 x=x0​ 时，我们可以从左上角到达右下角，那么当 x>x0​ 时同样也可以可行的。因此我们可以使用二分查找的方法，找出满足要求的最小的那个 x 值，记为 xans​，那么：

    当 x<xans​，我们无法从左上角到达右下角；

    当 x≥xans​，我们可以从左上角到达右下角。

由于格子的高度范围为 [1,106]，因此我们可以 [0,106−1] 的范围内对 x 进行二分查找。在每一步查找的过程中，我们使用进行深度优先搜索或者广度优先搜索判断是否可以从左上角到达右下角，并根据判定结果更新二分查找的左边界或右边界即可。

```cpp
class Solution {
    constexpr static int dxy[4][2]={{-1,0},{1,0},{0,1},{0,-1}};
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m=heights.size();
        int n=heights[0].size();
        int left=0,right=999999,ans=0;
        while(left<=right){
            int mid=(left+right)/2;
            queue<pair<int,int>> q;
            q.emplace(0,0);
            vector<int> seen(m*n);
            seen[0]=1;
            while(!q.empty()){
                auto [x,y]=q.front();
                q.pop();
                for(int i=0;i<4;i++){
                    int nx=x+dxy[i][0];
                    int ny=y+dxy[i][1];
                    if(nx>=0 && nx<m && ny>=0 && ny<n && !seen[nx*n+ny]
                    &&abs(heights[x][y]-heights[nx][ny])<=mid){
                        q.emplace(nx,ny);
                        seen[nx*n+ny]=1;
                    }
                }
            }
            if(seen[m*n-1]){
                ans=mid;
                right=mid-1;
            }else{
                left=mid+1;
            }
        }
        return ans;
    }
};
```

并查集

我们将这 mn 个节点放入并查集中，实时维护它们的连通性。

由于我们需要找到从左上角到右下角的最短路径，因此我们可以将图中的所有边按照权值从小到大进行排序，并依次加入并查集中。当我们加入一条权值为 x 的边之后，如果左上角和右下角从非连通状态变为连通状态，那么 x 即为答案。

```cpp
class UnionFind{
    vector<int> parent;
    vector<int> size;
    int n;
    // 连通分量数目
    int setCount;
    public:
    UnionFind(int _n):n(_n),parent(_n),size(_n,1){
        iota(parent.begin(),parent.end(),0);
    }
    int findSet(int x){
        return parent[x]==x?x:parent[x]=findSet(parent[x]);
    }
    bool unite(int x,int y){
        x=findSet(x);
        y=findSet(y);
        if(x==y){
            return false;
        }
        if(size[x]<size[y]){
            swap(x,y);
        }
        parent[y]=x;
        size[x]+=size[y];
        --setCount;
        return true;
    }
    bool connected(int x,int y){
        x=findSet(x);
        y=findSet(y);
        return x==y;
    }
};
class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m=heights.size();
        int n=heights[0].size();
        vector<tuple<int,int,int>> edges;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                int id=i*n+j;
                if(i>0){
                    edges.emplace_back(id-n,id,abs(heights[i][j]-heights[i-1][j]));
                }
                if(j>0){
                    edges.emplace_back(id-1,id,abs(heights[i][j]-heights[i][j-1]));
                }
            }
        }
        sort(edges.begin(),edges.end(),[](const auto& e1,const auto& e2){
            auto&& [x1,y1,v1]=e1;
            auto&& [x2,y2,v2]=e2;
            return v1<v2;
        });
        UnionFind uf(m*n);
        int ans=0;
        for(auto [x,y,v]:edges){
            uf.unite(x,y);
            if(uf.connected(0,m*n-1)){
                ans=v;
                break;
            }
        }
        return ans;
    }
};
```

</details>

# 1802 有界数组中指定下标处的最大值

给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：

    nums.length == n
    nums[i] 是 正整数 ，其中 0 <= i < n
    abs(nums[i] - nums[i+1]) <= 1 ，其中 0 <= i < n-1
    nums 中所有元素之和不超过 maxSum
    nums[index] 的值被 最大化

返回你所构造的数组中的 nums[index] 。

注意：abs(x) 等于 x 的前提是 x >= 0 ；否则，abs(x) 等于 -x 。

<details>

```cpp
class Solution {
    bool valid(int mid,int n,int index,int maxSum){
            int left=index;
            int right=n-index-1;
            return mid+cal(mid,left)+cal(mid,right)<=maxSum;
    }
    long cal(int big,int length){
        if(length+1<big){
            int small=big-length;
            return (long)(big-1+small)*length/2;
        }else{
            int ones=length-(big-1);
            return (long)big*(big-1)/2+ones;
        }
    }
public:
    int maxValue(int n, int index, int maxSum) {
        int left=1,right=maxSum;
        while(left<right){
            int mid=(left+right+1)/2;
            if(valid(mid,n,index,maxSum)){
                left=mid;
            }else{
                right=mid-1;
            }
        }
        return left;
    }
};
```

有一个总结：

![模板](https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/solutions/2043854/by-lao-song-2f-n5b6)

</details>

# UNSOLVED 1235 规划兼职工作

你打算利用空闲时间来做兼职工作赚些零花钱。

这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。

给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。

注意，时间上出现重叠的 2 份工作不能同时进行。

如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。

<details>

```cpp
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n=startTime.size();
        vector<array<int,3>> jobs(n);
        for(int i=0;i<n;i++){
            jobs[i]={endTime[i],startTime[i],profit[i]};
        }
        ranges::sort(jobs,[](auto& a,auto& b){
            return a[0]<b[0];
        });
        vector<int> f(n+1);
        for(int i=0;i<n;i++){
            int j=upper_bound(jobs.begin(),jobs.begin()+i,array<int,3>{jobs[i][1],INT_MAX})-jobs.begin();
            f[i+1]=max(f[i],f[j]+jobs[i][2]);
        }
        return f[n];
    }
};
```

</details>

# 887 鸡蛋掉落

给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

<details>

```cpp
class Solution {
    vector<vector<int>> memo{{}};
    int dfs(int i,int j){
        if(i==0||j==0){
            return 0;
        }
        int &res=memo[i][j];
        if(res!=0){
            return res;
        }
        return res=dfs(i-1,j)+dfs(i-1,j-1)+1;
    }
public:
    int superEggDrop(int k, int n) {
        for(int i=1;;i++){
            memo.emplace_back(k+1);
            if(dfs(i,k)>=n){
                return i;
            }
        }
    }
};
```

</details>

# 287 寻找重复数

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

<details>

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n = nums.size();
        int l = 1, r = n - 1, ans = -1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            int cnt = 0;
            for (int i = 0; i < n; ++i) {
                cnt += nums[i] <= mid;
            }
            if (cnt <= mid) {
                l = mid + 1;
            } else {
                r = mid - 1;
                ans = mid;
            }
        }
        return ans;
    }
};
```

</details>

# UNSOLVED 2528 最大化城市的最小电量

给你一个下标从 0 开始长度为 n 的整数数组 stations ，其中 stations[i] 表示第 i 座城市的供电站数目。

每个供电站可以在一定 范围 内给所有城市提供电力。换句话说，如果给定的范围是 r ，在城市 i 处的供电站可以给所有满足 |i - j| <= r 且 0 <= i, j <= n - 1 的城市 j 供电。

|x| 表示 x 的 绝对值 。比方说，|7 - 5| = 2 ，|3 - 10| = 7 。
一座城市的 电量 是所有能给它供电的供电站数目。

政府批准了可以额外建造 k 座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。

给你两个整数 r 和 k ，如果以最优策略建造额外的发电站，返回所有城市中，最小电量的最大值是多少。

这 k 座供电站可以建在多个城市。

<details>

这道题目里面用到差分数组的知识，可以用差分数组来记录变化量。

```c++
class Solution {
public:
    long long maxPower(vector<int>& stations, int r, int k) {
        int n=stations.size();
        vector<long long> prefix_sum(n+1),power(n),diff(n);
        for(int i=0;i<n;i++){
            prefix_sum[i+1]=prefix_sum[i]+stations[i];
        }
        for(int i=0;i<n;i++){
            power[i]=prefix_sum[min(i+r+1,n)]-prefix_sum[max(i-r,0)];
        }
        auto check=[&](long long min_power)->bool{
            ranges::fill(diff,0);
            long long diff_sum=0,need=0;
            for(int i=0;i<n;i++){
                diff_sum+=diff[i];
                long long m=min_power-power[i]-diff_sum;
                if(m>0){// 需要m个供电站
                    need+=m;
                    if(need>k){
                        return false;
                    }
                    diff_sum+=m;// 更新差分
                    if(i+r*2+1<n){
                        diff[i+r*2+1]-=m;
                    }
                }
            }
            return true;
        };
        long long left=ranges::min(power);
        long long right=left+k+1;
        while(left+1<right){
            long long mid=left+(right-left)/2;
            (check(mid)?left:right)=mid;
        }
        return left;
    }
};
```

</details>
