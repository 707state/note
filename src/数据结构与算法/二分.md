
# 2187 完成旅途的最少时间

给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。

每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。

给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。

```c++
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        auto check=[&](long long x)->bool{
            long long sum=0;
            for(auto& t: time){
                sum+=x/t;
                if(sum>=totalTrips){
                    return true;
                }
            }
            return false;
        };
        long long min_t=ranges::min(time);
        long long left=min_t-1;//循环不变量
        long long right=totalTrips*min_t;
        while(left+1<right){
            auto mid=(right+left)/2;
            (check(mid)?right:left)=mid;
        }
        return right;
    }
};
```

# 2529 正整数和负整数的最大计数

给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。


换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回 pos 和 neg二者中的最大值。

注意：0 既不是正整数也不是负整数。

```c++ 
class Solution {
public:
    int maximumCount(vector<int>& nums) {
     int neg=0,pos=0;
     int left=0,right=nums.size()-1;
     auto lowerBound=[&](vector<int>& num,int val)->int{
        int l=0,r=num.size();
        while(l<r){
            int m=(r+l)/2;
            if(nums[m]>=val){
                r=m;
            }else if(nums[m]<val){
                l=m+1;
            }
        }
        return l;
     };
     left=lowerBound(nums,0);
     right=lowerBound(nums,1);
     return max(left,(int)nums.size()-right);
    }
};
```

# 2563 统计公平数对的数目

给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。

如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：


0 <= i < j < n，且

lower <= nums[i] + nums[j] <= upper


```c++
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        long long ans=0;
        ranges::sort(nums);
        for(int i=0;i<nums.size();++i){
            auto l=lower_bound(nums.begin(),nums.begin()+i,lower-nums[i]);
            auto r=upper_bound(nums.begin(),nums.begin()+i,upper-nums[i]);
            ans+=r-l;
        }
        return ans;
    }
};
```

# 2576 求出最多标记下标

给你一个下标从 0 开始的整数数组 nums 。

一开始，所有下标都没有被标记。你可以执行以下操作任意次：

    选择两个 互不相同且未标记 的下标 i 和 j ，满足 2 * nums[i] <= nums[j] ，标记下标 i 和 j 。

请你执行上述操作任意次，返回 nums 中最多可以标记的下标数目。
```c++
class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
      ranges::sort(nums);
      int n=nums.size();
      int l=0,r=n/2;
      auto check=[&](int m){
        for(int i=0;i<m;i++){
            if(nums[i]*2>nums[n-m+i]){
                return false;
            }
        }
        return true;
      };
      while(l<r){
        int m=r+l+1>>1;
        if(check(m)){
            l=m;
        }else{
            r=m-1;
        }
      }
      return l*2;
    }
};
```

# 正方形的最多点数

给你一个二维数组 points 和一个字符串 s ，其中 points[i] 表示第 i 个点的坐标，s[i] 表示第 i 个点的 标签 。

如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不 存在标签相同的两个点，那么我们称这个正方形是 合法 的。

请你返回 合法 正方形中可以包含的 最多 点数。

注意：


如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。

正方形的边长可以为零。


```c++
class Solution {
public:
    int maxPointsInsideSquare(vector<vector<int>>& points, string s) {
        int ans=0;
        auto check=[&](int size)->bool{
            int vis=0;
            for(int i=0;i<points.size();i++){
                if(abs(points[i][0])<=size && abs(points[i][1])<=size){
                    auto c=s[i]-'a';
                    if(vis>>c&1){//c在集合中
                        return false;
                    }
                    vis|=1<<c;
                }
            }
            ans=__builtin_popcount(vis);
            return true;
        };
        int left=-1,right=1'000'000'001;
        while(left+1<right){
            int mid=(left+right)/2;
            (check(mid)?left:right)=mid;
        }
        return ans;
    }
};
```

这个解法使用了位运算

# 33 搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(right-left)/2+left;
            if(nums[mid]==target) return mid;
            if(nums[0]<=nums[mid]){
                if(nums[0]<=target&&target<nums[mid]) right=mid-1;
                else left=mid+1;
            }else{
                if(nums[mid]<target&&target<=nums.back()) left=mid+1;
                else right=mid-1;
            }
        }
        return -1;
    }
};
```

# 852 山脉数组的峰顶索引

给定一个长度为 n 的整数 山脉 数组 arr ，其中的值递增到一个 峰值元素 然后递减。

返回峰值元素的下标。

你必须设计并实现时间复杂度为 O(log(n)) 的解决方案。

记满足题目要求的下标 i 为 ians。我们可以发现：

    当 i<ians 时，arri<arri+1 恒成立；

    当 i≥ians 时，arri>arri+1 恒成立。

因此 ians 即为「最小的满足 arri>arri+1 的下标 i，我们可以用二分查找的方法来找出 ians。

```c++ 
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int left = 1, right = arr.size() - 2, ans = 0;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (arr[mid] > arr[mid + 1]) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
};
```

# LCR 170 交易逆序对的总数

在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 record，返回其中存在的「交易逆序对」总数。

思路： 归并排序

```c++ 
class Solution {
public:
    int mergeSort(vector<int>& record, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }

        int mid = (l + r) / 2;
        int inv_count = mergeSort(record, tmp, l, mid) + mergeSort(record, tmp, mid + 1, r);
        int i = l, j = mid + 1, pos = l;
        while (i <= mid && j <= r) {
            if (record[i] <= record[j]) {
                tmp[pos] = record[i];
                ++i;
                inv_count += (j - (mid + 1));
            }
            else {
                tmp[pos] = record[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {
            tmp[pos++] = record[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {
            tmp[pos++] = record[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, record.begin() + l);
        return inv_count;
    }

    int reversePairs(vector<int>& record) {
        int n = record.size();
        vector<int> tmp(n);
        return mergeSort(record, tmp, 0, n - 1);
    }
};
```
