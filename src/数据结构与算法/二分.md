# 153 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：

    若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
    若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        if(right==0) return nums.front();
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]<nums[right]){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return nums[left];
    }
};
```

# 2187 完成旅途的最少时间

给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。

每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。

给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。

```cpp
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        auto check=[&](long long x)->bool{
            long long sum=0;
            for(auto& t: time){
                sum+=x/t;
                if(sum>=totalTrips){
                    return true;
                }
            }
            return false;
        };
        long long min_t=ranges::min(time);
        long long left=min_t-1;//循环不变量
        long long right=totalTrips*min_t;
        while(left+1<right){
            auto mid=(right+left)/2;
            (check(mid)?right:left)=mid;
        }
        return right;
    }
};
```

# 2529 正整数和负整数的最大计数

给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。


换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回 pos 和 neg二者中的最大值。

注意：0 既不是正整数也不是负整数。

```cpp 
class Solution {
public:
    int maximumCount(vector<int>& nums) {
     int neg=0,pos=0;
     int left=0,right=nums.size()-1;
     auto lowerBound=[&](vector<int>& num,int val)->int{
        int l=0,r=num.size();
        while(l<r){
            int m=(r+l)/2;
            if(nums[m]>=val){
                r=m;
            }else if(nums[m]<val){
                l=m+1;
            }
        }
        return l;
     };
     left=lowerBound(nums,0);
     right=lowerBound(nums,1);
     return max(left,(int)nums.size()-right);
    }
};
```

# 2563 统计公平数对的数目

给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。

如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：


0 <= i < j < n，且

lower <= nums[i] + nums[j] <= upper


```cpp
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        long long ans=0;
        ranges::sort(nums);
        for(int i=0;i<nums.size();++i){
            auto l=lower_bound(nums.begin(),nums.begin()+i,lower-nums[i]);
            auto r=upper_bound(nums.begin(),nums.begin()+i,upper-nums[i]);
            ans+=r-l;
        }
        return ans;
    }
};
```

# 2576 求出最多标记下标

给你一个下标从 0 开始的整数数组 nums 。

一开始，所有下标都没有被标记。你可以执行以下操作任意次：

    选择两个 互不相同且未标记 的下标 i 和 j ，满足 2 * nums[i] <= nums[j] ，标记下标 i 和 j 。

请你执行上述操作任意次，返回 nums 中最多可以标记的下标数目。
```cpp
class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
      ranges::sort(nums);
      int n=nums.size();
      int l=0,r=n/2;
      auto check=[&](int m){
        for(int i=0;i<m;i++){
            if(nums[i]*2>nums[n-m+i]){
                return false;
            }
        }
        return true;
      };
      while(l<r){
        int m=r+l+1>>1;
        if(check(m)){
            l=m;
        }else{
            r=m-1;
        }
      }
      return l*2;
    }
};
```

# 正方形的最多点数

给你一个二维数组 points 和一个字符串 s ，其中 points[i] 表示第 i 个点的坐标，s[i] 表示第 i 个点的 标签 。

如果一个正方形的中心在 (0, 0) ，所有边都平行于坐标轴，且正方形内 不 存在标签相同的两个点，那么我们称这个正方形是 合法 的。

请你返回 合法 正方形中可以包含的 最多 点数。

注意：


如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。

正方形的边长可以为零。


```cpp
class Solution {
public:
    int maxPointsInsideSquare(vector<vector<int>>& points, string s) {
        int ans=0;
        auto check=[&](int size)->bool{
            int vis=0;
            for(int i=0;i<points.size();i++){
                if(abs(points[i][0])<=size && abs(points[i][1])<=size){
                    auto c=s[i]-'a';
                    if(vis>>c&1){//c在集合中
                        return false;
                    }
                    vis|=1<<c;
                }
            }
            ans=__builtin_popcount(vis);
            return true;
        };
        int left=-1,right=1'000'000'001;
        while(left+1<right){
            int mid=(left+right)/2;
            (check(mid)?left:right)=mid;
        }
        return ans;
    }
};
```

这个解法使用了位运算

# 33 搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(right-left)/2+left;
            if(nums[mid]==target) return mid;
            if(nums[0]<=nums[mid]){
                if(nums[0]<=target&&target<nums[mid]) right=mid-1;
                else left=mid+1;
            }else{
                if(nums[mid]<target&&target<=nums.back()) left=mid+1;
                else right=mid-1;
            }
        }
        return -1;
    }
};
```

# 852 山脉数组的峰顶索引

给定一个长度为 n 的整数 山脉 数组 arr ，其中的值递增到一个 峰值元素 然后递减。

返回峰值元素的下标。

你必须设计并实现时间复杂度为 O(log(n)) 的解决方案。

记满足题目要求的下标 i 为 ians。我们可以发现：

    当 i<ians 时，arri<arri+1 恒成立；

    当 i≥ians 时，arri>arri+1 恒成立。

因此 ians 即为「最小的满足 arri>arri+1 的下标 i，我们可以用二分查找的方法来找出 ians。

```cpp 
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int left = 1, right = arr.size() - 2, ans = 0;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (arr[mid] > arr[mid + 1]) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
};
```

# LCR 170 交易逆序对的总数

在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 record，返回其中存在的「交易逆序对」总数。

思路： 归并排序

```cpp 
class Solution {
public:
    int mergeSort(vector<int>& record, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }

        int mid = (l + r) / 2;
        int inv_count = mergeSort(record, tmp, l, mid) + mergeSort(record, tmp, mid + 1, r);
        int i = l, j = mid + 1, pos = l;
        while (i <= mid && j <= r) {
            if (record[i] <= record[j]) {
                tmp[pos] = record[i];
                ++i;
                inv_count += (j - (mid + 1));
            }
            else {
                tmp[pos] = record[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {
            tmp[pos++] = record[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {
            tmp[pos++] = record[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, record.begin() + l);
        return inv_count;
    }

    int reversePairs(vector<int>& record) {
        int n = record.size();
        vector<int> tmp(n);
        return mergeSort(record, tmp, 0, n - 1);
    }
};
```

# 4 UNSOLVED 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

```cpp
class Solution {
 public:
  int getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {
    int m = nums1.size(), n = nums2.size();
    int index1 = 0, index2 = 0;
    while (true) {
      if (index1 == m) return nums2[index2 + k - 1];
      if (index2 == n) return nums1[index1 + k - 1];
      if (k == 1) return std::min(nums1[index1], nums2[index2]);
      int newindex1 = std::min(index1 + k / 2 - 1, m - 1);
      int newindex2 = std::min(index2 + k / 2 - 1, n - 1);
      int pivot1 = nums1.at(newindex1);
      int pivot2 = nums2.at(newindex2);
      if (pivot2 >= pivot1) {
        k -= newindex1 - index1 + 1;
        index1 = newindex1 + 1;
      } else {
        k -= newindex2 - index2 + 1;
        index2 = newindex2 + 1;
      }
    }
  }
  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int totallen = nums1.size() + nums2.size();
    if (totallen % 2 == 1)
      return getKthElement(nums1, nums2, (totallen + 1) / 2);
    else
      return getKthElement(nums1, nums2, totallen / 2) / 2.0 +
             getKthElement(nums1, nums2, totallen / 2 + 1) / 2.0;
  }
};
```
# 268 丢失的数字

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        ranges::sort(nums);
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(mid<nums[mid]){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
};
```

# 162 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left=0,right=nums.size()-1;
        while(left+1<right){
            int mid=(left+right)/2;
            if(nums[mid-1]<nums[mid]){
                left=mid;
            }else{
                right=mid;
            }
        }
        return nums[left]>nums[right]?left:right;
    }
};
```
# 436 寻找右区间

给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。

区间 i 的 右侧区间 可以记作区间 j ，并满足 startj >= endi ，且 startj 最小化 。注意 i 可能等于 j 。

返回一个由每个区间 i 的 右侧区间 在 intervals 中对应下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。

```cpp
class Solution {
 public:
  vector<int> findRightInterval(vector<vector<int>>& intervals) {
    vector<pair<int, int>> startIntervals;
    int n = intervals.size();
    for (int i = 0; i < n; i++) {
      startIntervals.push_back({intervals[i][0], i});
    }
    std::sort(startIntervals.begin(), startIntervals.end());
    vector<int> ans(n, -1);
    for (int i = 0; i < n; i++) {
      auto it = std::lower_bound(startIntervals.begin(), startIntervals.end(),
                                 std::make_pair(intervals[i][1], 0));
      if (it != startIntervals.end()) {
        ans[i] = it->second;
      }
    }
    return ans;
  }
};
```
