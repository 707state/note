
# 三数之和为0

```c++ 
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n=nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int first=0;first<n;first++){
            if(first>0&&nums[first]==nums[first-1]){
                continue;
            }
            int third=n-1;
            int target=-nums[first];
            for(int second=first+1;second<n;second++){
                if(second>first+1&&nums[second]==nums[second-1]){
                    continue;
                }
                while(second<third&&nums[second]+nums[third]>target){
                    --third;
                }
                if(second==third){
                    break;
                }
                if(nums[second]+nums[third]==target){
                    ans.emplace_back(vector<int>{nums[first],nums[second],nums[third]});
                }
            }
        }
        return ans;
    }
};
```

# 16 最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int ans=0;
        int n=nums.size();
        int minDiff=INT_MAX;
        for(int first=0;first<n;++first){
            if(first>0&&nums[first]==nums[first-1]) continue;
            int third=n-1;
            int second=first+1;
            while(second<third){
                int sum=nums[first]+nums[second]+nums[third];
                if(sum==target) return target;
                if(abs(sum-target)<minDiff) {minDiff=abs(sum-target);ans=sum;}
                if(sum>target){
                    int k=third-1;
                    while(second<k&&nums[k]==nums[third]) --k;
                    third=k;
                }else {
                    int k=second+1;
                    while(k<third&&nums[k]==nums[second]) ++k;
                    second=k;
                }
                if(second==third) break;
            }
        }
        return ans;
    }
};
```

# 3309 连接二进制表示可形成的最大数值

给你一个长度为 3 的整数数组 nums。

现以某种顺序 连接 数组 nums 中所有元素的 二进制表示 ，请你返回可以由这种方法形成的 最大 数值。

注意 任何数字的二进制表示 不含 前导零。
```c++
class Solution {
public:
    int maxGoodNumber(vector<int>& nums) {
        ranges::sort(nums,[](int a,int b){
            int a_log=log2(a)+1;
            int b_log=log2(b)+1;
            return a*(pow(2,b_log)-1)>b*(pow(2,a_log)-1);
        });
        int ans=0;
        for(auto& each: nums){
            ans=ans<<(__lg(each)+1)|each;
        }
        return ans;
    }
};
```


# 18 四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

    0 <= a, b, c, d < n
    a、b、c 和 d 互不相同
    nums[a] + nums[b] + nums[c] + nums[d] == target

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a < n - 3; a++) {
            long long x = nums[a];
            if (a > 0 && x == nums[a - 1])
                continue;
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target)
                break;
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target)
                continue;
            for (int b = a + 1; b < n - 2; b++) {
                long long y = nums[b];
                if (b > a + 1 && y == nums[b - 1])
                    continue;
                if (x + y + nums[b + 1] + nums[b + 2] > target) break;
                if (x + y + nums[n - 2] + nums[n - 1] < target) continue;
                int c=b+1,d=n-1;
                while(c<d){
                    long long s=x+y+nums[c]+nums[d];
                    if(s>target) d--;
                    else if(s<target) c++;
                    else{
                        ans.emplace_back(vector<int>{(int)x,(int)y,nums[c],nums[d]});
                        for(c++;c<d&&nums[c]==nums[c-1];c++);
                        for(d--;c<d&&nums[d]==nums[d+1];d--);
                    }
                }
            }
        }
        return ans;
    }
};
```

# 259 较小的三数之和

给定一个长度为 n 的整数数组和一个目标值 target ，寻找能够使条件 nums[i] + nums[j] + nums[k] < target 成立的三元组  i, j, k 个数（0 <= i < j < k < n）。

```c++
class Solution {
public:
    int threeSumSmaller(vector<int>& nums, int target) {
        int n=nums.size();
        ranges::sort(nums);
        int ans=0;
        for(int first=0;first<n-2;first++){
           int second=first+1;
           int third=n-1;
           while(second<third){
            if(nums[first]+nums[second]+nums[third]>=target) third--;
            else {
                ans+=third-second;
                second++;
            }
           }
        }
        return ans;
    }
};
```


# 88 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

思路：这道题需要从后向前排序

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
            int p1=m-1,p2=n-1,p=m+n-1;
            while(p2>=0){
                if(p1>=0&&nums1[p1]>nums2[p2]){
                    nums1[p--]=nums1[p1--];
                }else{
                    nums1[p--]=nums2[p2--];
                }
            }
    }
};
```

# 31 下一个排列

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。

类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。

而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。


思路：

我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：


在 尽可能靠右的低位 进行交换，需要 从后向前 查找

将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换

将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

```c++ 
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if (nums.size() <= 1)
            return;
        int i = nums.size() - 2, j = nums.size() - 1;
        while (i >= 0 && nums[i] >= nums[j]) {
            i--, j--;
        }
        if (i >= 0) {
            int k = nums.size() - 1;
            while (nums[i] >= nums[k]) {
                k--;
            }
            swap(nums[i], nums[k]);
        }
        reverse(nums.begin() + j, nums.end());
    }
};
```


