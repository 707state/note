
# 三数之和为0

```c++ 
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n=nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int first=0;first<n;first++){
            if(first>0&&nums[first]==nums[first-1]){
                continue;
            }
            int third=n-1;
            int target=-nums[first];
            for(int second=first+1;second<n;second++){
                if(second>first+1&&nums[second]==nums[second-1]){
                    continue;
                }
                while(second<third&&nums[second]+nums[third]>target){
                    --third;
                }
                if(second==third){
                    break;
                }
                if(nums[second]+nums[third]==target){
                    ans.emplace_back(vector<int>{nums[first],nums[second],nums[third]});
                }
            }
        }
        return ans;
    }
};
```

# 16 最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int ans=0;
        int n=nums.size();
        int minDiff=INT_MAX;
        for(int first=0;first<n;++first){
            if(first>0&&nums[first]==nums[first-1]) continue;
            int third=n-1;
            int second=first+1;
            while(second<third){
                int sum=nums[first]+nums[second]+nums[third];
                if(sum==target) return target;
                if(abs(sum-target)<minDiff) {minDiff=abs(sum-target);ans=sum;}
                if(sum>target){
                    int k=third-1;
                    while(second<k&&nums[k]==nums[third]) --k;
                    third=k;
                }else {
                    int k=second+1;
                    while(k<third&&nums[k]==nums[second]) ++k;
                    second=k;
                }
                if(second==third) break;
            }
        }
        return ans;
    }
};
```

# 3309 连接二进制表示可形成的最大数值

给你一个长度为 3 的整数数组 nums。

现以某种顺序 连接 数组 nums 中所有元素的 二进制表示 ，请你返回可以由这种方法形成的 最大 数值。

注意 任何数字的二进制表示 不含 前导零。
```c++
class Solution {
public:
    int maxGoodNumber(vector<int>& nums) {
        ranges::sort(nums,[](int a,int b){
            int a_log=log2(a)+1;
            int b_log=log2(b)+1;
            return a*(pow(2,b_log)-1)>b*(pow(2,a_log)-1);
        });
        int ans=0;
        for(auto& each: nums){
            ans=ans<<(__lg(each)+1)|each;
        }
        return ans;
    }
};
```


# 18 四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

    0 <= a, b, c, d < n
    a、b、c 和 d 互不相同
    nums[a] + nums[b] + nums[c] + nums[d] == target

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a < n - 3; a++) {
            long long x = nums[a];
            if (a > 0 && x == nums[a - 1])
                continue;
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target)
                break;
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target)
                continue;
            for (int b = a + 1; b < n - 2; b++) {
                long long y = nums[b];
                if (b > a + 1 && y == nums[b - 1])
                    continue;
                if (x + y + nums[b + 1] + nums[b + 2] > target) break;
                if (x + y + nums[n - 2] + nums[n - 1] < target) continue;
                int c=b+1,d=n-1;
                while(c<d){
                    long long s=x+y+nums[c]+nums[d];
                    if(s>target) d--;
                    else if(s<target) c++;
                    else{
                        ans.emplace_back(vector<int>{(int)x,(int)y,nums[c],nums[d]});
                        for(c++;c<d&&nums[c]==nums[c-1];c++);
                        for(d--;c<d&&nums[d]==nums[d+1];d--);
                    }
                }
            }
        }
        return ans;
    }
};
```

# 259 较小的三数之和

给定一个长度为 n 的整数数组和一个目标值 target ，寻找能够使条件 nums[i] + nums[j] + nums[k] < target 成立的三元组  i, j, k 个数（0 <= i < j < k < n）。

```c++
class Solution {
public:
    int threeSumSmaller(vector<int>& nums, int target) {
        int n=nums.size();
        ranges::sort(nums);
        int ans=0;
        for(int first=0;first<n-2;first++){
           int second=first+1;
           int third=n-1;
           while(second<third){
            if(nums[first]+nums[second]+nums[third]>=target) third--;
            else {
                ans+=third-second;
                second++;
            }
           }
        }
        return ans;
    }
};
```


