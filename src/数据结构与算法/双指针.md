# 三数之和为0

```cpp 
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n=nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int first=0;first<n;first++){
            if(first>0&&nums[first]==nums[first-1]){
                continue;
            }
            int third=n-1;
            int target=-nums[first];
            for(int second=first+1;second<n;second++){
                if(second>first+1&&nums[second]==nums[second-1]){
                    continue;
                }
                while(second<third&&nums[second]+nums[third]>target){
                    --third;
                }
                if(second==third){
                    break;
                }
                if(nums[second]+nums[third]==target){
                    ans.emplace_back(vector<int>{nums[first],nums[second],nums[third]});
                }
            }
        }
        return ans;
    }
};
```

# 16 最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int ans=0;
        int n=nums.size();
        int minDiff=INT_MAX;
        for(int first=0;first<n;++first){
            if(first>0&&nums[first]==nums[first-1]) continue;
            int third=n-1;
            int second=first+1;
            while(second<third){
                int sum=nums[first]+nums[second]+nums[third];
                if(sum==target) return target;
                if(abs(sum-target)<minDiff) {minDiff=abs(sum-target);ans=sum;}
                if(sum>target){
                    int k=third-1;
                    while(second<k&&nums[k]==nums[third]) --k;
                    third=k;
                }else {
                    int k=second+1;
                    while(k<third&&nums[k]==nums[second]) ++k;
                    second=k;
                }
                if(second==third) break;
            }
        }
        return ans;
    }
};
```

# 3309 连接二进制表示可形成的最大数值

给你一个长度为 3 的整数数组 nums。

现以某种顺序 连接 数组 nums 中所有元素的 二进制表示 ，请你返回可以由这种方法形成的 最大 数值。

注意 任何数字的二进制表示 不含 前导零。
```cpp
class Solution {
public:
    int maxGoodNumber(vector<int>& nums) {
        ranges::sort(nums,[](int a,int b){
            int a_log=log2(a)+1;
            int b_log=log2(b)+1;
            return a*(pow(2,b_log)-1)>b*(pow(2,a_log)-1);
        });
        int ans=0;
        for(auto& each: nums){
            ans=ans<<(__lg(each)+1)|each;
        }
        return ans;
    }
};
```


# 18 四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

    0 <= a, b, c, d < n
    a、b、c 和 d 互不相同
    nums[a] + nums[b] + nums[c] + nums[d] == target

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a < n - 3; a++) {
            long long x = nums[a];
            if (a > 0 && x == nums[a - 1])
                continue;
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target)
                break;
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target)
                continue;
            for (int b = a + 1; b < n - 2; b++) {
                long long y = nums[b];
                if (b > a + 1 && y == nums[b - 1])
                    continue;
                if (x + y + nums[b + 1] + nums[b + 2] > target) break;
                if (x + y + nums[n - 2] + nums[n - 1] < target) continue;
                int c=b+1,d=n-1;
                while(c<d){
                    long long s=x+y+nums[c]+nums[d];
                    if(s>target) d--;
                    else if(s<target) cpp;
                    else{
                        ans.emplace_back(vector<int>{(int)x,(int)y,nums[c],nums[d]});
                        for(cpp;c<d&&nums[c]==nums[c-1];c++);
                        for(d--;c<d&&nums[d]==nums[d+1];d--);
                    }
                }
            }
        }
        return ans;
    }
};
```

# 259 较小的三数之和

给定一个长度为 n 的整数数组和一个目标值 target ，寻找能够使条件 nums[i] + nums[j] + nums[k] < target 成立的三元组  i, j, k 个数（0 <= i < j < k < n）。

```cpp
class Solution {
public:
    int threeSumSmaller(vector<int>& nums, int target) {
        int n=nums.size();
        ranges::sort(nums);
        int ans=0;
        for(int first=0;first<n-2;first++){
           int second=first+1;
           int third=n-1;
           while(second<third){
            if(nums[first]+nums[second]+nums[third]>=target) third--;
            else {
                ans+=third-second;
                second++;
            }
           }
        }
        return ans;
    }
};
```


# 88 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

思路：这道题需要从后向前排序

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
            int p1=m-1,p2=n-1,p=m+n-1;
            while(p2>=0){
                if(p1>=0&&nums1[p1]>nums2[p2]){
                    nums1[p--]=nums1[p1--];
                }else{
                    nums1[p--]=nums2[p2--];
                }
            }
    }
};
```

# 31 下一个排列

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。

类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。

而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。


思路：

我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：


在 尽可能靠右的低位 进行交换，需要 从后向前 查找

将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换

将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

```cpp 
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if (nums.size() <= 1)
            return;
        int i = nums.size() - 2, j = nums.size() - 1;
        while (i >= 0 && nums[i] >= nums[j]) {
            i--, j--;
        }
        if (i >= 0) {
            int k = nums.size() - 1;
            while (nums[i] >= nums[k]) {
                k--;
            }
            swap(nums[i], nums[k]);
        }
        reverse(nums.begin() + j, nums.end());
    }
};
```

# 5 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

```cpp 
class Solution {
public:
    string longestPalindrome(string s) {
        int len=1;
        int max_len=0;
        int left_max=0,right_max=0;
        int right_ans=0;
        int left_ans=0;
        for(int mid=0;mid<s.length();mid++){
            left_max=mid-1;
            right_max=mid+1;
            while(left_max>=0&&s[left_max]==s[mid]){
                len++;
                left_max--;
            }
            while(right_max<s.length()&&s[mid]==s[right_max]){
                len++;
                right_max++;
            }
            while(left_max>=0&&right_max<s.length()&&s[left_max]==s[right_max]){
                len+=2;
                left_max--;
                right_max++;
            }
            if(len>max_len){
                max_len=len;
                left_ans=left_max;
                right_ans=right_max;
            }
            len=1;
        }
        return s.substr(left_ans+1, max_len);
    }
};
```


# 186 反转字符串中的单词2 

给你一个字符数组 s ，反转其中 单词 的顺序。

单词 的定义为：单词是一个由非空格字符组成的序列。s 中的单词将会由单个空格分隔。

必须设计并实现 原地 解法来解决此问题，即不分配额外的空间。

```cpp 
class Solution {
public:
    void reverseWords(vector<char>& s) {
        if(s.size()==2) return;
        ranges::reverse(s);
        int n=s.size();
        int prev_blancket=0;
        for(int i=0;i<=n;i++){
            if(i==n||s[i]==' '){
                reverse(s.begin()+prev_blancket,s.begin()+i);
                prev_blancket=i+1;
            }
        }
    }
};
```

# 415 字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

```cpp 
class Solution {
public:
    string addStrings(string num1, string num2) {
        int i=num1.length()-1;
        int j=num2.length()-1;
        int carry=0;
        string ans;
        while(i>=0||j>=0||carry){
            int x=i>=0?num1[i--]-'0':0;
            int y=j>=0?num2[j--]-'0':0;
            int result=x+y+carry;
            ans.push_back(result%10+'0');
            carry=result/10;
        }
        ranges::reverse(ans);
        return ans;
    }
};
```

# 盛最多水的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。
```cpp 
class Solution {
public:
    int maxArea(vector<int>& height) {
       int left=0,right=height.size()-1;
       int ans=0;
       while(left<right){
        ans=max(ans,(right-left)*(min(height[left],height[right])));
        if(height[left]>height[right]){
            right--;
        }else{
            left++;
        }
       } 
       return ans;
    }
};
```

# 26 删除有序数组中的重复项

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：

更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
返回 k 。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int fast=1;
        int slow=1;
        int n=nums.size();
        if(n<1){
            return n;
        }
        while(fast<n){
            if(nums[fast]!=nums[fast-1]){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

# 165 比较版本号

给你两个 版本号字符串 version1 和 version2 ，请你比较它们。版本号由被点 '.' 分开的修订号组成。修订号的值 是它 转换为整数 并忽略前导零。

比较版本号时，请按 从左到右的顺序 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 0。

返回规则如下：

如果 version1 < version2 返回 -1，
如果 version1 > version2 返回 1，
除此之外返回 0。

```cpp 
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int n=version1.length();
        int m=version2.length();
        int i=0,j=0;
        while(i<n||j<m){
            long long x=0;
            for(;i<n&&version1[i]!='.';++i){
                x=x*10+version1[i]-'0';
            }
            ++i;
            long long y=0;
            for(;j<m&&version2[j]!='.';++j){
                y=y*10+version2[j]-'0';
            }
            ++j;
            if(x!=y){
                return x>y?1:-1;
            }
        }
        return 0;
    }
};
```
# 125 验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。
字母和数字都属于字母数字字符。

给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。
```cpp 
class Solution {
public:
    bool isPalindrome(string s) {
        for(int i=0;i<s.length();){
            if(s[i]>='A'&&s[i]<='Z'){
                s[i]+=32;
            }
            if((s[i]>='a'&&s[i]<='z')||(s[i]>='0'&&s[i]<='9')){
                i++;
                continue;
            }else{
                s.erase(i, 1);
            }
        }
        int left=0,right=s.length()-1;
        while(left<right){
            if(s[left++]!=s[right--]){
                return false;
            }
        }
        return true;
    }
};
```

# 3239 最少翻转次数使二进制矩阵回文 I

给你一个 m x n 的二进制矩阵 grid 。

如果矩阵中一行或者一列从前往后与从后往前读是一样的，那么我们称这一行或者这一列是 回文 的。

你可以将 grid 中任意格子的值 翻转 ，也就是将格子里的值从 0 变成 1 ，或者从 1 变成 0 。

请你返回 最少 翻转次数，使得矩阵 要么 所有行是 回文的 ，要么所有列是 回文的 。

```cpp
class Solution {
public:
    int minFlips(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        int diff_row=0;
        for(auto& row:grid){
            for(int j=0;j<n/2;j++){
                diff_row+=row[j]!=row[n-1-j];
            }
        }
        int diff_col=0;
        for(int j=0;j<n;j++){
            for(int i=0;i<m/2;i++){
                diff_col+=grid[i][j]!=grid[m-1-i][j];
            }
        }
        return min(diff_col,diff_row);
    }
};
```


