<!--toc:start-->
- [15 三数之和为 0](#15-三数之和为-0)
- [16 最接近的三数之和](#16-最接近的三数之和)
- [3309 连接二进制表示可形成的最大数值](#3309-连接二进制表示可形成的最大数值)
- [18 四数之和](#18-四数之和)
- [259 较小的三数之和](#259-较小的三数之和)
- [88 合并两个有序数组](#88-合并两个有序数组)
- [31 下一个排列](#31-下一个排列)
- [5 最长回文子串](#5-最长回文子串)
- [186 反转字符串中的单词 2](#186-反转字符串中的单词-2)
- [415 字符串相加](#415-字符串相加)
- [盛最多水的容器](#盛最多水的容器)
- [26 删除有序数组中的重复项](#26-删除有序数组中的重复项)
- [165 比较版本号](#165-比较版本号)
- [3239 最少翻转次数使二进制矩阵回文 I](#3239-最少翻转次数使二进制矩阵回文-i)
- [11 盛水最多的容器](#11-盛水最多的容器)
- [1847 UNSOLVED 最近的房间](#1847-unsolved-最近的房间)
- [161 相隔为 1 的编辑距离](#161-相隔为-1-的编辑距离)
- [616 给字符串添加标签](#616-给字符串添加标签)
- [1813 句子相似性3](#1813-句子相似性3)
- [849 到最近的人的最大距离](#849-到最近的人的最大距离)
- [202 快乐数](#202-快乐数)
- [986 区间列表的交集](#986-区间列表的交集)
<!--toc:end-->

# 15 三数之和为 0

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n=nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int first=0;first<n;first++){
            if(first>0&&nums[first]==nums[first-1]){
                continue;
            }
            int third=n-1;
            int target=-nums[first];
            for(int second=first+1;second<n;second++){
                if(second>first+1&&nums[second]==nums[second-1]){
                    continue;
                }
                while(second<third&&nums[second]+nums[third]>target){
                    --third;
                }
                if(second==third){
                    break;
                }
                if(nums[second]+nums[third]==target){
                    ans.emplace_back(vector<int>{nums[first],nums[second],nums[third]});
                }
            }
        }
        return ans;
    }
};
```

</details>

# 16 最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums
中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int ans=0;
        int n=nums.size();
        int minDiff=INT_MAX;
        for(int first=0;first<n;++first){
            if(first>0&&nums[first]==nums[first-1]) continue;
            int third=n-1;
            int second=first+1;
            while(second<third){
                int sum=nums[first]+nums[second]+nums[third];
                if(sum==target) return target;
                if(abs(sum-target)<minDiff) {minDiff=abs(sum-target);ans=sum;}
                if(sum>target){
                    int k=third-1;
                    while(second<k&&nums[k]==nums[third]) --k;
                    third=k;
                }else {
                    int k=second+1;
                    while(k<third&&nums[k]==nums[second]) ++k;
                    second=k;
                }
                if(second==third) break;
            }
        }
        return ans;
    }
};
```

</details>

# 3309 连接二进制表示可形成的最大数值

给你一个长度为 3 的整数数组 nums。

现以某种顺序 连接 数组 nums 中所有元素的 二进制表示
，请你返回可以由这种方法形成的 最大 数值。

注意 任何数字的二进制表示 不含 前导零。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int maxGoodNumber(vector<int>& nums) {
        ranges::sort(nums,[](int a,int b){
            int a_log=log2(a)+1;
            int b_log=log2(b)+1;
            return a*(pow(2,b_log)-1)>b*(pow(2,a_log)-1);
        });
        int ans=0;
        for(auto& each: nums){
            ans=ans<<(__lg(each)+1)|each;
        }
        return ans;
    }
};
```

</details>

# 18 四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target
。请你找出并返回满足下述全部条件且不重复的四元组 \[nums\[a\], nums\[b\],
nums\[c\], nums\[d\]\]
（若两个四元组元素一一对应，则认为两个四元组重复）：

    0 <= a, b, c, d < n
    a、b、c 和 d 互不相同
    nums[a] + nums[b] + nums[c] + nums[d] == target

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a < n - 3; a++) {
            long long x = nums[a];
            if (a > 0 && x == nums[a - 1])
                continue;
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target)
                break;
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target)
                continue;
            for (int b = a + 1; b < n - 2; b++) {
                long long y = nums[b];
                if (b > a + 1 && y == nums[b - 1])
                    continue;
                if (x + y + nums[b + 1] + nums[b + 2] > target) break;
                if (x + y + nums[n - 2] + nums[n - 1] < target) continue;
                int c=b+1,d=n-1;
                while(c<d){
                    long long s=x+y+nums[c]+nums[d];
                    if(s>target) d--;
                    else if(s<target) cpp;
                    else{
                        ans.emplace_back(vector<int>{(int)x,(int)y,nums[c],nums[d]});
                        for(cpp;c<d&&nums[c]==nums[c-1];c++);
                        for(d--;c<d&&nums[d]==nums[d+1];d--);
                    }
                }
            }
        }
        return ans;
    }
};
```

</details>

# 259 较小的三数之和

给定一个长度为 n 的整数数组和一个目标值 target ，寻找能够使条件
nums\[i\] + nums\[j\] + nums\[k\] \< target 成立的三元组 i, j, k 个数（0
\<= i \< j \< k \< n）。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int threeSumSmaller(vector<int>& nums, int target) {
        int n=nums.size();
        ranges::sort(nums);
        int ans=0;
        for(int first=0;first<n-2;first++){
           int second=first+1;
           int third=n-1;
           while(second<third){
            if(nums[first]+nums[second]+nums[third]>=target) third--;
            else {
                ans+=third-second;
                second++;
            }
           }
        }
        return ans;
    }
};
```

</details>

# 88 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n
，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1
中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m
个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

思路：这道题需要从后向前排序

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
            int p1=m-1,p2=n-1,p=m+n-1;
            while(p2>=0){
                if(p1>=0&&nums1[p1]>nums2[p2]){
                    nums1[p--]=nums1[p1--];
                }else{
                    nums1[p--]=nums2[p2--];
                }
            }
    }
};
```

</details>

# 31 下一个排列

整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。

例如，arr = \[1,2,3\] ，以下这些都可以视作 arr
的排列：\[1,2,3\]、\[1,3,2\]、\[3,1,2\]、\[2,3,1\] 。

整数数组的 下一个排列
是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的
下一个排列
就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = \[1,2,3\] 的下一个排列是 \[1,3,2\] 。

类似地，arr = \[2,3,1\] 的下一个排列是 \[3,1,2\] 。

而 arr = \[3,2,1\] 的下一个排列是 \[1,2,3\] ，因为 \[3,2,1\]
不存在一个字典序更大的排列。

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

<details><summary>Click to expand</summary>

思路：

我们希望下一个数 比当前数大，这样才满足 "下一个排列" 的定义。因此只需要
将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如
123456，将 5 和 6 交换就能得到一个更大的数 123465。 我们还希望下一个数
增加的幅度尽可能的小，这样才满足"下一个排列与当前排列紧邻"的要求。为了满足这个要求，我们需要：

在 尽可能靠右的低位 进行交换，需要 从后向前 查找

将一个 尽可能小的「大数」 与前面的「小数」交换。比如
123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换

将「大数」换到前面后，需要将「大数」后面的所有数
重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换
5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然
123546 比 123564 更小，123546 就是 123465 的下一个排列

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if (nums.size() <= 1)
            return;
        int i = nums.size() - 2, j = nums.size() - 1;
        while (i >= 0 && nums[i] >= nums[j]) {
            i--, j--;
        }
        if (i >= 0) {
            int k = nums.size() - 1;
            while (nums[i] >= nums[k]) {
                k--;
            }
            swap(nums[i], nums[k]);
        }
        reverse(nums.begin() + j, nums.end());
    }
};
```

</details>

# 5 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int len=1;
        int max_len=0;
        int left_max=0,right_max=0;
        int right_ans=0;
        int left_ans=0;
        for(int mid=0;mid<s.length();mid++){
            left_max=mid-1;
            right_max=mid+1;
            while(left_max>=0&&s[left_max]==s[mid]){
                len++;
                left_max--;
            }
            while(right_max<s.length()&&s[mid]==s[right_max]){
                len++;
                right_max++;
            }
            while(left_max>=0&&right_max<s.length()&&s[left_max]==s[right_max]){
                len+=2;
                left_max--;
                right_max++;
            }
            if(len>max_len){
                max_len=len;
                left_ans=left_max;
                right_ans=right_max;
            }
            len=1;
        }
        return s.substr(left_ans+1, max_len);
    }
};
```

</details>

# 186 反转字符串中的单词 2

给你一个字符数组 s ，反转其中 单词 的顺序。

单词 的定义为：单词是一个由非空格字符组成的序列。s
中的单词将会由单个空格分隔。

必须设计并实现 原地 解法来解决此问题，即不分配额外的空间。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    void reverseWords(vector<char>& s) {
        if(s.size()==2) return;
        ranges::reverse(s);
        int n=s.size();
        int prev_blancket=0;
        for(int i=0;i<=n;i++){
            if(i==n||s[i]==' '){
                reverse(s.begin()+prev_blancket,s.begin()+i);
                prev_blancket=i+1;
            }
        }
    }
};
```

</details>

# 415 字符串相加

给定两个字符串形式的非负整数 num1 和 num2
，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger），
也不能直接将输入的字符串转换为整数形式。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        int i=num1.length()-1;
        int j=num2.length()-1;
        int carry=0;
        string ans;
        while(i>=0||j>=0||carry){
            int x=i>=0?num1[i--]-'0':0;
            int y=j>=0?num2[j--]-'0':0;
            int result=x+y+carry;
            ans.push_back(result%10+'0');
            carry=result/10;
        }
        ranges::reverse(ans);
        return ans;
    }
};
```

</details>

# 盛最多水的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是
(i, 0) 和 (i, height\[i\]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
       int left=0,right=height.size()-1;
       int ans=0;
       while(left<right){
        ans=max(ans,(right-left)*(min(height[left],height[right])));
        if(height[left]>height[right]){
            right--;
        }else{
            left++;
        }
       }
       return ans;
    }
};
```

</details>

# 26 删除有序数组中的重复项

给你一个 非严格递增排列 的数组 nums ，请你 原地
删除重复出现的元素，使每个元素 只出现一次
，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums
中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k
，你需要做以下事情确保你的题解可以被通过：

更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums
中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int fast=1;
        int slow=1;
        int n=nums.size();
        if(n<1){
            return n;
        }
        while(fast<n){
            if(nums[fast]!=nums[fast-1]){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

</details>

# 165 比较版本号

给你两个 版本号字符串 version1 和 version2 ，请你比较它们。版本号由被点
\'.\' 分开的修订号组成。修订号的值 是它 转换为整数 并忽略前导零。

比较版本号时，请按 从左到右的顺序
依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为
0。

返回规则如下：

如果 version1 \< version2 返回 -1， 如果 version1 \> version2 返回 1，
除此之外返回 0。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int n=version1.length();
        int m=version2.length();
        int i=0,j=0;
        while(i<n||j<m){
            long long x=0;
            for(;i<n&&version1[i]!='.';++i){
                x=x*10+version1[i]-'0';
            }
            ++i;
            long long y=0;
            for(;j<m&&version2[j]!='.';++j){
                y=y*10+version2[j]-'0';
            }
            ++j;
            if(x!=y){
                return x>y?1:-1;
            }
        }
        return 0;
    }
};
```

</details>
# 125 验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个
回文串 。 字母和数字都属于字母数字字符。

给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        for(int i=0;i<s.length();){
            if(s[i]>='A'&&s[i]<='Z'){
                s[i]+=32;
            }
            if((s[i]>='a'&&s[i]<='z')||(s[i]>='0'&&s[i]<='9')){
                i++;
                continue;
            }else{
                s.erase(i, 1);
            }
        }
        int left=0,right=s.length()-1;
        while(left<right){
            if(s[left++]!=s[right--]){
                return false;
            }
        }
        return true;
    }
};
```

</details>

# 3239 最少翻转次数使二进制矩阵回文 I

给你一个 m x n 的二进制矩阵 grid 。

如果矩阵中一行或者一列从前往后与从后往前读是一样的，那么我们称这一行或者这一列是
回文 的。

你可以将 grid 中任意格子的值 翻转 ，也就是将格子里的值从 0 变成 1
，或者从 1 变成 0 。

请你返回 最少 翻转次数，使得矩阵 要么 所有行是 回文的 ，要么所有列是
回文的 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int minFlips(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        int diff_row=0;
        for(auto& row:grid){
            for(int j=0;j<n/2;j++){
                diff_row+=row[j]!=row[n-1-j];
            }
        }
        int diff_col=0;
        for(int j=0;j<n;j++){
            for(int i=0;i<m/2;i++){
                diff_col+=grid[i][j]!=grid[m-1-i][j];
            }
        }
        return min(diff_col,diff_row);
    }
};
```

</details>
# 3240 最少翻转次数使二进制矩阵回文 2

给你一个 m x n 的二进制矩阵 grid 。

如果矩阵中一行或者一列从前往后与从后往前读是一样的，那么我们称这一行或者这一列是
回文 的。

你可以将 grid 中任意格子的值 翻转 ，也就是将格子里的值从 0 变成 1
，或者从 1 变成 0 。

请你返回 最少 翻转次数，使得矩阵中 所有 行和列都是 回文的 ，且矩阵中 1
的数目可以被 4 整除 。

<details><summary>Click to expand</summary>

```cpp
class Solution {
public:
    int minFlips(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        int ans=0;
        for(int i=0;i<m/2;i++){
            for(int j=0;j<n/2;j++){
                int cnt1=grid[i][j]+grid[i][n-1-j]+grid[m-1-i][j]+grid[m-1-i][n-1-j];
                ans+=min(cnt1,4-cnt1);
            }
        }
        if(m%2&&n%2){
            ans+=grid[m/2][n/2];
        }
        int diff=0,cnt1=0;
        if(m%2){
            for(int j=0;j<n/2;j++){
                if(grid[m/2][j]!=grid[m/2][n-1-j]) diff++;
                else cnt1+=grid[m/2][j]*2;
            }
        }
        if(n%2){
            for(int i=0;i<m/2;i++){
                if(grid[i][n/2]!=grid[m-1-i][n/2]){
                    diff++;
                }else{
                    cnt1+=grid[i][n/2]*2;
                }
            }
        }
        return ans+(diff?diff:cnt1%4);
    }
};
```

</details>

# 11 盛水最多的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是
(i, 0) 和 (i, height\[i\]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

<details>

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
       int left=0,right=height.size()-1;
       int ans=0;
       while(left<right){
        ans=max(ans,(right-left)*(min(height[left],height[right])));
        if(height[left]>height[right]){
            right--;
        }else{
            left++;
        }
       }
       return ans;
    }
};
```

</details>

# 1847 UNSOLVED 最近的房间

一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] = [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。

同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] = [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：

    房间的面积 至少 为 minSizej ，且
    abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。

如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。

请你返回长度为 k 的数组 answer ，其中 answer[j] 为第 j 个查询的结果。

<details>

```cpp
class Solution {
public:
    vector<int> closestRoom(vector<vector<int>>& rooms,
                            vector<vector<int>>& queries) {
        // 按照 size 从大到小排序
        ranges::sort(rooms, {}, [](auto& a) { return -a[1]; });
        int q = queries.size();
        vector<int> query_ids(q);
        iota(query_ids.begin(), query_ids.end(), 0);
        // 按照 minSize 从大到小排序
        ranges::sort(query_ids, {}, [&](int i) { return -queries[i][1]; });
        vector<int> ans(q, -1);
        set<int> room_ids;
        int j = 0;
        for (int i : query_ids) {
            int preferred_id = queries[i][0], min_size = queries[i][1];
            while (j < rooms.size() && rooms[j][1] >= min_size) {
                room_ids.insert(rooms[j][0]);
                j++;
            }
            int diff = INT_MAX;
            auto it = room_ids.lower_bound(preferred_id);
            if (it != room_ids.begin()) {
                auto p = prev(it);
                diff = preferred_id - *p; // 左边的差
                ans[i] = *p;
            }
            if (it != room_ids.end() &&
                *it - preferred_id < diff) { // 右边的差更小
                ans[i] = *it;
            }
        }
        return ans;
    }
};
```

</details>

# 161 相隔为 1 的编辑距离

给定两个字符串 s 和 t ，如果它们的编辑距离为 1 ，则返回 true ，否则返回 false 。

字符串 s 和字符串 t 之间满足编辑距离等于 1 有三种可能的情形：

    往 s 中插入 恰好一个 字符得到 t
    从 s 中删除 恰好一个 字符得到 t
    在 s 中用 一个不同的字符 替换 恰好一个 字符得到 t

<details>

```cpp
class Solution {
public:
    bool isOneEditDistance(string s, string t) {
        int n=s.size();
        int m=t.size();
        if(abs(n-m)>=2){
            return false;
        }
        if(m==n){
            bool diff=false;
            for(int i=0;i<n;i++){
                if(s[i]!=t[i]){
                    if(!diff){
                        diff=true;
                    }else{
                        return false;
                    }
                }
            }
            return diff;
        }
        return (n-m>0)?isOneInsert(t,s):isOneInsert(s,t);
    }
    bool isOneInsert(string &a,string &b){
        int n=a.size();
        int m=b.size();
        int index1=0,index2=0;
        while (index1<n&&index2<m){
            if(a[index1]==b[index2]){
                index1++;
            }
            index2++;
            if(index2-index1>1){
                return false;
            }
        }
        return true;
    }
};
```

```rust
impl Solution {
    fn is_one_distance(s:&[char],t:&[char])->bool{
        let mut index1=0;
        let mut index2=0;
        let mismatch=false;
        while index1<s.len() && index2<t.len(){
            if s[index1]==t[index2]{
                index1=index1+1;
            }
            index2=index2+1;
            if index2-index1>1{
                return false;
            }
        }
        return true;
    }
    pub fn is_one_edit_distance(s: String, t: String) -> bool {
        let n=s.len();
        let m=t.len();
        if (n as i32-m as i32).abs()>=2{
            return false;
        }
        let s:Vec<char>=s.chars().collect();
        let t:Vec<char>=t.chars().collect();
        if n==m{
            let mut diff=false;
            for i in 0..n{
                if s[i]!=t[i]{
                    if !diff{
                        diff=true;
                    }else{
                        return false;
                    }
                }
            }
            return diff;
        }
        if n>m{
            return Self::is_one_distance(&t,&s);
        }else{
            return Self::is_one_distance(&s,&t);
        }
    }
}
```

</details>

# 616 给字符串添加标签

给定字符串 s 和字符串数组 words。

对于 s 内部的子字符串，若其存在于 words 数组中， 则通过添加闭合的粗体标签 <b> 和 </b> 进行加粗标记。

    如果两个这样的子字符串重叠，你应该仅使用一对闭合的粗体标签将它们包围起来。
    如果被粗体标签包围的两个子字符串是连续的，你应该将它们合并。

返回添加加粗标签后的字符串 s 。

<details>

```cpp
class Solution {
public:
    string addBoldTag(string s, vector<string>& words) {
        vector<vector<int>> v;
        for(auto& c:words){
            int inx=0;
            for(int i=0;i<s.size();i++){
                i=s.find(c,inx);
                if(i==string::npos){
                    break;
                }
                int sz=c.size();
                v.push_back({i,sz});
                inx=i+1;
            }
        }
        ranges::sort(v);
        vector<vector<int>> n_v;
        for(int i=0;i<v.size();i++){
            int left=v[i][0];
            int right=left+v[i][1];
            while(i<v.size()-1 && right>=v[i+1][0]){
                right=max(right,v[i+1][0]+v[i+1][1]);
                i++;
            }
            n_v.push_back({left,right-left});
        }
        int pos=0;
        for(auto &x:n_v){
            s.insert(x[0]+pos,"<b>");
            s.insert(x[1]+x[0]+pos+3,"</b>");
            pos+=7;
        }
        return s;
    }
};
```

</details>

# 1813 句子相似性3

给定两个字符串 sentence1 和 sentence2，每个表示由一些单词组成的一个句子。句子是一系列由 单个 空格分隔的 单词，且开头和结尾没有多余空格。每个单词都只包含大写和小写英文字母。

如果两个句子 s1 和 s2 ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。注意，插入的句子必须与现有单词用空白隔开。

比方说，

    s1 = "Hello Jane" 与 s2 = "Hello my name is Jane"，我们可以往 s1 中 "Hello" 和 "Jane" 之间插入 "my name is" 得到 s2 。
    s1 = "Frog cool" 与 s2 = "Frogs are cool" 不是相似的，因为尽管往 s1 中插入 "s are"，它没有与 "Frog" 用空格隔开。

给你两个句子 sentence1 和 sentence2 ，如果 sentence1 和 sentence2 是 相似 的，请你返回 true ，否则返回 false 。

<details>

```cpp
class Solution {
        vector<string> split(string& sen){
        stringstream ss(sen);
        vector<string> result;
        string temp;
        while(ss>>temp){
            result.emplace_back(temp);
        }
        return result;
    }
public:
    bool areSentencesSimilar(string sentence1, string sentence2) {
        auto w1=split(sentence1);
        auto w2=split(sentence2);
        int i=0,j=0;
        while(i<w1.size()&&i<w2.size()&&w1[i]==w2[i]){
            i++;
        }
        while(j<w1.size()-i && j<w2.size()-i &&w1[w1.size()-1-j]==w2[w2.size()-1-j]){
            j++;
        }
        return i+j==min(w1.size(),w2.size());
    }
};
```

</details>

# 849 到最近的人的最大距离

给你一个数组 seats 表示一排座位，其中 seats[i] = 1 代表有人坐在第 i 个座位上，seats[i] = 0 代表座位 i 上是空的（下标从 0 开始）。

至少有一个空座位，且至少有一人已经坐在座位上。

亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。

返回他到离他最近的人的最大距离。

<details>

```cpp
class Solution {
public:
    int maxDistToClosest(vector<int>& seats) {
        int l=0,r=0;
        int res=0;
        while(l<seats.size()&&seats[l]==0){
            ++l;
        }
        res=max(l,res);
        while(l<seats.size()){
            r=l+1;
            while(r<seats.size() && seats[r]==0){
                r++;
            }
            if(r==seats.size()){
                res=max(res,r-l-1);
            }else{
                res=max(res,(r-l)/2);
            }
            l=r;
        }
        return res;
    }
};
```

</details>

# 202 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

    对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
    然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
    如果这个过程 结果为 1，那么这个数就是快乐数。

如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

<details>

```cpp
class Solution {
public:
    int bitSquareSum(int n){
        int sum=0;
        while(n>0){
            int bit=n%10;
            sum+=bit*bit;
            n=n/10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int slow=n,fast=n;
        do{
            slow=bitSquareSum(slow);
            fast=bitSquareSum(fast);
            fast=bitSquareSum(fast);
        }while(slow!=fast);
        return slow==1;
    }
};
```

</details>

# 986 区间列表的交集

给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。

返回这 两个区间列表的交集 。

形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。

两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

<details>

```cpp
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
        int n=firstList.size();
        int m=secondList.size();
        vector<vector<int>> ans;
        int first=0,second=0;
        // 只有first<n && second<m的范围内才能出现答案
        while(first<n&&second<m){
            auto firstStart=firstList[first][0],secondStart=secondList[second][0],firstEnd=firstList[first][1],secondEnd=secondList[second][1];
            int low=max(firstStart,secondStart);
            int high=min(firstEnd,secondEnd);
            if(low<=high){
                ans.push_back({low,high});
            }
            if(firstEnd<secondEnd){
                first++;
            }else{
                second++;
            }
        }
        return ans;
    }
};
```

</details>
