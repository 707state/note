<!-- toc -->

# 算法

## 归纳法

1. 整数的素因数分解定理

算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个或以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。 

<details>

算术基本定理的最早证明是由欧几里得给出的。准确的说，欧几里得证明了在一般整环上看与算术基本定理等价的命题：若质数 p | ab，则不是 p | a，就是 p | b。然而，在欧几里得的时代，并没有发展出幂运算和指数的写法，甚至连四个整数的乘积这种算式都被认为是没有意义的，所以欧几里得并没有给出算术基本定理的现代陈述。 

存在性：

用反证法：假设存在大于 1 的自然数不能写成质数的乘积，把最小的那个称为 n。

n 不可为质数，因为 n = n 可被写成质数的乘积。因此 n一定是合数，但每个合数都可以分解成两个严格小于自身而大于 1 的自然数的积。设 n = a × b ，则根据假设，由于 n 是最小的不能被写成质数乘积的自然数，所以 a = p 1 p 2 . . . p j 和 b = q 1 q 2 . . . q j 都能被写成质数的乘积。然而 n = a b = p 1 p 2 . . . p j q 1 q 2 . . . q j 也可以写成质数的乘积，由此产生矛盾，故大于 1 的自然数必可写成质数的乘积。 

唯一性

欧几里得引理：若质数 p | a b ，则不是 p | a ，就是 p | b 。

引理的证明：若 p | a  则证明完毕。若 p ∤ a ，那么两者的最大公约数为1。根据贝祖等式，存在 ( m , n )  使得 m a + n p = 1 。于是 b = b ( m a + n p ) = a b m + b n p 。 由于 p | a b ，上式右边两项都可以被p整除。所以 p | b 。

再用反证法：假设有些大于1的自然数可以以多于一种的方式写成多个质数的乘积，那么假设 n 是其中最小的一个。

首先 n 不是质数。将 n 用两种方法写出： n = p 1 p 2 p 3 ⋯ p r = q 1 q 2 q 3 ⋯ q s  。根据引理，质数 p 1 | q 1 q 2 q 3 ⋯ q s  ，所以 q 1 , q 2 , q 3 ⋯ q s  中有一个能被 p 1 整除，不妨设为 q 1 。但 q 1 也是质数，因此 q 1 = p 1  。所以，比 n 小的正整数 n ′ = p 2 p 3 ⋯ p r 也可以写成 q 2 q 3 ⋯ q s  。这与 n  的最小性矛盾！

因此唯一性得证。 

</details>
 
2. Nicomachus定理：\\( \sum_{i=1}^{n} x_i^{3}= (\sum_{i=1}^{n} x_i)^2   \\)

# MIX

A：累加器。5字节+1符号。

X：扩充，五字节+1符号。

I：变址寄存器，I1, I2, I3, I4, I5, I6各拥有两个字节+1个符号。

J：转移地址，2字节。

一个溢出开关，一个比较指示器（三个值，大于等于小于），内存和I/O。



# 教训

1. 读一个算法不能只看，应该先对一些数据进行测试。

2. 
