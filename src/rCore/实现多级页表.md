# 虚拟地址和物理地址

## 内存控制相关的CSR寄存器

默认情况下 MMU 未被使能，此时无论 CPU 处于哪个特权级，访存的地址都将直接被视作物理地址。 可以通过修改 S 特权级的 satp CSR 来启用分页模式，此后 S 和 U 特权级的访存地址会被视为虚拟地址，经过 MMU 的地址转换获得对应物理地址，再通过它来访问物理内存。

当MODE设置为0时，所有访存被视为物理地址；而设置为8时，SV39分页机制被启用，所有S/U特权级的访存被视为一个39位的虚拟地址，MMU会将其转换为56位的物理地址；转换失败就触发异常。

![地址格式与组成](../image/virtual_address.png)

采用分页管理，单个页面大小设置为4KiB, 每个虚拟页面和物理页帧都按4KB对齐。

4KiB需要用12位字节地址来表示，因此虚拟地址和物理地址都被分成两部分：低12位被称为业内偏移。虚拟地址的高27位，也就是[38:12为他的虚拟页号VPN；物理地址的高44位，也就是[55:12]为他的物理页号PPN。页号用来定位一个虚拟/物理地址数据哪一个虚拟页面/物理页帧。

地址转换是以页为单位进行的，转换前后地址页内偏移部分不变。MMU 只是从虚拟地址中取出 27 位虚拟页号， 在页表中查到其对应的物理页号，如果找到，就将得到的 44 位的物理页号与 12 位页内偏移拼接到一起，形成 56 位物理地址。

### RV64 架构中虚拟地址为何只有 39 位？

虚拟地址长度确实应该和位宽一致为 64 位，但是在启用 SV39 分页模式下，只有低 39 位是真正有意义的。 SV39 分页模式规定 64 位虚拟地址的

这 25 位必须和第 38 位相同，否则 MMU 会直接认定它是一个 不合法的虚拟地址。。

也就是说，所有
个虚拟地址中，只有最低的 （当第 38 位为 0 时） 以及最高的 （当第 38 位为 1 时）是可能通过 MMU 检查的。

## 地址相关的数据结构抽象与类型定义

```rust
/// physical address
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysAddr(pub usize);
/// virtual address
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtAddr(pub usize);
/// physical page number
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysPageNum(pub usize);
/// virtual page number
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtPageNum(pub usize);
```

上面分别给出了物理地址、虚拟地址、物理页号、虚拟页号的 Rust 类型声明，它们都是 usize 的一种简单包装。 将它们各自抽象出来而不是直接使用 usize，是为了在 Rust 编译器的帮助下进行多种方便且安全的 类型转换 (Type Convertion) 。

这些类型本身可以和 usize 之间互相转换，地址和页号之间也可以相互转换。

```rust
// os/src/mm/address.rs

impl PhysAddr {
    pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) }
}

impl From<PhysAddr> for PhysPageNum {
    fn from(v: PhysAddr) -> Self {
        assert_eq!(v.page_offset(), 0);
        v.floor()
    }
}

impl From<PhysPageNum> for PhysAddr {
    fn from(v: PhysPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) }
}
```

其中 PAGE_SIZE 为 ， PAGE_SIZE_BITS 为 ，它们均定义在 config 子模块 中，分别表示每个页面的大小和页内偏移的位宽。从物理页号到物理地址的转换只需左移

位即可，但是物理地址需要 保证它与页面大小对齐才能通过右移转换为物理页号。

对于不对齐的情况，物理地址不能通过 From/Into 转换为物理页号，而是需要通过它自己的 floor 或 ceil 方法来 进行下取整或上取整的转换。

```rust
impl PhysAddr {
    /// Get the (floor) physical page number
    pub fn floor(&self) -> PhysPageNum {
        PhysPageNum(self.0 / PAGE_SIZE)
    }
    /// Get the (ceil) physical page number
    pub fn ceil(&self) -> PhysPageNum {
        PhysPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE)
    }
    /// Get the page offset of physical address
    pub fn page_offset(&self) -> usize {
        self.0 & (PAGE_SIZE - 1)
    }
    /// Check if the physical address is aligned by page size
    pub fn aligned(&self) -> bool {
        self.page_offset() == 0
    }
}
```

## 页表项的数据结构抽象与类型定义

![SV39分页模式下的页表项]
## 页表项的数据结构抽象与类型定义

![SV39分页模式下的页表项]
## 页表项的数据结构抽象与类型定义

![SV39分页模式下的页表项](../image/SV39Page.png)

上图为 SV39 分页模式下的页表项，其中 这 位是物理页号，最低的 位

则是标志位，它们的含义如下：

    仅当 V(Valid) 位为 1 时，页表项才是合法的；

    R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；

    U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；

    G 我们不理会；

    A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；

    D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。

先实现页表项的标志位PTEFlags: 

我们的OS运行在Sv39 RISC-V上面，对于运行在64位的虚拟地址仅仅使用其低39位，高25位是未被使用的；虚拟地址使用低39位中的高27位去索引页表去找到页表项（PTE: Page Table Entry）。其中每个页表项包含一个44位的物理页号（PPN）和一些标志位。

当OS通过PTE找到PPN后，根据其PPN去寻找其物理页号，随后根据2级索引再去找到对应的PTE提取其PPN。在经过三级索引后，我们发现最终的物理页号并将其与我们虚拟地址的低12位偏移量（offset）拼接起来成为真正的物理地址。 

```rust
// os/src/main.rs

#[macro_use]
extern crate bitflags;

// os/src/mm/page_table.rs

use bitflags::*;

bitflags! {
    pub struct PTEFlags: u8 {
        const V = 1 << 0;
        const R = 1 << 1;
        const W = 1 << 2;
        const X = 1 << 3;
        const U = 1 << 4;
        const G = 1 << 5;
        const A = 1 << 6;
        const D = 1 << 7;
    }
}
```

bitflags 是一个 Rust 中常用来比特标志位的 crate 。它提供了 一个 bitflags! 宏，如上面的代码段所展示的那样，可以将一个 u8 封装成一个标志位的集合类型，支持一些常见的集合 运算。

接着实现页表项PageTableEntry: 

```rust
#[derive(Copy, Clone)]
#[repr(C)]
/// page table entry structure
pub struct PageTableEntry {
    /// bits of page table entry
    pub bits: usize,
}

impl PageTableEntry {
    /// Create a new page table entry
    pub fn new(ppn: PhysPageNum, flags: PTEFlags) -> Self {
        PageTableEntry {
            bits: ppn.0 << 10 | flags.bits as usize,
        }
    }
    /// Create an empty page table entry
    pub fn empty() -> Self {
        PageTableEntry { bits: 0 }
    }
    /// Get the physical page number from the page table entry
    pub fn ppn(&self) -> PhysPageNum {
        (self.bits >> 10 & ((1usize << 44) - 1)).into()
    }
    /// Get the flags from the page table entry
    pub fn flags(&self) -> PTEFlags {
        PTEFlags::from_bits(self.bits as u8).unwrap()
    }
    /// The page pointered by page table entry is valid?
    pub fn is_valid(&self) -> bool {
        (self.flags() & PTEFlags::V) != PTEFlags::empty()
    }
    /// The page pointered by page table entry is readable?
    pub fn readable(&self) -> bool {
        (self.flags() & PTEFlags::R) != PTEFlags::empty()
    }
    /// The page pointered by page table entry is writable?
    pub fn writable(&self) -> bool {
        (self.flags() & PTEFlags::W) != PTEFlags::empty()
    }
    /// The page pointered by page table entry is executable?
    pub fn executable(&self) -> bool {
        (self.flags() & PTEFlags::X) != PTEFlags::empty()
    }
}
```
    第 10 行使得我们可以从一个物理页号 PhysPageNum 和一个页表项标志位 PTEFlags 生成一个页表项 PageTableEntry 实例；而第 20 行和第 23 行则分别可以从一个页表项将它们两个取出。

    第 15 行中，我们也可以通过 empty 方法生成一个全零的页表项，注意这隐含着该页表项的 V 标志位为 0 ， 因此它是不合法的。

后面我们还为 PageTableEntry 实现了一些辅助函数(Helper Function)，可以快速判断一个页表项的 V/R/W/X 标志位是否为 1，以 V 标志位的判断为例，实现了is_valid函数。相当于判断两个集合的交集是否为空。

## 物理页帧管理

### 可用物理页的分配与回收

首先，我们需要知道物理内存的哪一部分是可用的。在 os/src/linker.ld 中，我们用符号 ekernel 指明了 内核数据的终止物理地址，在它之后的物理内存都是可用的。而在 config 子模块中：

```rust
/// the physical memory end
pub const MEMORY_END: usize = 0x88000000;
```

我们硬编码整块物理内存的终止物理地址为 0x80800000 。 而物理内存的起始物理地址为 0x80000000 ， 意味着我们将可用内存大小设置为

，当然也可以设置的更大一点。

用一个左闭右开的物理页号区间来表示可用的物理内存，则：

    区间的左端点应该是 ekernel 的物理地址以上取整方式转化成的物理页号；

    区间的右端点应该是 MEMORY_END 以下取整方式转化成的物理页号。

这个区间将被传给我们后面实现的物理页帧管理器用于初始化。

我们声明一个FrameAllocator Trait来描述一个物理页帧管理器要提供哪些功能：
```rust
trait FrameAllocator {
    fn new() -> Self;
    fn alloc(&mut self) -> Option<PhysPageNum>;
    fn dealloc(&mut self, ppn: PhysPageNum);
}
```

最简单的栈式物理页帧管理策略StackFrameAllocator: 

```rust
/// an implementation for frame allocator
pub struct StackFrameAllocator {
    current: usize,
    end: usize,
    recycled: Vec<usize>,
}
```

其中各字段的含义是：物理页号区间 此前均 从未 被分配出去过，而向量 recycled 以后入先出的方式保存了被回收的物理页号。

初始化非常简单。在通过 FrameAllocator 的 new 方法创建实例的时候，只需将区间两端均设为 ， 然后创建一个新的向量；而在它真正被使用起来之前，需要调用 init 方法将自身的 初始化为可用物理页号区间：
```rust
impl FrameAllocator for StackFrameAllocator {
    fn new() -> Self {
        Self {
            current: 0,
            end: 0,
            recycled: Vec::new(),
        }
    }
}
impl StackFrameAllocator {
    pub fn init(&mut self, l: PhysPageNum, r: PhysPageNum) {
        self.current = l.0;
        self.end = r.0;
        // trace!("last {} Physical Frames.", self.end - self.current);
    }
}
```

核心的物理页帧和分配怎么实现：

```rust
impl FrameAllocator for StackFrameAllocator {
    fn alloc(&mut self) -> Option<PhysPageNum> {
        if let Some(ppn) = self.recycled.pop() {
            Some(ppn.into())
        } else {
            if self.current == self.end {
                None
            } else {
                self.current += 1;
                Some((self.current - 1).into())
            }
        }
    }
    fn dealloc(&mut self, ppn: PhysPageNum) {
        let ppn = ppn.0;
        // validity check
        if ppn >= self.current || self.recycled
            .iter()
            .find(|&v| {*v == ppn})
            .is_some() {
            panic!("Frame ppn={:#x} has not been allocated!", ppn);
        }
        // recycle
        self.recycled.push(ppn);
    }
}
```

在分配 alloc 的时候，首先会检查栈 recycled 内有没有之前回收的物理页号，如果有的话直接弹出栈顶并返回； 否则的话我们只能从之前从未分配过的物理页号区间

上进行分配，我们分配它的 左端点 current ，同时将管理器内部维护的 current 加一代表 current 此前已经被分配过了。在即将返回 的时候，我们使用 into 方法将 usize 转换成了物理页号 PhysPageNum 。

注意极端情况下可能出现内存耗尽分配失败的情况：即 recycled 为空且

。 为了涵盖这种情况， alloc 的返回值被 Option 包裹，我们返回 None 即可。

在回收 dealloc 的时候，我们需要检查回收页面的合法性，然后将其压入 recycled 栈中。回收页面合法有两个 条件：

    该页面之前一定被分配出去过，因此它的物理页号一定 

        ；

        该页面没有正处在回收状态，即它的物理页号不能在栈 recycled 中找到。

    我们通过 recycled.iter() 获取栈上内容的迭代器，然后通过迭代器的 find 方法试图 寻找一个与输入物理页号相同的元素。其返回值是一个 Option ，如果找到了就会是一个 Option::Some ， 这种情况说明我们内核其他部分实现有误，直接报错退出。

之后创建 StackFrameAllocator 的全局实例 FRAME_ALLOCATOR，并在正式分配物理页帧之前将 FRAME_ALLOCATOR 初始化，见 os/src/mm/frame_allocator.rs。

### 分配/回收物理页帧的接口

公开给其他子模块调用的分配/回收物理页帧的接口：
```rust
pub fn frame_alloc() -> Option<FrameTracker> {
    FRAME_ALLOCATOR
        .exclusive_access()
        .alloc()
        .map(FrameTracker::new)
}

fn frame_dealloc(ppn: PhysPageNum) {
    FRAME_ALLOCATOR.exclusive_access().dealloc(ppn);
}
```

可以发现， frame_alloc 的返回值类型并不是 FrameAllocator 要求的物理页号 PhysPageNum ，而是将其 进一步包装为一个 FrameTracker ，其定义如下。 FrameTracker 被创建时，需要从 FRAME_ALLOCATOR 中分配一个物理页帧：
```rust
pub struct FrameTracker {
    pub ppn: PhysPageNum,
}

impl FrameTracker {
    pub fn new(ppn: PhysPageNum) -> Self {
        // page cleaning
        let bytes_array = ppn.get_bytes_array();
        for i in bytes_array {
            *i = 0;
        }
        Self { ppn }
    }
}
```

我们将分配来的物理页帧的物理页号作为参数传给 FrameTracker 的 new 方法来创建一个 FrameTracker 实例。由于这个物理页帧之前可能被分配过并用做其他用途，我们在这里直接将这个物理页帧上的所有字节清零。这一过程并不 那么显然，我们后面再详细介绍。



    
