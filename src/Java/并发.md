<!--toc:start-->
- [线框-管道模型](#线框-管道模型)
- [CompletableFuture和结合器](#completablefuture和结合器)
- [发布-订阅以及反应式编程](#发布-订阅以及反应式编程)
- [Atomic相关](#atomic相关)
  - [CAS算法的ABA问题](#cas算法的aba问题)
  - [AtomicFieldUpdater](#atomicfieldupdater)
- [Fork-Join](#fork-join)
<!--toc:end-->

# 线框-管道模型

设计和理解并发系统最好的方式是使用图形。我们将这种技术称为线框–管道 （box-andchannel）模型 。设想一个使用整型的简单场景，我们希望对之前计算f(x)+g(x) 的例子做一个归纳。在你想要使用参数x 调用方法（或函数）p ，并将计算的结果作为参数传递给函数q1 和q2 ，接着使这两个调用的结果去调用方法（或函数）r ，然后打印结果（为了避免混乱，这里不再区分类C 的方法m以及它关联的函数C::m ）。

# CompletableFuture和结合器

Future 接口的一个问题是它是一个接口，你需要思考如何设计你的并发代码结构才能采用Future 实你的任务。不过，历史上，除了FutureTask 这一实现之外，Future 也提供了其他几个动作：创建一Future 指定它执行某个计算任务，执行任务，等待执行终止，等等。

# 发布-订阅以及反应式编程

Future 和CompletableFuture 的思维模式是计算的执行是独立且并发的。使用get() 方法可以在执行束后获取Future 对象的执行结果。因此，Future 是一个一次性 对象，它只能从头到尾执行代码一次。

与此相反，反应式编程的思维模式是类Future 的对象随着时间的推移可以产生很多的结果。

主要有三个概念：

1. 订阅者 可以订阅的发布者。
2. 名为订阅的连接。
3. 消息 （也叫事件 ），它们通过连接传输。

由于数据的流动是从发布者（生产者）流向订阅者（消费者），因此程序员经常使用诸向上流 （upstream）和向下流 （downstream）这样的术语。前面的示例代码中，向流onNext() 方法接收的数据newValue 是由notifyAllSubscribers() 方法传递给向下游onNext() 方法的。

# Atomic相关

AtomicReference使用了CAS的方式来实现，其代码通过Unsafe包的native方法提供。

原子类型用自旋+CAS的无锁操作保证了共享变量的线程安全性和原子性。

- volatile关键字保证了线程间的可见性，当某线程操作了被volatile关键字修饰的变量，其他线程可以立即看到该共享变量的变化。
- CAS算法，即对比交换算法，是由UNSAFE提供的，实质上是通过操作CPU指令来得到保证的。CAS算法提供了一种快速失败的方式，当某线程修改已经被改变的数据时会快速失败。
- 当CAS算法对共享数据操作失败时，因为有自旋算法的加持，我们对共享数据的更新终究会得到计算。

## CAS算法的ABA问题

如何避免CAS算法带来的ABA问题呢？针对乐观锁在并发情况下的操作，我们通常会增加版本号，比如数据库中关于乐观锁的实现方式，以此来解决并发操作带来的ABA问题。在Java原子包中也提供了这样的实现AtomicStampedReference<E>。

它通过为引用值增加一个stamp戳的方式来避免ABA问题的发生。

## AtomicFieldUpdater

要想使得共享数据的操作具备原子性，目前有两种方案，第一，使用关键字synchronized进行加锁；第二，将对应的共享数据定义成原子类型，比如将Int定义成AtomicInteger，其他数据类型则没有与之直接对应的原子类型，我们可以借助于AtomicReference进行封装。前者提供了互斥的机制来保证在同一时刻只能有一个线程对共享数据进行操作，所以说它是一种悲观的同步方式；后者采用CAS算法提供的Lock Free方式，允许多个线程同时进行共享数据的操作，相比较synchronized关键字，原子类型提供了乐观的同步解决方案。

AtomicFieldUpdater通过静态方法newUpdater 成功创建之后，就可以使用AtomicIntegerFieldUpdater的实例来实现对应class属性的原子性操作了。

# Fork-Join

JUC提供了一个基于Fork-Join模型的并发机制，以及其对应的RecursiveTask机制。

```java
public class App{

    // 任务类，继承 RecursiveTask（有返回值）
    static class SumTask extends RecursiveTask<Long> {
        private static final int THRESHOLD = 10_000; // 拆分阈值
        private final int[] array;
        private final int start;
        private final int end;

        SumTask(int[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
        }

        @Override
        protected Long compute() {
            int length = end - start;
            if (length <= THRESHOLD) {
                long sum = 0;
                for (int i = start; i < end; i++) {
                    sum += array[i];
                }
                return sum;
            } else {
                int mid = start + length / 2;
                // 拆分成左右两个子任务
                SumTask left = new SumTask(array, start, mid);
                SumTask right = new SumTask(array, mid, end);

                // fork 子任务
                left.fork();
                // 直接在当前线程计算右边，减少线程切换
                long rightResult = right.compute();
                long leftResult = left.join(); // 等待左任务结果

                return leftResult + rightResult;
            }
        }
    }

    public static void main(String[] args) {
        int[] data = new int[50_000_000_0];
        for (int i = 0; i < data.length; i++) {
            data[i] = 1; // 简单起见，每个元素都是 1
        }

        ForkJoinPool pool = new ForkJoinPool();
        var task = new SumTask(data, 0, data.length);

        long start = System.currentTimeMillis();
        long result = pool.invoke(task);
        long end = System.currentTimeMillis();

        System.out.println("结果: " + result);
        System.out.println("耗时: " + (end - start) + " ms");
    }
}
```

可以看出来Fork-Join模型的一个代码结构就是：

```c
mergesort(A, lo, hi):
    if lo < hi:                     // at least one element of input
        mid = ⌊lo + (hi - lo) / 2⌋
        fork mergesort(A, lo, mid)  // process (potentially) in parallel with main task
        mergesort(A, mid, hi)       // main task handles second recursion
        join
        merge(A, lo, mid, hi)
```

ForkJoinPool是一个高性能线程池。

ForkJoinPool： 线程池调度器，管理工作线程（ForkJoinWorkerThread）。

ForkJoinTask： 任务抽象。常见子类：RecursiveTask<V>（有返回值）、RecursiveAction（无返回值）。

WorkQueue： 每个工作线程维护一个双端队列（deque），存放任务。

1. 提交任务：主线程通过 pool.invoke(task) 或 pool.submit(task) 把任务放入一个工作队列。
2. 拆分任务：compute() 方法中，若任务大于阈值，调用 fork() 把子任务推入自己队列的尾端。
3. 执行任务：工作线程优先从自己队列的尾端取任务执行（LIFO，利于局部性）。执行中继续递归拆分并 fork 新任务。
4. 工作窃取 (Work Stealing)：当某个线程的队列空了，会随机窃取其它线程队列的头端任务（FIFO）。只窃取一个任务，减少锁竞争。
5. 合并结果：调用 join() 等待子任务完成并汇总结果。
