<!--toc:start-->
- [限流算法有哪些？](#限流算法有哪些)
<!--toc:end-->

# 限流算法有哪些？

1. 固定窗口限流算法：实现简单，容易理解，但是流量曲线可能不够平滑，有“突刺现象”，在窗口切换时可能会产生两倍于阈值流量的请求。

对一段固定时间窗口内的请求进行技术，如果请求数超过了阈值，则舍弃该请求；如果没有到达设定的阈值，则接受该请求，且计数+1。当时间窗口结束时，重置计数器为0。

优点是实现简单，但是会有流量吐刺的问题。

2. 滑动窗口限流算法：是对固定窗口限流算法的改进，有效解决了窗口切换时可能会产生两倍于阈值流量请求的问题。

将限流窗口内部切分成一些更小的时间片，然后再时间轴上滑动，每次滑动，滑过一个小时间片，就形成一个新的限流窗口，即滑动窗口。然后再这个滑动窗口内执行固定时间窗口算法即可。滑动窗口可以避免固定窗口出现的放过两倍请求的问题，因为一个短时间内出现的所有请求必然在一个滑动窗口内，所以一定会被滑动窗口限流。

3. 漏桶限流算法：能够对流量起到整流的作用，让随即不稳定的流量以固定的速率流出，但是不能解决流量突发的问题。

在系统看来，请求永远是以平滑的速率过来，从而起到了保护系统的作用。使用漏桶限流算法，缺点有两个：

- 即使系统资源很空闲，多个请求同时到达时，漏桶也是慢慢地一个接一个地去处理请求，这其实并不符合人们的期望。
- 不能解决流量突发的问题。

4. 令牌桶算法：漏斗算法的一种改进，不仅能够起到平滑流量的作用，还能在允许一定程度的流量突发。

令牌桶是另一种桶限流算法，模拟一个特定大小的桶，然后向桶中以特定的速度放入令牌（token），请求到达后，必须从桶中取出一个令牌才能继续处理。如果桶中已经没有令牌了，那么当前请求就被限流。如果桶中的令牌放满了，令牌桶也会溢出。放令牌的动作是持续不断进行的，如果桶中令牌数达到上限，则丢弃令牌，因此桶中可能一直持有大量的可用令牌。此时请求进来可以直接拿到令牌执行。比如设置 qps 为 100，那么限流器初始化完成 1 秒后，桶中就已经有 100 个令牌了，如果此前还没有请求过来，这时突然来了 100 个请求，该限流器可以抵挡瞬时的 100 个请求。由此可见，只有桶中没有令牌时，请求才会进行等待，最终表现的效果即为以一定的速率执行。
