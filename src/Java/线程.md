<!--toc:start-->
- [哪些状态？](#哪些状态)
  - [start方法如何启动一个线程？](#start方法如何启动一个线程)
  - [Thread和Runnable并不一样](#thread和runnable并不一样)
  - [JVM内存结构](#jvm内存结构)
  - [wait状态的线程如何进行恢复到running状态？](#wait状态的线程如何进行恢复到running状态)
  - [线程yield](#线程yield)
  - [设置线程优先级](#设置线程优先级)
    - [设置线程的上下文类加载器](#设置线程的上下文类加载器)
  - [线程interrupt](#线程interrupt)
  - [线程join](#线程join)
- [synchronized支持重入吗？如何实现的？](#synchronized支持重入吗如何实现的)
- [Java运行线程的几种方法?](#java运行线程的几种方法)
- [线程间通信](#线程间通信)
  - [单线程通信](#单线程通信)
    - [wait和sleep](#wait和sleep)
  - [多线程通信](#多线程通信)
  - [ThreadGroup](#threadgroup)
  - [hook线程](#hook线程)
<!--toc:end-->

# 哪些状态？

- new：尚未启动的线程，也就是线程创建，还未调用start方法。
- runnable：就绪状态（调用start,等待调度）+正在运行。
- blocked：等待监视器锁时，陷入阻塞状态。
- waiting：等待状态的线程正在等待另一线程执行特定的操作。
- timed_waiting：具有指定等待时间的等待状态。
- terminated：线程完成执行，终止状态。

线程对象进入RUNNABLE状态必须调用start方法，那么此时才是真正地在JVM进程中创建了一个线程，线程一经启动就可以立即得到执行吗？答案是否定的，线程的运行与否和进程一样都要听令于CPU的调度，那么我们把这个中间状态称为可执行状态（RUNNABLE），也就是说它具备执行的资格，但是并没有真正地执行起来而是在等待CPU的调度。

## start方法如何启动一个线程？

```java
public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        }
    }
}
```

核心是start0方法，也就是说start0会调用到Thread的run方法。

Thread内部有一个threadStatus变量；一个Thread只能被启动一次，线程启动后会被加入到一个ThreadGroup。

## Thread和Runnable并不一样

创建线程只能通过Thread，但是实现线程的执行单元则有1. 重写Thread的run方法； 2. 实现Runnable的run接口，并将Runnable作为Thread的构造参数。

## JVM内存结构

1. 程序计数器

程序计数器在JVM中所起的作用就是用于存放当前线程接下来将要执行的字节码指令、分支、循环、跳转、异常处理等信息。在任何时候，一个处理器只执行其中一个线程中的指令，为了能够在CPU时间片轮转切换上下文之后顺利回到正确的执行位置，每条线程都需要具有一个独立的程序计数器，各个线程之间互相不影响，因此JVM将此块内存区域设计成了线程私有的。

2. 虚拟机栈
与程序计数器内存相类似，Java虚拟机栈也是线程私有的，它的生命周期与线程相同，是在JVM运行时所创建的，在线程中，方法在执行的时候都会创建一个名为栈帧（stack frame）的数据结构，主要用于存放局部变量表、操作栈、动态链接、方法出口等。

每一个线程创建时，JVM都会创建其对应的虚拟机栈。

3. 本地方法栈

Java中提供了调用本地方法的接口（Java Native Interface），也就是C/C++程序，在线程的执行过程中，经常会碰到调用JNI方法的情况，比如网络通信、文件操作的底层，甚至是String的intern等都是JNI方法，JVM为本地方法提供的分区就是本地方法栈。这一部分也是线程私有的。

4. 堆内存

堆内存是JVM中最大的一块内存区域，被所有的线程所共享，Java在运行期间创建的所有对象几乎都存放在该内存区域，该内存区域也是垃圾回收器重点照顾的区域，因此有些时候堆内存被称为“GC堆”。

5. 方法区

方法区也是被多个线程所共享的内存区域，他主要用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据，虽然在Java虚拟机规范中，将堆内存划分为堆内存的一个逻辑分区，但是它还是经常被称为“非堆”，有时候也被称为“持久代”，这个叫法并不妥当，在HotSpot JVM中，方法区还会被细划分为持久代和代码缓存区，代码缓存区主要用于存储编译后的本地代码（和硬件相关）以及JIT（Just In Time）编译器生成的代码，当然不同的JVM会有不同的实现。

6. Java 8 元空间

在JDK1.8版本以前的内存大概都是这样划分的，但是自JDK1.8版本起，JVM的内存区域发生了一些改变，实际上是持久代内存被彻底删除，取而代之的是元空间。


## wait状态的线程如何进行恢复到running状态？

- 等待的线程被其他线程对象唤醒，notify()和notifyAll()。
- 如果线程没有获取到锁就会直接进入Waiting状态，本质上是执行了LockSupport.park()方法进入了Waiting状态，那么解锁的时候会执行LockSupport.unpark(Thread)，解除等待状态。

## 线程yield
yield是一种启发式方法，如果CPU资源不紧张就会忽略这种提醒。

yield会使线程有Running转换为Runnable状态。

## 设置线程优先级

优先级不能小于1也不能大于10。如果指定的线程优先级大于所在group的优先级，那么指定的优先级将会失效，取而代之的是group的最大优先级。

### 设置线程的上下文类加载器

1. getContextClassLoader: 获取线程上下文的类加载器，简单来说就是这个线程是由哪个类加器加载的，如果是在没有修改线程上下文类加载器的情况下，则保持与父线程同样的类加载器。
2. setContextClassLoader: 设置该线程的类加载器，这个方法可以打破JAVA类加载器的父委托机制，有时候该方法也被称为JAVA类加载器的后门。

这一个看似后门的东西实则是非常有必要的。

## 线程interrupt

使用wait/sleep/join会导致线程进入阻塞状态，而interrupt就可以打断阻塞。

## 线程join

join是一个可中断方法。

如果有其他线程执行了对当前线程的interrupt操作，它也会捕获到中断信号，并且擦除线程的interrupt标识，Thread的API为我们提供了三个不同的join方法。

join某个线程A，会使当前线程B进入等待，直到线程A结束生命周期，或者到达给定的时间，那么在此期间B线程是处于BLOCKED的，而不是A线程。

# synchronized支持重入吗？如何实现的？

synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是可重入性。

synchronized的底层是利用计算机的mutex lock实现的，每一个可重入锁都会关联一个线程ID和一个锁状态status。

当一个线程请求方法的时候，会去检查锁状态。

1. 如果锁状态是0,代表该锁没被占用，使用CAS操作获取锁，将线程ID替换成自己的线程ID。
2. 如果锁状态不是0,代表有线程在访问该方法，此时如果线程ID是自己的线程ID,如果是可重入锁，会将status自增1,然后获取到该锁，进而执行相应的方法；如果是非重入的锁，就会进入阻塞队列等待。

释放锁的时候：

1. 如果是可重入锁的，每一次退出方法，就会将status减去1,知道status的值为0,最后释放该锁。
2. 如果是非可重入锁的，线程退出方法，直接就会释放该锁。

# Java运行线程的几种方法?

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口和FutureTask
4. 使用线程池（Executor框架）

# 线程间通信

 ## 单线程通信

notify: 唤醒单个正在执行该对象wait方法的线程；如果有某个线程由于执行该对象的wait方法而进入阻塞则会被唤醒，如果没有则会忽略;被唤醒的线程需要重新获取对该对象所关联monitor的lock才能继续执行。

wait: wait方法的这三个重载方法都将调用wait（long timeout）这个方法，前文使用的wait（）方法等价于wait（0），0代表着永不超时；Object的wait（long timeout）方法会导致当前线程进入阻塞，直到有其他线程调用了Object的notify或者notifyAll方法才能将其唤醒，或者阻塞时间到达了timeout时间而自动唤醒；wait方法必须拥有该对象的monitor，也就是wait方法必须在同步方法中使用；当前线程执行了该对象的wait方法之后，将会放弃对该monitor的所有权并且进入与该对象关联的wait set中，也就是说一旦线程执行了某个object的wait方法之后，它就会释放对该对象monitor的所有权，其他线程也会有机会继续争抢该monitor的所有权。

### wait和sleep

相同点：
1. 都会是线程进入阻塞状态。
2. 都是可中断方法。

不同点：
1. wait是Object方法，sleep是Thread特有方法。
2. wait方法的执行必须在同步方法中进行，而sleep不需要。
3. 线程在同步方法中执行sleep时不会释放monitor锁，而wait方法会释放monitor锁。

## 多线程通信

1. notifyAll: 唤醒全部阻塞线程，同样的被唤醒线程需要争抢monitor锁。
2. wait set: 线程调用了某个对象的wait方法之后都会被加入与该对象monitor关联的wait set中，并且释放monitor的所有权。执行notify之后会从wait set中有一个线程移除，但是没有强制规范；notifyAll则是会把所有的线程弹出。

## ThreadGroup

interrupt一个thread group会导致该group中所有的active线程都被interrupt，也就是说该group中每一个线程的interrupt标识都被设置了。

## hook线程

线程在执行单元中是不允许抛出checked异常的，这一点前文中已经有过交代，而且线程运行在自己的上下文中，派生它的线程将无法直接获得它运行中出现的异常信息。对此，Java为我们提供了一个UncaughtExceptionHandler接口，当线程在运行过程中出现异常时，会回调UncaughtExceptionHandler接口，从而得知是哪个线程在运行时出错，以及出现了什么样的错误。
