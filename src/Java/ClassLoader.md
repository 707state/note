<!--toc:start-->
- [双亲委派机制是什么？](#双亲委派机制是什么)
  - [双亲委派的好处](#双亲委派的好处)
- [类加载器过程？](#类加载器过程)
- [实际中类加载会遇到哪些问题？](#实际中类加载会遇到哪些问题)
<!--toc:end-->

# 双亲委派机制是什么？

双亲委派机制是Java类加载器(ClassLoader)中的一种工作原理。

主要用于解决类加载过程中的安全和避免重复加载的问题。在这个机制中，类加载器之间存在层次关系，每个类加载器都有一个父加载器。当一个类需要被加载时，加载请求会从当前加载器开始，逐级向上委托给父加载器，直到根加载器(Bootstrap ClassLoader)。如果根加载器无法加载该类，那么委托链上的每个加载器都会尝试加载，直到找到合适的加载器或者无法加载为止。

## 双亲委派的好处

- 保证类的唯一性。

通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。

- 保证安全性。

由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。

- 支持隔离和层次划分。

双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。

- 简化了加载流程。

通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。

# 类加载器过程？

1. 加载：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

2. 连接：验证、准备、解析 3 个阶段统称为连接。

3. 验证：确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证

4. 准备：为类中的静态字段分配内存，并设置默认的初始值，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了

5. 解析：解析阶段是虚拟机将常量池的「符号引用」直接替换为「直接引用」的过程。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。

6. 初始化：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是执行类的构造器方法，要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。

7. 使用：使用类或者创造对象。

8. 卸载：如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 3. 类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 实际中类加载会遇到哪些问题？

主要有三种类加载器：

1. BootstrapClassloader根加载器，也就是系统类加载器，加载核心库，如rt.jar。

2. ExtensionClassloader扩展类加载器，主要加载/ext/下面的jar库。

3. AppClassloader离我们最近的类加载器，负责加载classpath下的类，开发时候我们的代码大部分由其加载。

除此之外，还有一些点：

1. 一个类是由jvm加载是通过类加载器+全限定类名确保唯一性的。

2. 双亲委派，子加载器会尽量委托给父加载器进行加载，父加载器找不到再自己加载。

3. 线程上下文类加载，为了满足spi等需求突破双亲委派机制，当高层类加载器想加载底层类时通过Thread.contextClassLoader来获取当前线程的类加载器（往往是底层类加载器）去加载类。
