# 几种写法

## 最基本方法

使用 conditional_variable 和 mutex 。

<details>

```c++
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

std::queue<int> q;
std::mutex mtx;
std::condition_variable cv;
bool done = false;

void producer() {
    for (int i = 0; i < 5; i++) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            q.push(i);
            std::cout << "Produced: " << i << "\n";
        }
        cv.notify_one();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    {
        std::lock_guard<std::mutex> lock(mtx);
        done = true;
    }
    cv.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [] { return !q.empty() || done; });

        while (!q.empty()) {
            int val = q.front();
            q.pop();
            std::cout << "Consumed: " << val << "\n";
        }
        if (done) break;
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}
```

</details>

## counting_semaphor

<details>

```c++
#include <iostream>
#include <thread>
#include <queue>
#include <semaphore>
#include <mutex>
std::queue<int> q;
std::mutex mtx;
std::counting_semaphore<10> slots(10); // 最大 10 个元素
std::counting_semaphore<10> items(0);
void producer() {
    for (int i = 0; i < 5; i++) {
        slots.acquire(); // 等待有空槽
        {
            std::lock_guard<std::mutex> lock(mtx);
            q.push(i);
            std::cout << "Produced: " << i << "\n";
        }
        items.release(); // 通知消费者
    }
}
void consumer() {
    for (int i = 0; i < 5; i++) {
        items.acquire(); // 等待有数据
        int val;
        {
            std::lock_guard<std::mutex> lock(mtx);
            val = q.front();
            q.pop();
        }
        std::cout << "Consumed: " << val << "\n";
        slots.release(); // 释放一个空槽
    }
}
int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}
```

</details>

## Promise Futuer版本

<details>

```c++
#include <iostream>
#include <thread>
#include <future>
#include <vector>

void producer(std::promise<int>&& p, int val) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    std::cout << "Produced: " << val << "\n";
    p.set_value(val);
}

void consumer(std::future<int>& f) {
    int val = f.get();
    std::cout << "Consumed: " << val << "\n";
}

int main() {
    std::vector<std::thread> producers, consumers;
    std::vector<std::promise<int>> promises(5);
    std::vector<std::future<int>> futures;

    for (auto& p : promises) futures.push_back(p.get_future());

    for (int i = 0; i < 5; i++) {
        producers.emplace_back(producer, std::move(promises[i]), i);
        consumers.emplace_back(consumer, std::ref(futures[i]));
    }

    for (auto& t : producers) t.join();
    for (auto& t : consumers) t.join();
}
```

</details>

## 环形队列

<details>


```c++
#include <iostream>
#include <thread>
#include <atomic>
#include <array>

constexpr int SIZE = 8;
std::array<int, SIZE> buffer;
std::atomic<int> head(0), tail(0);

void producer() {
    for (int i = 0; i < 5; i++) {
        int next = (head + 1) % SIZE;
        while (next == tail.load()) { /* busy wait */ }
        buffer[head] = i;
        head.store(next);
        std::cout << "Produced: " << i << "\n";
    }
}

void consumer() {
    for (int i = 0; i < 5; i++) {
        while (head.load() == tail.load()) { /* busy wait */ }
        int val = buffer[tail];
        tail.store((tail + 1) % SIZE);
        std::cout << "Consumed: " << val << "\n";
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}
```

</details>
