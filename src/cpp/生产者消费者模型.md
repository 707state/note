# 几种写法

<!--toc:start-->
- [几种写法](#几种写法)
  - [最基本方法](#最基本方法)
  - [counting_semaphor](#countingsemaphor)
  - [Promise Futuer版本](#promise-futuer版本)
  - [环形队列](#环形队列)
  - [packaged_task版本](#packagedtask版本)
<!--toc:end-->

## 最基本方法

使用 conditional_variable 和 mutex 。

<details>

```c++
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

std::queue<int> q;
std::mutex mtx;
std::condition_variable cv;
bool done = false;

void producer() {
    for (int i = 0; i < 5; i++) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            q.push(i);
            std::cout << "Produced: " << i << "\n";
        }
        cv.notify_one();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    {
        std::lock_guard<std::mutex> lock(mtx);
        done = true;
    }
    cv.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [] { return !q.empty() || done; });

        while (!q.empty()) {
            int val = q.front();
            q.pop();
            std::cout << "Consumed: " << val << "\n";
        }
        if (done) break;
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}
```

</details>

## counting_semaphor

<details>

```c++
#include <iostream>
#include <thread>
#include <queue>
#include <semaphore>
#include <mutex>
std::queue<int> q;
std::mutex mtx;
std::counting_semaphore<10> slots(10); // 最大 10 个元素
std::counting_semaphore<10> items(0);
void producer() {
    for (int i = 0; i < 5; i++) {
        slots.acquire(); // 等待有空槽
        {
            std::lock_guard<std::mutex> lock(mtx);
            q.push(i);
            std::cout << "Produced: " << i << "\n";
        }
        items.release(); // 通知消费者
    }
}
void consumer() {
    for (int i = 0; i < 5; i++) {
        items.acquire(); // 等待有数据
        int val;
        {
            std::lock_guard<std::mutex> lock(mtx);
            val = q.front();
            q.pop();
        }
        std::cout << "Consumed: " << val << "\n";
        slots.release(); // 释放一个空槽
    }
}
int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}
```

</details>

## Promise Futuer版本

<details>

```c++
#include <iostream>
#include <thread>
#include <future>
#include <vector>

void producer(std::promise<int>&& p, int val) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    std::cout << "Produced: " << val << "\n";
    p.set_value(val);
}

void consumer(std::future<int>& f) {
    int val = f.get();
    std::cout << "Consumed: " << val << "\n";
}

int main() {
    std::vector<std::thread> producers, consumers;
    std::vector<std::promise<int>> promises(5);
    std::vector<std::future<int>> futures;

    for (auto& p : promises) futures.push_back(p.get_future());

    for (int i = 0; i < 5; i++) {
        producers.emplace_back(producer, std::move(promises[i]), i);
        consumers.emplace_back(consumer, std::ref(futures[i]));
    }

    for (auto& t : producers) t.join();
    for (auto& t : consumers) t.join();
}
```

</details>

## 环形队列

<details>


```c++
#include <iostream>
#include <thread>
#include <atomic>
#include <array>

constexpr int SIZE = 8;
std::array<int, SIZE> buffer;
std::atomic<int> head(0), tail(0);

void producer() {
    for (int i = 0; i < 5; i++) {
        int next = (head + 1) % SIZE;
        while (next == tail.load()) { /* busy wait */ }
        buffer[head] = i;
        head.store(next);
        std::cout << "Produced: " << i << "\n";
    }
}

void consumer() {
    for (int i = 0; i < 5; i++) {
        while (head.load() == tail.load()) { /* busy wait */ }
        int val = buffer[tail];
        tail.store((tail + 1) % SIZE);
        std::cout << "Consumed: " << val << "\n";
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}
```

</details>

## packaged_task版本

<details>

```c++
#include <iostream>
#include <thread>
#include <vector>
#include <queue>
#include <future>
#include <mutex>
#include <condition_variable>
#include <functional>

class ThreadPool {
public:
    explicit ThreadPool(size_t threads) : stop(false) {
        for (size_t i = 0; i < threads; i++) {
            workers.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(this->mtx);
                        this->cv.wait(lock, [this] {
                            return this->stop || !this->tasks.empty();
                        });
                        if (this->stop && this->tasks.empty()) return;
                        task = std::move(this->tasks.front());
                        this->tasks.pop();
                    }
                    task(); // 执行任务
                }
            });
        }
    }

    // 提交任务，返回 future
    template<class F, class... Args>
    auto enqueue(F&& f, Args&&... args)
        -> std::future<typename std::invoke_result<F, Args...>::type> {

        using return_type = typename std::invoke_result<F, Args...>::type;
        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...)
        );
        std::future<return_type> res = task->get_future();

        {
            std::lock_guard<std::mutex> lock(mtx);
            if (stop) throw std::runtime_error("enqueue on stopped ThreadPool");
            tasks.emplace([task]() { (*task)(); });
        }
        cv.notify_one();
        return res;
    }

    ~ThreadPool() {
        {
            std::lock_guard<std::mutex> lock(mtx);
            stop = true;
        }
        cv.notify_all();
        for (std::thread &w : workers) w.join();
    }

private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex mtx;
    std::condition_variable cv;
    bool stop;
};

int main() {
    ThreadPool pool(3);

    auto f1 = pool.enqueue([] { return 42; });
    auto f2 = pool.enqueue([](int a, int b) { return a + b; }, 10, 20);

    std::cout << "Result1: " << f1.get() << "\n";
    std::cout << "Result2: " << f2.get() << "\n";

    return 0;
}
```
</details>
