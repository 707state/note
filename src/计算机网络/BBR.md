# BBR拥塞控制

TCP协议通过滑动窗口解决了Client和Server之间的问题，但是没有管理C/S之间的大量路由器、交换机转发IP报文的问题，因此在瓶颈路由器的输入流大于其输出流时就会发生拥塞。

这虽然是IP网络层的事，但如果TCP基于分层原则不去管，互联网上大量主机的TCP程序便会造成网络恶性拥堵。

## 传输速率的限制

+ 应用程序限制阶段，此时RTT不变，随着应用程序开始发送大文件，速率直线上升；
+ BDP（带宽延迟积，链路带宽乘RTT）限制阶段，此时RTT开始不断上升，但吞吐量不变，因为此时瓶颈路由器已经达到上限，缓冲队列正在不断增加；
+ 瓶颈路由器缓冲队列限制阶段，此时开始大量丢包。

路由器设备的缓冲队列越大，CUBIC算法就会造成更大的RTT时延。

BBR算法通过检测RTprop（链路的物理时延）和BtlBw（瓶颈带宽）来实现拥塞控制。

RTprop只需要找到瓶颈路由器队列为空时多次RTT测量的最小值即可，BtlBw全称是bottleneck bandwith，即瓶颈带宽，可以通过测量已发送但未ACK确认的飞行中字节除以飞行时间deliveryRate来测量。

CUBIC造成瓶颈路由器的缓冲队列越来越满，RTT时延就会越来越大，而操作系统对三次握手的建立是有最大时间限制的，这导致建CUBIC下的网络极端拥塞时，新连接很难建立成功。

## 问题来源

reno和cubic算法认为丢包和拥塞等效，但是这对于曾经网络带宽适配路由器和网络交换机的缓冲区的情况下才成立。

实际上丢包并不等效于拥塞。拥塞可以被看作是一种在网络路径中，传输中的数据量始终大于带宽-时延积的场景。

基于丢包的拥塞控制策略给网络带来了源源不断的问题：

1. 浅缓存：在浅缓存场景下，丢包往往发生在拥塞之前。高速、长距离的现代网络，搭配上消费级的浅缓存交换机，基于丢包的拥塞控制算法可能会导致极其糟糕的吞吐量，而这种现象则归咎于这类算法对于丢包的过激反应。
2. 深缓存：在有着深缓存的瓶颈链路中，拥塞往往发送在丢包之前。在现今的的边缘网络中，基于丢包的拥塞控制算法对众多最后几英里的设备，进行了深缓存的反复填充，引发了不必要的数秒级的排队延时，也就是“缓冲膨胀”的问题。

针对这些问题，BBR拥塞控制算法使用了另类的方式：不用丢包去衡量拥塞是否发生，而是直接对网络建模来避免以及应对真实的拥塞。

## 设计

BBR是基于模型的拥塞控制算法：其行为方式是对传输流通过的网络路径的确切模型的表现。BBR模型包括两个估算参数：

1. BBR.BtlBw：估计的传输通道的瓶颈带宽，估算自滑动窗口的最大传发送速率样本。
2. BBR.RTprop：估计的该路径的双向往返传播延时，估算自滑动窗口的最小往返延时样本。

BBR使用该模型来探求高吞吐量低延时的工作区。为了在最优点（即达到最大吞吐量并且维持最小延时）附近运作，该系统需要维护两个条件：

速率平衡：数据包的到达速率等于传输流的瓶颈带宽。
充盈管道：路径中处于传输状态的数据量等于BDP。

为了达到速率平衡，BBR使用pacing让数据包以接近BBR.BtlBw的速率进行发送。为了达到充盈管道，BBR对pacing rate进行调制，来保持传输中的数据量接近估算得到的带宽延时积（BDP），或BBR.BtlBw * BBR.RTprop。

BBR使用该模型去控制网络的发送行为，让其保持在目标工作区附近。与Reno和CUBIC不同的是（他们使用单一控制变量，如使用cwnd来限制传输中的数据量），BBR使用三个独特的控制参数：

1. pacing rate：BBR发送数据的速率。
2. send quantum：发送端为了均衡单包传输开销而规划的，可发送的单个包的最大集合大小，。
3. cwnd：在任意时刻，BBR允许网络中处于传输状态的数据量的最大值。

### 状态机设计

BBR使用一个清晰明了的状态机来维护三个控制参数。该状态机通过交替循环探测BBR.BtlBw和BBR.RTprop，来实现高吞吐量、低延时、近似公平的带宽共享。

BBR起始于Startup状态，该状态下会迅速提升发送速率。
+ 当预估到网络管道被填满时，则进入Drain状态，开始排放管道队列。
+ 已处于稳态的BBR流将只使用ProbeBW状态，去周期性地短暂地提升传输中的数据量，来探测更高的BBR.BtlBw样本。
+ ProbeRTT状态下（如果需要的话），会短暂地降低传输中的数据量，去探测更低的BBR.RTprop样本。

### 使用

BBR算法对于传输层和链路层来说是不可见的，其只会改变发送端的行为，而不会对网络进行改变。
