<!--toc:start-->
- [B+树相关内容](#b树相关内容)
  - [重点： 请描述一下B+树的插入/删除操作的逻辑](#重点-请描述一下b树的插入删除操作的逻辑)
  - [怎么设计一个高性能的物理上的存储](#怎么设计一个高性能的物理上的存储)
  - [B+树的性能瓶颈可能会出现在哪些地方？](#b树的性能瓶颈可能会出现在哪些地方)
  - [索引失效的情况](#索引失效的情况)
  - [表中十个字段，主键用自增ID还是UUID,为什么？](#表中十个字段主键用自增id还是uuid为什么)
  - [为什么自增ID更快一些，UUID不快吗？他在B+树中存储是有序的吗？](#为什么自增id更快一些uuid不快吗他在b树中存储是有序的吗)
- [日志](#日志)
  - [请你讲一下undo log, redo log, bin log](#请你讲一下undo-log-redo-log-bin-log)
- [事务](#事务)
  - [讲讲事务隔离级别？](#讲讲事务隔离级别)
  - [MVCC机制的原理是什么？](#mvcc机制的原理是什么)
  - [MySQL中的什么命令会加上间隙锁？](#mysql中的什么命令会加上间隙锁)
  - [事务的特性是什么？怎么实现的？](#事务的特性是什么怎么实现的)
- [Storage Engine](#storage-engine)
  - [Mysql有哪两种引擎呢？请你说一下他们的区别](#mysql有哪两种引擎呢请你说一下他们的区别)
  - [全表扫描的时候，有哪些加锁方式？](#全表扫描的时候有哪些加锁方式)
  - [如何避免全表扫描？](#如何避免全表扫描)
- [锁](#锁)
  - [MySQL的锁讲一下](#mysql的锁讲一下)
  - [mysql 主库锁表（事务未提交） 从库会跟着锁吗](#mysql-主库锁表事务未提交-从库会跟着锁吗)
- [mysql 主库锁表（事务已提交） 从库会跟着锁吗](#mysql-主库锁表事务已提交-从库会跟着锁吗)
- [MySQL如何实现如果不存在就插入否则就更新？](#mysql如何实现如果不存在就插入否则就更新)
- [数据库访问量过大怎么办？](#数据库访问量过大怎么办)
- [数据库翻页（limit）查询时，发现越往后查询越来越慢，为什么？如何修改SQL才能解决？](#数据库翻页limit查询时发现越往后查询越来越慢为什么如何修改sql才能解决)
- [执行一个语句时发生了什么？](#执行一个语句时发生了什么)
<!--toc:end-->

# B+树相关内容

## 重点： 请描述一下B+树的插入/删除操作的逻辑

## 怎么设计一个高性能的物理上的存储

1. 数据的物理存储
1.1 数据页（Page）

MySQL 的 InnoDB 存储引擎采用 页（Page） 作为基本存储单位，默认大小 16KB（可调整），一个表的数据被划分成多个页存储在 表空间（tablespace） 中。

    数据组织方式：
        聚簇索引（Clustered Index）：主键索引即数据页，叶子节点存储完整行数据。
        二级索引（Secondary Index）：索引页存储键值 + 主键，叶子节点不存储行数据，而是存储主键的指针。

2. 索引设计
2.1 B+树索引

InnoDB 采用 B+树索引 进行数据存储，特点：

    高度平衡，查询时间复杂度 O(log n)。
    叶子节点存储数据，非叶子节点仅存储索引键。
    范围查询高效，所有叶子节点通过 双向链表 连接，支持顺序扫描。

优化策略：

    避免索引过长：索引长度影响 B+树的高度，进而影响查询效率。合理使用 前缀索引 。
    覆盖索引：如果查询的字段都包含在二级索引中，无需回表，提高查询速度。

2.2 哈希索引（Memory 引擎）

    仅支持 等值查询，不支持范围查询。
    访问复杂度 O(1)，但不适用于大部分通用数据库。

2.3 自适应哈希索引（AHI）

    InnoDB 在运行时会自动对热点数据构建哈希索引，优化查询性能。

3. 存储优化策略
3.1 物理页管理

    缓冲池（Buffer Pool）：MySQL 采用 LRU（最近最少使用）算法 缓存数据页，提高查询速度。
    自适应 Flushing 机制：优化数据页的刷盘时机，避免磁盘 I/O 突增。

3.2 顺序 I/O 优化

    索引组织表（IOT）：聚簇索引确保数据存储顺序与主键顺序一致，减少磁盘随机访问。
    Redo Log + WAL 机制：先写日志再写磁盘，提高事务处理性能。

3.3 压缩存储

    InnoDB 压缩页（如 8KB、4KB），减少 I/O，提高性能。

4. 索引选择与应用

    OLTP 场景（事务型数据库）
        使用 B+树索引，主键自增，减少页面分裂。
        使用 覆盖索引，减少回表查询。

    OLAP 场景（分析型数据库）
        MySQL 不是最优选择，通常采用 列存储（如 ClickHouse）。
        但 MySQL 可以使用 分区表、压缩索引 等优化查询。


## B+树的性能瓶颈可能会出现在哪些地方？

结合B+树的结构，比如：层数太高，导致I/O开销大；节点合并/分裂；写密集的场景；高并发下的写扩散。

## 索引失效的情况

- 使用左或者左右模糊匹配的时候，也就是like %xx 或者like %xx%都会造成索引失效
- 对索引列使用函数
- 对索引列进行表达式计算
- MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引需要遵循最左匹配原则，否则会导致索引失效。

## 表中十个字段，主键用自增ID还是UUID,为什么？

自增ID。

因为 uuid 相对顺序的自增 id 来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以 innodb 无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。

这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：

- 写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb 在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机 IO。
- 因为写入是乱序的，innodb 不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，影响性能。
- 由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片。

## 为什么自增ID更快一些，UUID不快吗？他在B+树中存储是有序的吗？

自增的主键的值是顺序的，所以 Innodb 把每一条记录都存储在一条记录的后面，所以自增 id 更快的原因：

- 下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费。
- 新插入的行一定会在原有的最大数据行下一行，mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗。
- 减少了页分裂和碎片的产生。

但是 UUID 不是递增的，MySQL 中索引的数据结构是 B+Tree，这种数据结构的特点是索引树上的节点的数据是有序的，而如果使用 UUID 作为主键，那么每次插入数据时，因为无法保证每次产生的 UUID 有序，所以就会出现新的 UUID 需要插入到索引树的中间去，这样可能会频繁地导致页分裂，使性能下降。

而且，UUID 太占用内存。每个 UUID 由 36 个字符组成，在字符串进行比较时，需要从前往后比较，字符串越长，性能越差。另外字符串越长，占用的内存越大，由于页的大小是固定的，这样一个页上能存放的关键字数量就会越少，这样最终就会导致索引树的高度越大，在索引搜索的时候，发生的磁盘 IO 次数越多，性能越差。

# 日志

## 请你讲一下undo log, redo log, bin log

# 事务

## 讲讲事务隔离级别？

## MVCC机制的原理是什么？

## MySQL中的什么命令会加上间隙锁？

在可重复读隔离级别下：

- 使用非唯一索引进行查询时，InnoDB可能会在索引间隙加上间隙锁，例如SELECT * FROM t WHERE a = ? FOR UPDATE。如果a是非唯一索引，MySQL会在该值的前后加上间隙锁，以防止其他事务在这些间隙插入新纪录。
- 在执行带有WHERE条件的DELETE语句时，如果使用的是非唯一索引，MySQL会在符合条件的记录的前后加上间隙锁。
- 类似地，在执行带有WHERE条件的UPDATE语句时，如果使用的是非唯一索引，MySQL也会在符合条件的记录的前后加上间隙锁。

## 事务的特性是什么？怎么实现的？

- 持久性是通过redo log实现的。
- 一致性是通过持久性+原子性+隔离性实现的。
- 原子性是通过undo log实现的。
- 隔离性是通过MVCC实现的。

# Storage Engine

## Mysql有哪两种引擎呢？请你说一下他们的区别

1. 索引结构：InnoDB聚簇索引，MyISAM是非聚簇索引。
2. 锁粒度。
3. 事务。
4. count的效率。

## 全表扫描的时候，有哪些加锁方式？

结合读方式（快照读，当前读）和隔离级别（读已提交，可重复读，串行化）。

（1）读已提交（Read Committed）

    锁定读：只对扫描到的行加记录锁，不加间隙锁。

    非锁定读：读取已提交的最新快照数据。

（2）可重复读（Repeatable Read）

    锁定读：对扫描到的行加临键锁（Next-Key Lock），锁定行及其前后的间隙。

    非锁定读：读取事务开始时的快照数据。

（3）串行化（Serializable）

    所有读操作都会隐式转换为 SELECT ... LOCK IN SHARE MODE，对扫描到的行加临键锁。

## 如何避免全表扫描？

建立索引（哪些字段建立索引）？


# 锁

## MySQL的锁讲一下

## mysql 主库锁表（事务未提交） 从库会跟着锁吗

在 MySQL 主从复制架构中，主库的锁表（如事务未提交导致的锁）不会直接导致从库也锁表。但具体行为取决于锁的类型和主从复制的机制，以下是关键细节：
1. 主从复制的核心机制

    主库通过二进制日志（binlog）记录数据变更（DML/DDL）。

    从库通过 IO 线程拉取 binlog，并由 SQL 线程重放这些操作，实现数据同步。

    主库的锁信息不会传递到从库，锁是各实例内部的资源控制机制。

2. 事务未提交时主从库的行为

    主库未提交的事务：

        事务未提交时，binlog 不会立即写入（取决于事务提交策略，如 innodb_flush_log_at_trx_commit）。

        从库不会收到未提交事务的 binlog 事件，因此从库不会执行该事务，也不会因此产生锁。

    主库提交后：

        事务提交后，binlog 才会写入并传输到从库。

        从库的 SQL 线程会重放该事务，此时从库会按事务逻辑自行加锁（如行锁、表锁），但锁的持有时间通常极短（仅重放期间）。

3. 显式锁表（如 LOCK TABLES）

    若主库执行 LOCK TABLES ... WRITE：

        默认情况下，LOCK TABLES 语句不会复制到从库。

        主库的显式锁表不会影响从库，从库仍可正常处理其他查询。

        例外：若强制在从库执行相同锁表操作（需特殊配置），但通常不推荐。

4. 潜在间接影响

    主库长时间未提交事务：

        可能导致主库后续 DML 操作阻塞（如被行锁阻塞），从而延迟 binlog 的生成。

        从库可能因 binlog 接收延迟出现复制延迟（Replication Lag），但并非因为从库被锁，而是数据同步变慢。

    DDL 操作（如 ALTER TABLE）：

        主库执行 DDL 时默认会隐式提交事务，并可能短暂锁表。

        DDL 通过 binlog 复制到从库后，从库会独立执行相同的 DDL，可能导致从库短暂锁表（与主库行为一致）。

5. 总结
场景	主库行为	从库行为
主库事务未提交	事务未提交，可能持有锁	无关联事务，无锁
主库提交事务	生成 binlog	重放事务，短暂加锁（自动提交）
主库显式锁表（LOCK TABLES）	锁表	不复制锁表语句，无锁
主库执行 DDL	锁表并修改结构	独立执行 DDL，可能短暂锁表
结论

    主库的锁不会直接导致从库锁表。

    从库的锁仅由其自身重放的事务或查询产生，与主库锁无关。

    主库事务未提交时，从库不会处理该事务，因此不会因此阻塞。

# mysql 主库锁表（事务已提交） 从库会跟着锁吗

在 MySQL 主从复制架构中，主库事务提交后引发的锁表行为是否会导致从库锁表，取决于锁表的具体原因和操作类型。以下是关键分析：
1. 事务提交后的锁表场景

    主库事务已提交意味着：

        事务的变更已写入 binlog 并传输到从库。

        主库在事务提交后，事务内持有的锁（如行锁）会自动释放，不会继续锁表。

    如果主库在事务提交后仍然锁表，可能是由以下操作引起：

        显式锁表（如 LOCK TABLES ... WRITE）。

        DDL 操作（如 ALTER TABLE、DROP TABLE）。

        长时间查询或未提交的事务（但事务已提交则与此无关）。

2. 不同锁表操作对从库的影响
(1) 显式锁表（LOCK TABLES）

    主库行为：

        执行 LOCK TABLES ... WRITE 会直接锁表，阻止其他会话写入。

        即使事务已提交，锁表操作是独立于事务的，需显式调用 UNLOCK TABLES 释放。

    从库行为：

        LOCK TABLES 默认不会通过 binlog 复制到从库。

        从库不会执行相同的锁表操作，因此不会因此锁表。

(2) DDL 操作（如 ALTER TABLE）

    主库行为：

        DDL 操作（如修改表结构）会隐式提交当前事务，并在执行期间短暂锁表（如元数据锁）。

    从库行为：

        DDL 操作会通过 binlog 复制到从库，从库会独立执行相同的 DDL。

        从库执行 DDL 时，也会短暂锁表（与主库行为一致），但锁表时间通常较短。

(3) 其他操作（如大查询）

    若主库在事务提交后执行一个耗时查询（如全表扫描），可能持有元数据锁或 InnoDB 读锁。

    从库行为：

        此类操作不会直接导致从库锁表，但主库的性能问题可能间接导致复制延迟（从库需等待主库的 binlog 事件）。

3. 主从复制的核心逻辑

    主库的锁是实例级别的，不会通过 binlog 传递到从库。

    从库的锁由其自身重放的 SQL 语句或本地查询产生，与主库无关。

    例外：DDL 操作会复制到从库，导致从库独立加锁。

4. 总结表
场景	主库行为	从库行为
主库显式锁表（LOCK TABLES）	锁表，需显式释放	不复制锁表操作，无锁
主库执行 DDL	隐式提交事务并短暂锁表	复制 DDL，独立执行并短暂锁表
主库执行大查询	可能持有元数据锁或读锁	无直接影响，可能因复制延迟间接影响
5. 结论

    主库事务提交后的锁表行为（如显式 LOCK TABLES）不会直接导致从库锁表。

    DDL 操作（如 ALTER TABLE）会通过 binlog 复制到从库，导致从库执行相同的 DDL 并短暂锁表。

    从库的锁表仅由自身操作引起，与主库的锁表无直接关联。


# MySQL如何实现如果不存在就插入否则就更新？

使用
```sql
insert ... on duplicate key update
```

# 数据库访问量过大怎么办？

# 数据库翻页（limit）查询时，发现越往后查询越来越慢，为什么？如何修改SQL才能解决？

原因是，当Limit X,Y时，数据库必须跳过X数量的行，就意味着可能需要完全扫描前面的行，从而导致查询变慢。

解决方法：考虑使用基于主键的分页。

# 执行一个语句时发生了什么？
