#+title: 操作系统期末复习
#+author: jask
#+LATEX_COMPILER: xelatex
#+LaTeX_HEADER: \usepackage{ctex}
#+LATEX_HEADER: \setmainfont{Noto Serif CJK SC}
#+LATEX_HEADER: \usepackage[a4paper,margin=1in]{geometry}
#+OPTIONS: toc:nil
#+mathspec: true

* 死锁
*死锁发生的条件* ：
1. 互斥条件：
     指进程的共享资源必须保持使用的互斥性，即任何一个时刻只能分配给一个进程使用，互斥条件是形成死锁最根本的原因，因为如果资源不要求排它性地使用，那么一定不会造成请求资源而无法满足的局面。
2. 占有且等待条件：
   一个进程占有了某些资源之后又要申请新的资源而得不到满足时，处于等待资源的状态，且不释放已经占用的资源。
3. 不可剥夺条件:
     任何进程不能抢夺另一个进程所占用的资源，即已经被占用的资源只能由占用进程自己来释放。
4. 环路条件:
   存在一组进程P1,P2,…,Pn，其中每个进程分别等待另一个进程所占用的资源，形成环路等待条件。

*处理死锁的三大策略* ：
+ 可以使用各种方法预防或者避免死锁，以便确保系统不会进入死锁状态。
+ 不采取措施，可以允许系统进入死锁状态，定期检测，如果有死锁发生，解除死锁状态并恢复其他进程的正常执行。
+ 认为系统不会发生死锁，这是典型的鸵鸟策略，Linux系统就是采用的该策略。

** 死锁预防
+ 破坏互斥：在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。
+ 禁止占用且等待：
  1. 所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。 
  2. 该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。
+ 废除不可抢占条件：
  1. 如果占有某些资源的一个进程进行进一步资源请求被拒绝，则进程必须释放它最初占有的资源，如有必要，可再次请求这些资源。
  2. 如果一个进程请求当前另一个进程占有的一个资源，则操作系统可以允许抢占另一个进程，要求它释放资源。
+ 破坏循环等待条件：
  循环等待条件可以通过定义资源类型的线性顺序来预防。首先我们可以将每类资源排好顺序，然后当进程在请求资源时，只能按照某种顺序请求不同类型的资源 。

** 死锁避免
+ 通过相应的算法来进行选择，确保系统永远不会到达死锁点，因此死锁避免比死锁预防允许进程更高的并发性。

_系统的安全状态和不安全状态。考虑一个系统，它有固定数量的进程和固定数量的资源，任何时候，一个进程可能分配到零个资源或多个资源，系统的状态是当前分配给进程的资源状况。_

*** 思考题
*某系统有同类资源 m  个，n  个并发进程可共享该类临界资源。* 
*求 ：每个进程最多可申请多少个该类临界资源，保证系统一定不会发生死锁。*

#+BEGIN_EXAMPLE
设每个进程最多申请该类资源的最大量为x。
     则n个进程最多同时申请的该类临界资源数为：n*x。
为保证系统不会发生死锁，应满足下列不等式：
                              n(x-1)+1≤m （*）
     则系统一定不会发生死锁。这是因为进程最多申请x个资源，最坏的情
况是每个进程都已得到了(x-1)个资源，现均申请要最后一个资源。只要系
统至少还有一个资源就可使其中一个或几个进程得到所需的全部资源，在
它们执行结束后归还的资源可供其他进程使用，因而不会发生死锁。
       解不等式（*），可得：
                             x≤1+[(m-1)/n]
即：x的最大值为1+[(m-1)/n]。因而，当每个进程申请资源的最大数值为
1+[(m-1)/n]时，系统肯定不会发生死锁。
#+END_EXAMPLE

*** 银行家算法总结

+ 必须事先声明每个进程的最大资源获取量
+ 进程之间必须是无关的，即进程之间的执行顺序没有任何的同步要求。
+ 系统中可供分配的资源数目必须是固定的
+ 进程在占有资源的，不能退出。

** 死锁检测

#+BEGIN_EXAMPLE
检测死锁的基本思路是：系统保存资源请求和分配信息，利用某种算法对这些信息加以检查，以判断系统是否出现了死锁。
#+END_EXAMPLE

+ 对单体资源类的死锁检测
+ 对于多体资源类的死锁检测

* 处理器调度

衡量指标：
+ CPU使用率
+ 吞吐量
+ 周转时间
+ 等待时间
+ 响应时间

** 调度策略的类别：
+ *非抢占式调度*
一旦进程处于运行状态，它不断运行，直到运行结束或运行至阻塞时进行调度，即，当运行进程主动释放CPU时，才执行调度程序。
+ *抢占式调度*
当前正在运行的程序可能被系统中断，转为就绪态。抢占的发生可能是在一个高优先级进程到达时，或在一个中断发生后，一个阻塞的进程变为就绪时，或者基于周期性的时间中断（时间片）。

[[file:~/codes/Stuff/src/image/schedule.png]]

** 多处理器调度

+ 对于多处理器，CPU调度的一种方法是让一个处理器（主处理器）处理所有调度决定、I/O处理以及其他系统活动，其他处理器只执行用户代码。这个方称为非对称多处理(asymmetric multiprocessing)，这种方法只有一个处理器访问系统数据结构，减少了数据共享的需要。

+ 另外一种方法是使用对称多处理(sysmmetric multiprocessing, SMP)，即每个处理器自我调度。所有进程可能处在一个共同的就绪队列中，也可能每个处理器都有自己私有的就绪队列。无论怎样，每个处理器的调度程序都检查共同就绪队列，以便选择执行一个进程。我们以下讨论主要针对SMP系统。
** 处理器调度算法

+ 先来先服务FCFS
  总的来说，FCFS调度算法实现简单，但它对短进程不利。
  FCFS调度算法有时候还会产生“护航效应”
[[file:~/codes/Stuff/src/image/FCFS.png]]
  
+ 优先级调度算法
  由用户或系统事先按某个原则给进程一个优先级，系统总是调度优先级最高的那个进程运行。

[[file:~/codes/Stuff/src/image/PS.png]]

+ 最短作业优先调度SJF非抢占式
  避免FCFS算法对短进程不利的选择是最短进程优先策略。调度时，它在就绪队列中选择估计处理时间最短的进程。
[[file:~/codes/Stuff/src/image/SJF.png]]

+ 最短作业优先调度SJF抢占式
  当一个新进程到达就绪队列时，操作系统会激发调度程序，针对当前就绪队列中的进程的最新情况进行选择。如果新进程的CPU 执行时间比与当前运行进程的尚未完成的 CPU 执行时间还要小，则抢占当前运行进程。
[[file:~/codes/Stuff/src/image/SJF_I.png]]

+ 最高响应比优先调度算法

    最高响应比优先（NRN）是对FCFS和非抢占SJF策略的优化组合。FCFS只考虑了进程的等待时间，而非抢占SJF只考虑了执行时间。而HRN策略既考虑了等待时间，又考虑了进程的预计执行时间。用响应比R来表征，即

    R=（W+S）/S，其中，W为等待时间，S为预计的执行时间。

[[file:~/codes/Stuff/src/image/HRS.png]]

+ 轮转调度算法
  调度程序按就绪队列中进程的顺序依次调度进程运行，每个进程每次运行一个时间片，时间片结束时，正在运行的进程对CPU的拥有权被剥夺，状态由运行转为就绪，重新排在就绪队列末尾等待下一次调度，CPU被分配给下一个就绪进程。

[[file:~/codes/Stuff/src/image/RR.png]]

+ 多级反馈轮转调度算法
  多级反馈轮转调度算法是对简单轮转算法的改进，它将就绪的进程放入不同优先级的就绪队列中，每个就绪队列按FCFS机制进行调度，调度程序首先调度具有高优先级的就绪队列中的进程，只有当较高优先级就绪队列为空时，才转向调度较低优先级就绪队列中的进程。

** 实时调度

+ 实时系统与其它系统最大的区别在于，系统的正确性不仅取决于计算的逻辑结果，而且依赖于产生结果的时间。

- 软实时任务：
  希望能满足最后期限，但对最后期限的要求不是强制的，即使超过了这个期限，任务的完成也是有意义的。
- 硬实时任务：
  必须满足最后期限，否则会带来灾难性后果或致命性错误。
+ 时限调度算法
  周期性的任务：要求任务“每隔周期T一次”，常用抢占式调度方式。
  非周期性的任务：有一个必须开始或结束的最后期限，常用非抢占式调度方式。

_实时操作系统更强调的是实时任务能在最有价值的时间开始（或结束），而不是单纯的追求速度_


* 磁盘调度

磁盘读取数据时：
    1）首先必须找到柱面，即磁头需要移动对准相应磁道，这个过
     程叫做寻道，所耗费时间叫做寻道时间，
    2）然后目标扇区旋转到磁头下，即磁盘旋转将目标扇区旋转到
     磁头下。这个过程耗费的时间叫做旋转时间。

也就是说，一次访盘请求由三部分组成：
磁盘读写时间=寻道时间+延迟时间+传输时间 

+ 寻道
+ 旋转延迟
+ 数据传输
** 磁盘调度算法

+ FCFS调度
 FCFS算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法。

[[file:~/codes/Stuff/src/image/DiskSchedule.png]]

该算法简单，但是效率不高，相邻两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利

该算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往接近于随机调度。

+ SSTF调度
SSTF 算法选择处理距离当前磁头位置的最短寻道时间的请求。

[[file:~/codes/Stuff/src/image/SSTF.png]]

+ Scan调度
SCAN 算法有时称为电梯算法，因为磁头的行为就像大楼里面的电梯，先处理所有向上的请求，然后再处理相反方向的请求。
[[file:~/codes/Stuff/src/image/Scan.png]]

+ C-Scan调度
循环扫描（C-SCAN）调度是 SCAN 的一个变种，C-SCAN 移动磁头从磁盘一端到磁盘另一端，并且处理行程上的请求。然而，当磁头到达另一端时，它立即返回到磁盘的开头，而并不处理任何回程上的请求

[[file:~/codes/Stuff/src/image/C-Scan.png]]

+ Look算法
SCAN 和 C-SCAN 在磁盘的整个宽度内移动磁臂。更常见的是，磁臂只需移到一个方向的最远请求为止。遵循这种模式的 SCAN 算法和 C-SCAN 算法分别称为LOOK和C-LOOK调度

v[[file:~/codes/Stuff/src/image/Look.png]]

** 算法选择

SSTF 是常见的，并且具有自然的吸引力，因为它比 FCFS 具有更好的性能。

对于磁盘负荷较大的系统，SCAN 和 C-SCAN 表现更好，因为它们不太可能造成饥饿问题

SSTF 或 LOOK 是默认算法的合理选择。

#+BEGIN_EXAMPLE
被分成4个扇区。若逻辑记录的大小与扇区大小一致，柱面、磁道、扇区的编号均从“0”开始，
现用字长为16位的200个字(0字～199字)组成位示图来指示磁盘空间的使用
情况。请问：
 
(1)文件系统发现位示图中15字、7位为0而准备分配给某一记录时，该记录会
存放到磁盘的哪一块上?此块的物理位置(柱面号，磁头号和扇区号)如何? 

(2)删除文件时要归还存储空间，56柱面6磁道3扇区的块就变成了空闲块，
此时，位示图中几字几位应由1改为0?

#+END_EXAMPLE

答案：

1.
#+BEGIN_EXPORT latex
 
\[ 块号=15 \times 字长 + 位数 = 15 \times 16 + 7 = 247 \]


\[ 柱面号=块号/每柱面扇区数=247/(4 \times 8)=7 \]

\[ 磁头号=(块号 \mod 每柱面扇区数)/每盘面扇区数=(247 \mod 32)/4=5 \]

\[ 扇区号= (块号 \mod 每柱面扇区数) \pmod{每盘面扇区数}=(247 \mod (4 \times 8)) \pmod{4} = 3 \]
#+END_EXPORT
因此该记录在247块上，在7号柱面5号磁头3号扇区
2.
#+BEGIN_EXPORT latex
\[ 块号=柱面号 \times 每柱面扇区数+磁头号 \times 每盘面扇区数+扇区号=56 \times (8 \times 4)+6 \times 4 + 3=1819 \]
\[ 字号=块号 / 字长=1819 / 16 = 113 \]
\[ 位号 = 块号 \mod 字长 = 1819 \mod 16 =11 \]
#+END_EXPORT
所以位示图中113字11位应由1变成０。

