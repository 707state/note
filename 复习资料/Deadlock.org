#+title: 进程相关内容
#+author: jask
#+LATEX_COMPILER: lualatex                         
#+LaTeX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmainfont{Noto Serif CJK SC}    
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}  
#+OPTIONS: toc:nil                                 
#+mathspec: true                              
* 进程相关内容
** 进程互斥
（1）互斥：一次最多一个进程能够进入临界区，当有进程在临界区执行时，其它进程若想要进入临界区，则需要等待。

（2）有限等待：不能让一个进程无限制地在临界区内执行，即任意进入临界区的进程必须在有限时间内退出临界区。

（3）空闲让进：如果某进程退出临界区，而有其它进程正在等待进入临界区时，应当让这个进程进入。

+ 适用硬件实现互斥
1. *中断禁用* 

作用：
保证了临界区不会发生中断，所以可以保证进程在进入临界区后不会被打断执行，因此有效地实现了互斥。

缺点：1）该方法的代价太高，由于禁止了中断，系统执行的效率会有明显的降低。

2）该方法不能用于多处理器结构

2. *专用机器指令*

#+BEGIN_SRC C

//使用了compare_and_swap指令实现互斥的例程：

const   int  n=N;    /*进程个数*/
int lock;//共享变量
void  process(int i)
{  
while (true)
   {
        while(compare_and_swapWait(lock,0,1)==1);    /*不做任何事*/
        /*临界区*/；
   lock=0;
}
  }
  void main()
  {  
   lock=0;
   parbegin(process(1),process(2),…,process(n));
  }

#+END_EXAMPLE

优点：
适用范围广。适用于在单处理器或共享内存的多处理器上的任意数目进程。
使用简单。指令设置简单，容易验证其正确性。
可支持多个临界区。

缺点：
导致CPU空耗。当一个进程等待进入临界区时，会不断地持续检测，消耗处理器时间。
导致饥饿进程。由于各种原因，当有多个进程都在等待进入临界区时，在某些极端情况下有可能某个进程永远无法进入临界区，发生饿死现象。

3. *信号量实现互斥*

并发进程A与进程B共享一个缓冲区，假设缓冲区大小为N（最多可同时存放N个数据），A进程将数据存入缓冲区，而B进程从缓冲区中将数据取出。此时两个进程的推进会受到某种关系的制约

** 进程之间通信

+ *共享内存方式*
  共享内存的实现步骤：1.创建共享内存区，通过shmget实现。在物理内存中开辟一块共享内存区。2.把这块共享内存区挂接映射到两个进程的地址空间上，通过shmat实现。3.完成通信之后，撤销内存映射关系，通过shmdt进行脱离。4.删除共享内存区，通过shmctl实现。
+ *管道通信*
  管道通信机制必须提供以下几个方面的协调能力：

- 互斥。当一个进程正在对管道进行读或写操作时，另一个进程必须等待。
- 同步。管道的大小是有限的。所以当管道满时，写进程必须等待，直到读进程把他唤醒为止。同理，当管道没有数据时，读进程也必须等待，直到写进程将数据写入管道后，读进程才被唤醒。
确认对方是否存在。只有确认对方存在时，才能进行通信。
+ *消息传递通信*
          在消息传递系统中，进程之间的数据交换以消息为单位，根据实现方式的不同又可以分为直接通信方式和间接通信方式。

        在直接通信方式中，发送进程直接将消息发送给接收进程，接收进程可以接受来自任意发送方的消息，并且在读出消息的同时得知发送者是谁。

        在间接通信方式中，消息不是直接从发送方发送到接收方，而是发送到临时消息队列（即信箱）。这种方式在使用上有很大的灵活性，发送发和接收方的关系可以是一对一、多对一、一对多和多对多的关系。
+ *邮箱通信*
  若干进程都可以向同一个进程发送信件，接收信件的进程可以设立一个信箱。信箱的大小决定了信箱中可以容纳的信件数。信箱由“信箱说明”和“信箱体”两部分组成。

** 管程

一个管程定义了一个数据结构和在该数据结构上能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。管程在结构上由以下三部分组成：
1）管程所管理的共享数据结构，这些数据结构是对应临界资源的抽象。
2）建立在该数据结构上的一组操作。
3）对上述数据结构进行初始化的语句。

* 死锁

    可以把死锁定义为一组进程相互竞争系统资源而形成的“永久”阻塞现象。
   当一组进程中的每个进程都在等待某个事件，而只有在这组进程中的其它
   被阻塞的进程才可以触发该事件，这时就称这组进程发生死锁。

** 资源分配图

[[file:~/codes/Stuff/src/image/ResAlloc.png]]

** 死锁的条件

（1）互斥条件。
              指进程的共享资源必须保持使用的互斥性，即任何一个时刻只能分配给一个进程使用，互斥条件是形成死锁最根本的原因，因为如果资源不要求排它性地使用，那么一定不会造成请求资源而无法满足的局面。
（2）占有且等待条件。
              一个进程占有了某些资源之后又要申请新的资源而得不到满足时，处于等待资源的状态，且不释放已经占用的资源。
（3）不可剥夺条件。
             任何进程不能抢夺另一个进程所占用的资源，即已经被占用的资源只能由占用进程自己来释放。
（4）环路条件。
             存在一组进程P1,P2,…,Pn，其中每个进程分别等待另一个进程所占用的资源，形成环路等待条件。

*** 死锁处理方法

可以使用各种方法预防或者避免死锁，以便确保系统不会进入死锁状态。

不采取措施，可以允许系统进入死锁状态，定期检测，如果有死锁发生，解除死锁状态并恢复其他进程的正常执行。

认为系统不会发生死锁，这是典型的鸵鸟策略，Linux系统就是采用的该策略。



