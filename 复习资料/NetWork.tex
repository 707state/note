% Created 2025-01-13 Пн 14:20
% Intended LaTeX compiler: xelatex
\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{ctex}
\usepackage{amsmath}
\setmainfont{Noto Serif CJK SC}
\usepackage[a4paper,margin=0.5in]{geometry}
\author{jask}
\date{\today}
\title{计算机网络}
\hypersetup{
 pdfauthor={jask},
 pdftitle={计算机网络},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.7.17)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{3}
\tableofcontents

\section{计算机网络基础部分}
\label{sec:org73063d1}
\subsection{协议和服务的区别}
\label{sec:orgd7964cd}
\begin{itemize}
\item 协议：
\begin{itemize}
\item 语法： 交换的信息的格式
\item 语义： 发送者或接收者所要完成的操作，即需要发出何种控制信息，完成何种动作以及做出何种响应
\item 同步： 收发双方的时序关系，时间实现顺序的详细说明
\end{itemize}
\item 服务： 是纵向的底层到上层提供服务。
但服务是 “垂直的”,即服务是下层通过层间接口向上层提供的。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语。
\item 协议和服务的区别：
\begin{itemize}
\item 协议的实现保证了能够像上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。
\item 协议是 “水平的”，即协议是控制两个对等实体之间交换的帧、报文、分组的格式和意义的规则，实体利用协议来实现他们的服务定义。
\item 服务通过协议完成，协议通过服务体现；比喻：服务代表功能、能力；协议代表标准化或者规则。
\end{itemize}
\end{itemize}
\subsection{TCP/IP协议}
\label{sec:org6438e2e}
\begin{itemize}
\item TCP/IP的分层
\begin{enumerate}
\item 应用层：只需要专注于给用户提供应用功能，如HTTP, FTP, Telnet, DNS等。
应用层不关心数据是如何传输的，并且在操作系统的用户态运行，传输层及以下在操作系统内核态运行。
\item 传输层：为应用层提供网络支持，有TCP和UDP两个传输协议。
TCP：Transmission Control Protocol, 拥有注入流量控制、超时重传、拥塞控制等特性。
UDP：只负责发送数据包，不确保是否能够抵达，实时性相对较好，传输效率更高，也可以实现可靠传输。

应用传输的数据可能会很大，直接传输不好控制，当数据包的大小超过MSS时，就需要将数据包分块，这样即使丢失了一个分块也只需要重新发送这一个分块，不需要重新发送整个数据包，每一个分块叫做一个TCP段。
\item 网络层：网络层负责将一个数据的设备传输给另一个设备，起到实际的传输功能。
最常用的是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过MTU(以太网中一般为1500字节)就会再次分片，得到一个即将发送到网络的IP报文。
IP地址分成两种意义：
\begin{itemize}
\item 网络号：负责标识该IP地址数据哪个子网；
\item 主机号：负责标识同一子网下的不同主机；
\end{itemize}
怎么区分就需要用到子网掩码。
比如10.100.122.0/24,后面的/24就是255.255.255.0子网掩码一共24个1。
知道了子网掩码就可以将10.100.122.0 与 255.255.255.255进行位运算，a就可以得到网络号：10.100.122.0。
将255.255.255.255取反后与IP地址进行与运算就可以得到主机号。
在寻址过程中，先匹配到相同的网络号（标识找到同一个子网），才回去找对应的主机。
IP协议的另一个作用就是路由。路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。
\textbf{IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。}
\item 网络接口层：在网络层生成了IP头部u之后哦，需要在Link Layer(网络接口层)在IP头部加上MAC头部并封装成数据帧发送到网络上。
以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。
MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。
所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。
综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-19-42-24_3840x1080.png}
\end{center}
\end{enumerate}
\end{itemize}
\subsection{思考题：键入网址到网页显示发生的事情？}
\label{sec:orga99b5a4}
\begin{enumerate}
\item \textbf{第一步HTTP}
浏览器首先解析URL,生成要发送的请求信息。解析后就获得Web服务器和文件名，然后要生成请求信息。
\item \textbf{第二步DNS服务器}
通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。

但在发送之前，还有一项工作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。
DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。
在域名中，越靠右的位置表示其层级越高。
\uline{域名解析流程}:
客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。
\item \textbf{第三步协议栈}
通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。
协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。
协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。
协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。
\begin{itemize}
\item ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
\item ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。
\end{itemize}
\item \textbf{TCP}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-04-55_3840x1080.png}
\end{center}
源端口号和目标端口号是不可少的。
还有应该有的是确认号，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。
接下来还有一些状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力。
除了做流量控制以外，TCP还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。
\textbf{三次握手}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-09-04_3840x1080.png}
\end{center}
一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。
然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。
服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。
客户端收到服务端发送的 SYN 和 ACK 之后，发送对 SYN 确认的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。
服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。
\uline{所以三次握手目的是保证双方都有发送和接收的能力。}
如果 HTTP 请求消息比较长，超过了 MSS 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-11-11_3840x1080.png}
\end{center}
MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。
数据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-13-02_3840x1080.png}
\end{center}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-13-36_3840x1080.png}
\end{center}
\item IP
TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-18-39_3840x1080.png}
\end{center}
在 IP 协议里面需要有源地址 IP 和 目标地址 IP：
因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06（十六进制），表示协议为 TCP。
当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。
这个时候就需要根据路由表规则，来判断哪一个网卡作为源地址 IP。
\uline{这里将目标IP地址与子网掩码进行与运算，比较结果}
目标地址和子网掩码都是 0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，Gateway 即是路由器的 IP 地址。
最终形成的数据报:
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-21-42_3840x1080.png}
\end{center}
\begin{itemize}
\item TCP协议首部各字段的作用
\begin{enumerate}
\item 源端口和目的端口：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能通过端口实现。

\item 序号：占 4 字节。TCP 连接中传送的数据流中的每一个字节都有一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。

\item 确认号：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。

\item 数据偏移（即首部长度）：占 4 位，指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。单位是 32 位字（以 4 字节为计算单位）。

\item 紧急 URG：控制位。当 URG = 1 时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送 (相当于高优先级的数据)。

\item 确认 ACK：控制位。只有当 ACK =1 时，确认号字段才有效。当 ACK =0 时，确认号无效。

\item 推送 PSH (PuSH) ：控制位。接收 TCP 收到 PSH = 1 的报文段后，就尽快（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满后再交付。

\item 复位 RST (ReSeT) ：控制位。当 RST=1 时，表明 TCP 连接中出现严重差错（如主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。

\item 同步 SYN (SYNchronization) ：控制位。同步 SYN = 1 表示这是一个连接请求或连接接受报文。 当 SYN = 1，ACK = 0 时，表明这是一个连接请求报文段。当 SYN = 1，ACK = 1 时，表明这是一个连接接受报文段。

\item 终止 FIN (FINish) ：控制位。用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

\item 窗口：占 2 字节。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。 \uline{记住：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。}

\item 检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。

\item 紧急指针：占 2 字节。在 URG = 1时，指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），指出了紧急数据的末尾在报文段中的位置。

\item 选项：长度可变，最长可达 40 字节。
\end{enumerate}
\end{itemize}
\end{enumerate}


\begin{enumerate}
\item \textbf{两点传输-MAC}
MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-27-20-22-54_3840x1080.png}
\end{center}
在 MAC 包头里需要发送方 MAC 地址和接收方目标 MAC 地址，用于两点之间的传输。
一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：
\begin{itemize}
\item 0800 ： IP 协议
\item 0806 ： ARP 协议
\item MAC发送方和接收方如何确认？
发送方的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。
接收方的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。
所以先得搞清楚应该把包发给谁，这个只要查一下路由表就知道了。在路由表中找到相匹配的条目，然后把包发给 Gateway 列中的 IP 地址就可以了。
\item 如何获取对方的MAC地址？
需要 ARP 协议帮我们找到路由器的 MAC 地址。
ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。
在后续操作系统会把本次查询结果放到一块叫做 ARP 缓存的内存空间留着以后用，不过缓存的时间就几分钟。
\end{itemize}
至此，就要把数据包发送出去了
\item 网卡
网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。
网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。
\item 交换机
交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为二层网络设备。
首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。
然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。
计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址。
交换机的 MAC 地址表主要包含两个信息：一个是设备的 MAC 地址，另一个是该设备连接在交换机的哪个端口上。
交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。
当MAC地址表中找不到指定的MAC地址时，交换机就无法判断应该把包发送到那里，就会把包转发到除了源端口之外的所有端口上。
这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。
\item \textbf{路由器}
网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。
\begin{itemize}
\item 与交换机的区别
因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。

\item 基本原理
路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。
当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。
\item 包接受操作
首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进行错误校验。
如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。
总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。
\item 查询路由表确定输出端口
完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。
MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。
接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。
转发操作分为几个阶段，首先是查询路由表判断转发目标。
这里的路由匹配也使用的目标地址与条目的子网掩码进行按位与运算。
\item 包的发送操作
首先，我们需要根据路由表的网关列判断对方的地址。
如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。
如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。
\end{itemize}

知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。
路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。
接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 0800 （十六进制）表示 IP 协议。
网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。
发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。
接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。
在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。
\item \textbf{服务器与客户端}
数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。
接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。
于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入 \textbf{缓存} 中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。
\end{enumerate}
\subsection{可靠传输的工作原理\hfill{}\textsc{可靠传输原理}}
\label{sec:org4f55d8a}

\begin{itemize}
\item 理想传输条件的特点
\begin{enumerate}
\item 传输信道不产生差错。
\item 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。
\end{enumerate}
\end{itemize}
\subsubsection{停止等待协议}
\label{sec:orge5e3973}
\begin{enumerate}
\item 全双工通信的双方既是发送方也是接收方。
\item 全双工通信的双方既是发送方也是接收方。
\item 假设仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。
\end{enumerate}
\subsubsection{无差错的情况}
\label{sec:org5856b44}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-31-00-25-24_3840x1080.png}
\end{center}
\subsubsection{出现差错的情况}
\label{sec:orge68dfcf}
\begin{enumerate}
\item B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。
\item M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。
\end{enumerate}
在这两种情况下，B 都不会发送任何信息
\begin{itemize}
\item \textbf{问题来了，A如何知道B是否正确收到了M\_1呢？}
采用超时重传解决。
\begin{enumerate}
\item A 为每一个已发送的分组设置一个超时计时器。
\item A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。
\item 若 A 在超时计时器规定时间内没有收到 B 的确认，就认为分组错误或丢失，就重发该分组。
\end{enumerate}
\end{itemize}
\subsubsection{确认丢失和确认迟到}
\label{sec:org39ef270}
\begin{itemize}
\item 确认丢失
\begin{enumerate}
\item 若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内将不会收到确认，因此 A 在超时计时器到期后重传 M1。
\item 假定 B 正确收到了 A 重传的分组 M1。这时 B 应采取两个行动：
（1）丢弃这个重复的分组M\_1不向上层交付
（2）向A发送确认。
\end{enumerate}
\item 确认迟到
\begin{enumerate}
\item B 对分组 M1 的确认迟到了，因此 A 在超时计时器到期后重传 M1。
\item B 会收到重复的 M1，丢弃重复的 M1，并重传确认分组。
\item A 会收到重复的确认。对重复的确认的处理：丢弃。
\end{enumerate}
\end{itemize}
\subsubsection{信道利用率}
\label{sec:org52b905e}
停止等待协议中的信道利用率计算公式：
\[
  U = \frac{T_D}{T_D + RTT + T_A}
\]

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-31-00-37-35_3840x1080.png}
\end{center}

优点：简单。缺点：信道利用率太低。

当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率会非常低。
\begin{enumerate}
\item 要点
\label{sec:org241e83a}
\begin{itemize}
\item 停止等待：发送方每次只发送一个分组。在收到确认后再发送下一个分组。
\item 暂存：在发送完一个分组后，发送方必须暂存已发送的分组的副本，以备重发。
\item 编号。对发送的每个分组和确认都进行编号。
\item 超时重传。发送方为发送的每个分组设置一个超时计时器。若超时计时器超时位收到确认，发送方会自动超时重传分组。
\item 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些，防止不必要的重传。
\item 简单，但信道利用率太低。
\end{itemize}
\item 提高传输速率：流水线传输
\label{sec:orgc30dc7a}
流水线传输：在收到确认之前，发送方连续发出多个分组。

由于信道上一直有数据不间断地传送，流水线传输可获得很高的信道利用率。

连续 ARQ 协议和滑动窗口协议采用流水线传输方式。
\end{enumerate}
\subsubsection{连续ARQ协议}
\label{sec:org99dd7f9}
\begin{itemize}
\item 发送窗口：发送方维持一个发送窗口，位于发送窗口内的分组都可被连续发送出去，而不需要等待对方的确认。
\item 发送窗口滑动：发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。
\item 累积确认：接收方对按序到达的最后一个分组发送确认，表示：到这个分组为止的所有分组都已正确收到了。
\end{itemize}
\begin{enumerate}
\item 累计确认
\label{sec:org5295a44}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-31-00-47-13_1920x1080.png}
\end{center}

\begin{itemize}
\item 优点
\begin{itemize}
\item 容易实现，即使确认丢失也不必重传。
\end{itemize}
\item 缺点
\begin{itemize}
\item 不能向发送方反映出接收方已经正确收到的所有分组的信息。
\end{itemize}
\end{itemize}

连续 ARQ 协议采用 Go-back-N（回退N）。

Go-back-N（回退N）：表示需要再退回来重传已发送过的 N 个分组。当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。
\end{enumerate}
\subsection{可靠运输的实现\hfill{}\textsc{可靠传输实现}}
\label{sec:orgaae926d}
\subsubsection{以字节为单位的滑动窗口}
\label{sec:orgd30fe68}
\begin{itemize}
\item TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。
\item TCP 的滑动窗口是以字节为单位的。
\item 发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。
\item 发送窗口：在没有收到确认的情况下，发送方可以连续把窗口内的数据全部发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。
\item 接收窗口：只允许接收落入窗口内的数据。
\end{itemize}
\begin{enumerate}
\item 发送缓存和发送窗口
\label{sec:orgbeadcb7}

发送方的应用进程把字节流写入 TCP 发送缓存。

暂时存放：
\begin{enumerate}
\item 发送应用程序传送给发送方 TCP 准备发送的数据；
\item TCP 已发送出但尚未收到确认的数据。
\end{enumerate}
\item 接收缓存和接收窗口
\label{sec:orgc7b127c}
接收方的应用进程从 TCP 接收缓存中读取尚未被读取的字节。

暂时存放：
\begin{enumerate}
\item 按序到达的、但尚未被接收应用程序读取的数据；
\item 未按序到达的数据。
\end{enumerate}
\item 重点
\label{sec:org17c614f}
\begin{enumerate}
\item 发送窗口是根据接收窗口设置的，但在同一时刻，发送窗口并不总是和接收窗口一样大（因为有一定的时间滞后）。
\item TCP 要求接收方必须有累积确认的功能，以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，捎带确认实际上并不经常发生。
\item TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
\end{enumerate}
\end{enumerate}
\subsubsection{超时重传时间的选择}
\label{sec:orgf9efdfa}
TCP 发送方在规定的时间内没有收到确认就要重传已发送的报文段。

但重传时间的选择是 TCP 最复杂的问题之一。

互联网环境复杂，IP 数据报所选择的路由变化很大，导致运输层的往返时间 (RTT) 的变化也很大。

不能太短，否则会引起很多报文段的不必要的重传，使网络负荷增大。

不能过长，会使网络的空闲时间增大，降低了传输效率。
\begin{enumerate}
\item 加权平均往返时间RTT\_s
\label{sec:org535423d}

加权平均往返时间 RTTS 又称为平滑的往返时间。

\[
  新的RTT_s = (1-\alpha) \times 旧的RTT_s + \alpha \times 新的RTT
\]
其中，0≤α<1。
若 α→0，表示 RTT 值更新较慢。
若 α→1，表示 RTT 值更新较快。
\item 超时重传RTO
\label{sec:orgde4a03a}
RTO (Retransmission Time-Out) 应略大于加权平均往返时间 RTTS 。

\[
  RTO=RTT_s + 4 \times RTT_D
\]
RTTD 是 RTT 偏差的加权平均值。

\[
  新的RTT_D=(1- \beta) \times 旧的RTT_D+ \beta \times |新的RTT样本-RTT_s|
\]
\item 修正的Karn算法
\label{sec:org6076d24}
在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。

\[
  新的RTO=旧的RTO \times 系数
\]
系数的典型取值为2。

报文段重传：在发生重传时，不会使用重传报文的 RTT 样本来更新 RTO，以免因为网络抖动或其他因素导致测量不准确。而是通过增加超时时间 RTO 来避免过早重。

正常传输时：当不再发生报文段的重传时，才会重新计算加权平均的 RTT 和 RTT 偏差 RTTDRTTD​，并更新 RTO 的值。
\end{enumerate}
\subsubsection{选择确认SACK}
\label{sec:org1d6380b}
如果要使用选择确认，在建立 TCP 连接时，要在 TCP 首部的选项中加上允许 SACK 选项，且双方必须事先商定好。

如果使用选择确认，原来首部中的确认号的用法仍然不变（累积确认）。只是在 TCP 首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。
\section{Linux接受网络包的流程}
\label{sec:orgdf626e4}

网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。

\begin{itemize}
\item 如何通知操作系统网络包已经达到？
最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。
为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。
因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。
硬件终端处理函数：
\begin{itemize}
\item 需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。
\item 接着，发起「软中断」，然后恢复刚才屏蔽的中断。
\end{itemize}
软中断的处理：
内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。
ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk\_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。
\end{itemize}
\section{HTTP协议}
\label{sec:orgece98b7}
\begin{itemize}
\item 状态码
1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

\item Connection 字段
最常用的就是Keep-Alive字段，用来表示长连接。
\item Content-Type字段
用于服务器回应时，告知客户端本次数据是什么格式。
\item Accept
声明自己可以接受哪些数据格式。
\item Get和Post的区别
GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。
POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。
\item Get和Post方法都是安全和幂等的吗？
在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的
GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。
POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。

GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。
\end{itemize}
\subsection{HTTP缓存技术}
\label{sec:org32c3429}
实现方式：强制缓存和协商缓存
\begin{itemize}
\item 强制缓存
强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
Cache-Control， 是一个相对时间；Expires，是一个绝对时间；
如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，Cache-Control 的优先级高于 Expires 。

\item 协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。
两种实现：
\begin{enumerate}
\item 请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现
请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

\item 请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段
响应头部中 Etag：唯一标识响应资源；
请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。
\end{enumerate}
第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。
如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，这时 Etag 的优先级更高，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。
\begin{itemize}
\item 为什么ETag优先级更高？
\begin{itemize}
\item 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；
\item 可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
\item 有些服务器不能精确获取文件的最后修改时间。
\end{itemize}
\end{itemize}
协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。

\begin{itemize}
\item 使用ETag实现的协商缓存的过程：
当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
  如果没有过期，则直接使用本地缓存；
  如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：
  如果值相等，则返回 304 Not Modified，不会返回资源；
  如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。
\end{itemize}
\end{itemize}
\subsection{HTTP特性}
\label{sec:org5b566bc}
\begin{itemize}
\item 简单
HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。
\item 灵活、易于拓展
HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化，比如说\- HTTP3.0改用UDP作为下层传输协议。
\item 应用广泛和跨平台
天然具有跨平台的优越性。
\end{itemize}
\subsection{HTTP/1.1的缺点}
\label{sec:org9d2cec2}
\begin{itemize}
\item 无状态

无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。
\begin{itemize}
\item 解决方案：
Cookie技术：在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了。
\end{itemize}
\item 明文传输

明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。
但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。
\item 不安全

通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。
无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。
\begin{itemize}
\item 解决方案：引入SSL/TLS层。
\end{itemize}
\end{itemize}
\subsection{HTTP/1.1的性能？}
\label{sec:org8fae72b}
HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。
\begin{itemize}
\item 长连接
早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。
为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
特点：只要任意一段没有明确提出断开连接就保持TCP连接状态。
\item 管道网络传输
HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求。
\textbf{但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。}
如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。
\textbf{所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。}
\item 队头阻塞
「请求 - 应答」的模式会造成 HTTP 的性能问题。为什么呢？
因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。
\end{itemize}
\subsection{HTTP与HTTPS}
\label{sec:org5ba5202}
\begin{itemize}
\item 区别
\begin{itemize}
\item HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
\item HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
\item 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
\item HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
\end{itemize}
\item HTTPS解决了哪些问题？
\begin{itemize}
\item 窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
\item 篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
\item 冒充风险，比如冒充淘宝网站，用户钱容易没。
\end{itemize}
\item TLS/SSL的特点
\begin{itemize}
\item 信息加密：交互信息无法被窃取。
\item 校验机制：无法篡改通信内容，篡改了就不能正常显示。
\item 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。
\end{itemize}
\item 如何解决三个风险?
\begin{itemize}
\item 混合加密的方式实现信息的机密性，解决了窃听的风险。
\item 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
\item 将服务器公钥放入到数字证书中，解决了冒充的风险。
\end{itemize}
\item 混合加密
\begin{itemize}
\item 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
\item 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。
\end{itemize}
\item 为何采取混合加密
\begin{itemize}
\item 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
\item 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。
\end{itemize}
\item HTTPS如何建立连接？
SSL/TLS协议基本流程：
\begin{itemize}
\item 客户端向服务器索要并验证服务器的公钥。
\item 双方协商生产「会话秘钥」。
\item 双方采用「会话秘钥」进行加密通信。
\end{itemize}
\item HTTPS的应用数据如何保证完整性？
\begin{itemize}
\item TLS 在实现上分为握手协议和记录协议两层：
TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；
\end{itemize}
\end{itemize}
\uline{HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是HTTPS 不够安全。}
\subsection{HTTP/1.1, HTTP/2, HTTP/3的演进}
\label{sec:org6f6709b}
\subsubsection{HTTP/1.1相比HTTP/1.0提高了什么性能？}
\label{sec:orgba1768a}
\begin{itemize}
\item 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
\item 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
\end{itemize}
但是仍然有性能瓶颈：
\begin{itemize}
\item 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
\item 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
\item 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
\item 没有请求优先级控制；
\item 请求只能从客户端开始，服务器只能被动响应。
\end{itemize}
\subsubsection{HTTP/2做了什么优化？}
\label{sec:orgd70a597}
\begin{itemize}
\item 头部压缩
HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。
这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
\item 二进制格式
HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧（Headers Frame）和数据帧（Data Frame）。
\item 并发传输
我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了队头阻塞的问题。
而 HTTP/2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。
针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。
\item 服务器推送
HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以主动向客户端发送消息。
客户端和服务器双方都可以建立 Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。
\end{itemize}
\subsubsection{HTTP/2缺陷？}
\label{sec:orgcf076ac}
HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，\- 这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。
\subsubsection{HTTP/3的优化？}
\label{sec:orgdc6bce6}
\begin{itemize}
\item 队头阻塞
HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。
HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。
HTTP/2 队头阻塞的问题是因为 TCP，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！
UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。
\item QUIC的3个特点
\begin{itemize}
\item 无队头阻塞
QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。
当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。
\item 更快地建立连接
对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。
HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-12-38-19_1920x1080.png}
\end{center}
\end{itemize}
\item 连接迁移
基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。
那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。
而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。
所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。
\end{itemize}
\subsubsection{如何减少HTTP请求次数？}
\label{sec:org150ef28}
\begin{itemize}
\item 减少重定向请求次数
重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了。
而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数。
\item 合并请求
如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。
另外由于 HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP/1.1 管道模式是默认不使用的，所以讨论 HTTP/1.1 的队头阻塞问题，是不考虑管道模式的），于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间。
通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，从而减少网络的开销。
合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。
但是这样的合并请求会带来新的问题，当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，这显然带来了额外的网络消耗。
\item 延迟发送请求
请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。
\end{itemize}
\subsection{HTTP/2的优化}
\label{sec:orgee16560}
\begin{itemize}
\item 头部压缩
1.1版本中Header部分存在有：
\begin{itemize}
\item 含很多固定的字段，比如 Cookie、User Agent、Accept 等，这些字段加起来也高达几百字节甚至上千字节，所以有必要压缩；
\item 大量的请求和响应的报文里有很多字段值都是重复的，这样会使得大量带宽被这些冗余的数据占用了，所以有必须要避免重复性；
\item 字段是 ASCII 编码的，虽然易于人类观察，但效率低，所以有必要改成二进制编码；
\end{itemize}
2版本没有用gzip进行压缩，而是采用HPACK算法，包含三个部分：
\begin{itemize}
\item 静态字典
HTTP/2 为高频出现在头部的字符串和字段建立了一张静态表，它是写入到 HTTP/2 框架里的，不会变化的，静态表里共有 61 组。
表中有的 Index 没有对应的 Header Value，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。
来看个具体的例子，下面这个 server 头部字段，在 HTTP/1.1 的形式如下：
\begin{verbatim}
server: nghttpx\r\n
\end{verbatim}
算上冒号空格和末尾的换行符，共占用了 17 字节，而使用了静态表和 Huffman 编码，可以将它压缩成 8 字节，压缩率大概 47\%。
\item 动态表编码（动态字典）
静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建动态表，它的 Index 从 62 起步，会在编码解码的时候随时更新。

比如，第一次发送时头部中的「User-Agent 」字段数据有上百个字节，经过 Huffman 编码发送出去后，客户端和服务器双方都会更新自己的动态表，添加一个新的 Index 号 62。那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发 1 个字节的 Index 号就好了，因为双方都可以根据自己的动态表获取到字段的数据。

所以，使得动态表生效有一个前提：必须同一个连接上，重复传输完全相同的 HTTP 头部。如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。
\item 二进制帧（哈夫曼编码）
HTTP/2 把响应报文划分成了两类帧（ \textbf{Frame} ），图中的 HEADERS（首部）和 DATA（消息负载） 是帧的类型，也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-14-25-15_3840x1080.png}
\end{center}
帧结构如上
\item 并发传输
通过 Stream 这个设计，多个 Stream 复用一条 TCP 连接，达到并发的效果，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。
多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。
在 HTTP/2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。
\end{itemize}
\end{itemize}
\subsection{HTTP和RPC的区别}
\label{sec:org2bbe404}
\begin{itemize}
\item 服务方
在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。
而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如CoreDNS。
\item 底层连接形式
以主流的 HTTP/1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。
而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。
\item 传输内容
基于 TCP 传输的消息，说到底，无非都是消息头 Header 和消息体 Body。
Header 是用于标记一些特殊信息，其中最重要的是消息体长度。
Body 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 Json，Protobuf。
\end{itemize}
\section{TCP}
\label{sec:org8597ab0}
\subsection{基本认识}
\label{sec:org9bc46f4}
头部
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-15-51-27_3840x1080.png}
\end{center}
序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。

确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。

\begin{itemize}
\item 什么是TCP

TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

\item 什么是TCP连接
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。
所以，建立一个TCP连接需要：
\begin{itemize}
\item Socket：由 IP 地址和端口号组成

\item 序列号：用来解决乱序问题等

\item 窗口大小：用来做流量控制
\end{itemize}

\item 四元组
源地址、源端口、目标地址、目标端口

源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

\item TCP和UDP的区别
\begin{itemize}
\item 连接
TCP 是面向连接的传输层协议，传输数据前先要建立连接。
UDP 是不需要连接，即刻传输数据。

\item 服务对象
TCP 是一对一的两点服务，即一条连接只有两个端点。
UDP 支持一对一、一对多、多对多的交互通信

\item 可靠性
TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。

\item 拥塞控制、流量控制
TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

\item 首部开销
TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

\item 传输方式
TCP 是流式传输，没有边界，但保证顺序和可靠。
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

\item 分片不同
TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。
\end{itemize}

\item 为什么UDP头部没有首部长度字段，而TCP首部有首部长度字段呢？
TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。
\item 为什么UDP头部有包长度字段，而TCP没有呢？

TCP计算负载长度：TCP数据的长度=IP总长度-IP首部长度-TCP首部长度

其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。

因为为了网络设备硬件设计和处理方便，首部长度需要是 4 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是 4 字节的整数倍，才补充了「包长度」字段。
\end{itemize}
\subsection{三次握手}
\label{sec:org57a4859}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-17-47-33_3840x1080.png}
\end{center}
\begin{itemize}
\item 一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态
\item 客户端会随机初始化序号（client\_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
\item 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server\_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client\_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
\item 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server\_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。
\item 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。
\end{itemize}

从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的。
具体流程请参考计网文件夹中的内容。
\begin{itemize}
\item 为什么每次建立TCP连接时，初始化的序列号都要求不一样呢？
\begin{itemize}
\item 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
\item 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；
\end{itemize}
\end{itemize}
\subsubsection{既然IP要分片，为什么TCP层还需要MSS呢？}
\label{sec:org7217094}
MTU：一个网络包的最大长度，以太网中一般为 1500 字节；
MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？

当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。

这看起来井然有序，但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。

因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。

当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。

因此，可以得知由 IP 层进行分片传输，是非常没有效率的。

所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。

经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。
\subsubsection{第一次握手丢失了，会发生什么？}
\label{sec:org9d628f9}
当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN\_SENT 状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。

不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。

当客户端超时重传 3 次 SYN 报文后，由于 tcpsynretries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。
\subsubsection{第二次握手丢失了，会发生什么？}
\label{sec:org9e7d138}
当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN\_RCVD 状态。

第二次握手的 SYN-ACK 报文其实有两个目的 ：
\begin{itemize}
\item 第二次握手里的 ACK， 是对第一次握手的确认报文；
\item 第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；
\end{itemize}

因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。

因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。

那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。
\subsubsection{第三次握手丢失了，会发生什么？}
\label{sec:org3d5eb0b}
客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。

因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。
\subsection{四次挥手}
\label{sec:org82efcc6}
客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN\_WAIT\_1 状态。

服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE\_WAIT 状态

客户端收到服务端的 ACK 应答报文后，之后进入 FIN\_WAIT\_2 状态。

等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST\_ACK 状态。

客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME\_WAIT 状态。

服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。

客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。

每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。

主动关闭连接的，才有 TIME\_WAIT 状态。
\subsubsection{为什么需要四次挥手？}
\label{sec:org415e9e4}
关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。

实际上，四次挥手可以变为三次，具体看计网下的内容。
\subsubsection{第一次挥手丢失了，会发生什么？}
\label{sec:org89cddc3}
当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN\_WAIT\_1 状态。

正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 FIN\_WAIT2状态。

如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 tcp\_orphan\_retries 参数控制。

当客户端超时重传 3 次 FIN 报文后，由于 tcporphanretries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。
\subsubsection{第二次挥手丢失了，会发生什么？}
\label{sec:orgf645fdc}
当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE\_WAIT 状态。

在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。

当客户端超时重传 2 次 FIN 报文后，由于 tcporphanretries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。

当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 FIN\_WAIT2 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。

\uline{对于 close 函数关闭的连接，由于无法再发送和接收数据，所以FIN\_WAIT2 状态不可以持续太久，而 tcp\_fin\_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。}

但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。

此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN\_WAIT2 状态（tcp\_fin\_timeout 无法控制 shutdown 关闭的连接）。
\subsubsection{第三次挥手丢失了，会发生什么？}
\label{sec:orgb6a27e3}
当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE\_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。

此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。

服务端处于 CLOSEWAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LASTACK 状态，等待客户端返回 ACK 来确认连接关闭。

如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp\_orphan\_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcporphanretries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。

客户端因为是通过 close 函数关闭连接的，处于 FINWAIT2 状态是有时长限制的，如果 tcpfintimeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。
\subsubsection{第四次挥手丢失了，会发生什么？}
\label{sec:org6cf5b70}
当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME\_WAIT 状态。

在 Linux 系统，TIME\_WAIT 状态会持续 2MSL 后才会进入关闭状态。

然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST\_ACK 状态。

如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp\_orphan\_retries 参数控制。

当服务端重传第三次挥手报文达到 2 时，由于 tcporphanretries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。

客户端在收到第三次挥手后，就会进入 TIME\_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。
\subsubsection{为什么TIME\_WAIT等待的时间是2MSL?}
\label{sec:org35043b4}
MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。

TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。

TIME\_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

可以看到 2MSL时长 这其实是相当于至少允许报文丢失一次。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME\_WAIT 状态的连接可以应对。

2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。
\subsubsection{为什么需要TIME\_WAIT状态？}
\label{sec:orgf40d85c}
\begin{itemize}
\item 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
为了理解原因，需要先了解序列号SEQ和初始序列号ISN：
\begin{enumerate}
\item 序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0。
\item 初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。
\end{enumerate}

序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。
为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME\_WAIT 状态，状态会持续 2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。

\item 保证「被动关闭连接」的一方，能被正确的关闭；
TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。

如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。

假设客户端没有 TIME\_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。

服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。

服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer）进行异常终止，这对于一个可靠的协议来说不是一个优雅的终止方式。

为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。

客户端在收到服务端重传的 FIN 报文时，TIME\_WAIT 状态的等待时间，会重置回 2MSL。
\end{itemize}
\subsubsection{如何优化TIME\_WAIT?}
\label{sec:orgb5bf043}
\begin{enumerate}
\item net.ipv4.tcptwreuse 和 tcp\_timestamps
如下的 Linux 内核参数开启后，则可以复用处于 TIME\_WAIT 的 socket 为新的连接所用。

有一点需要注意的是，tcptwreuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time\_wait 状态超过 1 秒的连接给新的连接复用。

net.ipv4.tcp\_tw\_reuse = 1
使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即

net.ipv4.tcp\_timestamps=1（默认即为 1）
这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。

由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。

\item net.ipv4.tcpmaxtw\_buckets

这个值默认为 18000，当系统中处于 TIMEWAIT 的连接一旦超过这个值时，系统就会将后面的 TIMEWAIT 连接状态重置，这个方法比较暴力。

\item 程序中使用 SO\_LINGER

我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。
\begin{verbatim}
struct linger so_linger;
so_linger.l_onoff = 1;
so_linger.l_linger = 0;
setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));
\end{verbatim}
如果l\_onoff为非 0， 且l\_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME\_WAIT状态，直接关闭。
\end{enumerate}


如果服务端要避免过多的 TIMEWAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIMEWAIT。
\subsubsection{服务端出现大量TIME\_WAIT状态的原因有哪些？}
\label{sec:orgd19f9a9}
首先要知道 TIMEWAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIMEWAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。
\subsubsection{什么状态下，服务端会主动断开连接呢？}
\label{sec:org2417e2a}
\begin{enumerate}
\item HTTP没有使用长连接
关闭 HTTP 长连接机制后，每次请求都要经历这样的过程：建立 TCP -> 请求资源 -> 响应资源 -> 释放连接，那么此方式就是 HTTP 短连接。
只要任意一方的 HTTP header 中有 Connection:close 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求/处理后，就会关闭连接。

不过，根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接，那么此时服务端上就会出现 TIME\_WAIT 状态的连接。

因此，当服务端出现大量的 TIME\_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive，因为任意一方没有开启 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME\_WAIT 状态的连接。

\item HTTP长连接超时

HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求/应答，避免了连接建立和释放的开销。

假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME\_WAIT 状态的连接。

\item HTTP长连接的请求数量达到上限

Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。

比如 nginx 的 keepaliverequests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接，那么此时服务端上就会出现 TIMEWAIT 状态的连接。

keepalive\_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100 次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。

对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepaliverequests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIMEWAIT 状态。
\end{enumerate}
\subsubsection{服务器大量出现CLOSE\_WAIT状态的原因有哪些呢？}
\label{sec:org082ad07}
CLOSEWAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSEWAIT 状态的连接转变为 LAST\_ACK 状态。

所以，当服务端出现大量 CLOSE\_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。
\subsubsection{如果已经建立了连接，但是客户端突然出现了故障怎么办？}
\label{sec:org9b1d9bc}

客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。

为此，TCP提出了保活机制
\begin{enumerate}
\item 保活机制
\label{sec:org3a51b1a}

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

如果开启了 TCP 保活，需要考虑以下几种情况：
\begin{itemize}
\item 第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。
\item 第二种，对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。
\item 第三种，是对端主机宕机（注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
\end{itemize}
\end{enumerate}
\subsubsection{如果已经建立了连接，但是服务端的进程崩溃会发生什么？}
\label{sec:org9f1d7ec}
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。

在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手。
\subsection{\underline{TCP重传、滑动窗口、流量控制、拥塞控制}}
\label{sec:org25bc887}

\subsubsection{\underline{重传机制}}
\label{sec:orga19a3bf}

TCP 实现可靠传输的方式之一，是通过序列号与确认应答。

在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。

在网络环境复杂的情况下，可能会发生丢包，这时候就需要重传机制来工作。
\begin{enumerate}
\item 超时重传
\label{sec:org2c1eb9c}

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。

两种发生超时重传的情况

\begin{enumerate}
\item 数据包丢失
\item 确认应答丢失
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-19-14-16_3840x1080.png}
\end{center}
两种情况

超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。

假设在重传的情况下，超时时间 RTO 「较长或较短」时，会发生什么事情呢？
\begin{itemize}
\item 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；

\item 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。
\end{itemize}

超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。

「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍。

也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

超时重传存在的问题是，超市周期可能较长，有没有更快的方式？

于是就可以用「快速重传」机制来解决超时重发的时间等待。
\end{enumerate}
\item 快速重传
\label{sec:org8a43218}

快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-19-06-35_3840x1080.png}
\end{center}
机制原理

发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。

\textbf{所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。}

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。 \textbf{就是重传的时候，是重传一个，还是重传所有的问题。}

为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。
\item SACK方法
\label{sec:orgd757a93}

SACK（ Selective Acknowledgment）， 选择性确认。

这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200\textasciitilde{}299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-19-08-25_3840x1080.png}
\end{center}
\item Duplicate SACK方法
\label{sec:org5f9c663}

Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-19-09-19_3840x1080.png}
\end{center}

在这个例子中，「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 \textasciitilde{} 3499）。

于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000\textasciitilde{}3500，告诉「发送方」 3000\textasciitilde{}3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。

这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-19-10-21_3840x1080.png}
\end{center}
在这个例子中，数据包（1000\textasciitilde{}1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。

而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000\textasciitilde{}1499）又到了「接收方」；

所以「接收方」回了一个 SACK=1000\textasciitilde{}1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。

这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。

可见，D-SACK有这几个好处：

\begin{enumerate}
\item 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;

\item 可以知道是不是「发送方」的数据包被网络延迟了;

\item 可以知道网络中是不是把「发送方」的数据包给复制了;
\end{enumerate}
\end{enumerate}
\subsubsection{滑动窗口}
\label{sec:org739e35a}
TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。

这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。

为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

那么有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

如下，假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-19-19-40_3840x1080.png}
\end{center}
图中的ACK 600确认应答报文丢失，也没问题，因为可以通过下一个e确认应答进行确认，只要发送方收到了ACK 700确认应答，就意味着700之前的所有数据接收方都受到了，这个模式就叫 \textbf{累计确认} 或者 \textbf{累计应答} 。

\begin{itemize}
\item 窗口大小由哪一方决定？
TCP 头里有一个字段叫 Window，也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

所以，通常窗口的大小是由接收方的窗口大小来决定的。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

SND: WND表示发送窗口的大小，USA(Send Unacknoledged)绝对指针，指向已发送但还没确认的第一个字节的序列号，NXT指向o未发生能够但可发送范围的第一个字节的序列号。

可用窗口大小的计算：SND.WND-(SND.NXT-SND.USA)

接收方的窗口：
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-21-59-10_1920x1080.png}
\end{center}
   RCV.WND：表示接收窗口的大小，它会通告给发送方。
   RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 \#3 的第一个字节。
   指向 \#4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 \#4 的第一个字节了。

\begin{itemize}
\item 接收窗口和发送窗口的大小相等吗？
并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。
\end{itemize}
\subsubsection{流量控制}
\label{sec:org941e41d}

发送方不能无脑的发数据给接收方，要考虑接收方处理能力。

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-22-16-52_1920x1080.png}
\end{center}
一个例子
可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-22-17-38_1920x1080.png}
\end{center}
当服务端系统资源非常紧张的时候，操作系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。

为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。

\begin{itemize}
\item 窗口关闭

TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。

如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。

\item 窗口关闭潜在的危险

接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。

那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-22-20-59_1920x1080.png}
\end{center}

这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。

\item TCP如何解决窗口关闭时，潜在的死锁现象呢？

为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

如果持续计时器超时，就会发送窗口探测 ( Windowprobe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-22-22-02_1920x1080.png}
\end{center}

如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；

如果接收窗口不是 0，那么死锁的局面就可以被打破了。

窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。

\item 糊涂窗口综合征

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。

到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-22-34-29_1920x1080.png}
\end{center}
糊涂窗口综合征例子

每个过程的窗口大小的变化，在图中都描述的很清楚了，可以发现窗口不断减少了，并且发送的数据都是比较小的了。

所以，糊涂窗口综合症的现象是可以发生在发送方和接收方：
\begin{itemize}
\item 接收方可以通告一个小的窗口

\item 而发送方可以发送小数据
\end{itemize}

解决策略：
当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。

\item 怎么让发送方避免发送小数据？
发送方通常的策略如下：
使用Nagle算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：
\begin{itemize}
\item 条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS；

\item 条件二：收到之前发送数据的 ack 回包；
\end{itemize}

只要上面两个条件都不满足，发送方一直在囤积数据，直到满足上面的发送条件。
注意，如果接收方不能满足「不通告小窗口给发送方」，那么即使开了 Nagle 算法，也无法避免糊涂窗口综合症，因为如果对端 ACK 回复很快的话（达到 Nagle 算法的条件二），Nagle 算法就不会拼接太多的数据包，这种情况下依然会有小数据包的传输，网络总体的利用率依然很低。

所以，接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症。

Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。

可以在 Socket 设置 TCP\_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）
\end{itemize}
\subsubsection{拥塞控制}
\label{sec:org138fdc2}

\begin{itemize}
\item 为什么要有拥塞控制呀，不是有流量控制了吗？
前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。
一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。
在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大\ldots{}.
所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。
于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。

为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。

\item 什么是拥塞窗口？和发送窗口有什么关系呢？
拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。

我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。

拥塞控制cwnd变化的规则：
\begin{itemize}
\item 只要网络中没有出现拥塞，cwnd 就会增大；

\item 但网络中出现了拥塞，cwnd 就减少；
\end{itemize}

\item 怎么知道当前网络中是否出现了拥塞呢？
其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。

\item 拥塞控制有哪些控制算法？
\begin{itemize}
\item 慢启动

\item 拥塞避免

\item 拥塞发生

\item 快速恢复
\end{itemize}
\end{itemize}
\begin{enumerate}
\item 慢启动
\label{sec:org29b5d21}

慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加一倍。

这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：

连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据。

当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2个。

当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个。

当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。

可以看出慢启动算法发包的个数是指数性的增长。

有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。

当 cwnd < ssthresh 时，使用慢启动算法。

当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。
\item 拥塞避免算法
\label{sec:org367fbc2}

当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。

一般来说 ssthresh 的大小是 65535 字节。

那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-23-45-50_3840x1080.png}
\end{center}

\begin{itemize}
\item 拥塞发生

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
\begin{itemize}
\item 超时重传

\item 快速重传
\end{itemize}
\item 发生超时重传的拥塞发生算法
\end{itemize}

当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：
\begin{itemize}
\item ssthresh 设为 cwnd/2，
\item cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

\item 发生快速重传的拥塞发送算法

当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

\begin{itemize}
\item cwnd = cwnd/2 ，也就是设置为原来的一半;

\item ssthresh = cwnd;

\item 进入快速恢复算法
\end{itemize}

\item 快速恢复

快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：
\begin{itemize}
\item cwnd = cwnd/2 ，也就是设置为原来的一半;

\item ssthresh = cwnd;
\end{itemize}
然后进入快速恢复算法如下：
\begin{itemize}
\item 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；

\item 重传丢失的数据包；

\item 如果再收到重复的 ACK，那么 cwnd 增加 1；

\item 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
\end{itemize}
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-28-23-50-51_3840x1080.png}
\end{center}
也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。

\begin{itemize}
\item 快速恢复算法过程中，为什么收到新的数据后，cwnd 设置回了 ssthresh ？

首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。

其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。
\end{itemize}
\end{enumerate}
\subsection{TCP半连接和全连接队列}
\label{sec:orgec083a8}

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

\begin{itemize}
\item 半连接队列，也称 SYN 队列；
\item 全连接队列，也称 accept 队列；
\end{itemize}

服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。

Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 accept() 的 TCP 连接；

Send-Q：当前全连接最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务，最大全连接长度为 128；
\section{IP协议}
\label{sec:orgdeae928}

\begin{itemize}
\item 地址分类
\end{itemize}

IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-12-59-41_3840x1080.png}
\end{center}

\begin{itemize}
\item 什么是A,B,C类地址
\end{itemize}
其中对于 A、B、C 类主要分为两个部分，分别是网络号和主机号。这很好理解，好比小林是 A 小区 1 栋 101 号，你是 B 小区 1 栋 101 号。

大致范围：

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-00-29_3840x1080.png}
\end{center}

\begin{itemize}
\item A,B,C类地址的最大主机个数是如何计算的呢？

最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数：
2\^{}8 - 2 = 254

这里减2是因为：因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-03-11_1920x1080.png}
\end{center}

广播地址用于在同一个链路中相互连接的主机之间发送数据包。

广播地址：
\begin{itemize}
\item 在本网络内广播的叫做本地广播。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。

\item 在不同网络之间的广播叫做直接广播。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有 192.168.1.1\textasciitilde{}192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。
\end{itemize}

\item 什么是D,E类地址

而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。

多播用于将包发送给特定组内的所有主机。

\href{file:///home/jask/Pictures/Screenshots/Screenshot\_2024-12-29-13-06-33\_1920x1080.png}{单播、广播、组播}

多播使用的 D 类地址，其前四位是 1110 就表示是多播地址，而剩下的 28 位是多播的组编号。

\item IP分类的优点

简单明了、选路（基于网络地址）简单。

\item IP分类缺点

\begin{enumerate}
\item 同一网络下没有地址层次。比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。

\item 不能很好的与现实网络匹配。
C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。

而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。
\end{enumerate}

为了解决IP分类的缺点，就提出了无分类地址的方案：CIDR。

\item CIDR无分类地址

这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。

\item 怎么划分网络号和主机号？
\begin{itemize}
\item 表示形式 a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 \textasciitilde{} 32，这就使得 IP 地址更加具有灵活性。

比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。
\end{itemize}
\href{file:///home/jask/Pictures/Screenshots/Screenshot\_2024-12-29-13-12-21\_1920x1080.png}{CIDR举例}

\begin{itemize}
\item 另一种划分网络和主机号的方式是子网掩码。
将子网掩码和 IP 地址按位计算 AND，就可得到网络号。
\href{file:///home/jask/Pictures/Screenshots/Screenshot\_2024-12-29-13-14-24\_1920x1080.png}{子网掩码}
\end{itemize}

\item 为什么要分离网络号和主机号
因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。

路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。

\item 怎么进行子网划分？
子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。形式如下：
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-15-47_1920x1080.png}
\end{center}

未做子网划分的 ip 地址：网络地址＋主机地址

做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）

假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 对其进行子网划分。

C 类地址中前 24 位是网络号，最后 8 位是主机号，根据子网掩码可知从 8 位主机号中借用 2 位作为子网号。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-18-22_1920x1080.png}
\end{center}
由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11，具体划分如下图：

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-18-55_1920x1080.png}
\end{center}

划分后的四个子网地址：
\begin{center}
\begin{tabular}{rrlr}
子网号 & 网络地址 & 主机地址范围 & 广播地址\\
\hline
0 & 192.168.1.0 & 192.168.1.1 \textasciitilde{} 192.168.1.62 & 192.168.1.63\\
1 & 192.168.1.64 & 192.168.1.65 \textasciitilde{} 192.168.1.126 & 192.158.1.127\\
2 & 192.168.1.128 & 192.168.1.129 \textasciitilde{} 192.168.1.190 & 192.168.1.191\\
3 & 192.168.1.192 & 192.168.1.193 \textasciitilde{} 192.168.1.254 & 192.168.1.255\\
\end{tabular}
\end{center}

\item 公有IP地址和私有IP地址
在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-25-04_1920x1080.png}
\end{center}

\item 公有IP地址由谁管理？
私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 ICANN 组织管理，中文叫「互联网名称与数字地址分配机构」。

\item IP地址和路由控制

IP地址的网络地址这一部分是用于进行路由控制。

路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。

在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。

举例：
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-29-02_1920x1080.png}
\end{center}

\begin{enumerate}
\item 主机 A 要发送一个 IP 包，其源地址是 10.1.1.30 和目标地址是 10.1.2.10，由于没有在主机 A 的路由表找到与目标地址 10.1.2.10 相同的网络地址，于是包被转发到默认路由（路由器 1 ）

\item 路由器 1 收到 IP 包后，也在路由器 1 的路由表匹配与目标地址相同的网络地址记录，发现匹配到了，于是就把 IP 数据包转发到了 10.1.0.2 这台路由器 2

\item 路由器 2 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 2 的 10.1.2.1 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机路由器 2 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 2 的 10.1.2.1 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机
\end{enumerate}

如果是环回地址，那就不会流向网络。
\end{itemize}

环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。

计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。

\begin{itemize}
\item IP分片和重组

最常见数据链路是以太网，它的 MTU 是 1500 字节。那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。

经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。

假设发送方发送一个 4000 字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3 个小数据报进行传输，再交由接收方重组成大数据报。

在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 TCP 引入了 MSS 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 MTU 的数据报文。
\end{itemize}
\subsection{DHCP}
\label{sec:org9de2a78}

DHCP获取IP的工作流程：
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-13-52-42_1920x1080.png}
\end{center}

\begin{enumerate}
\item 客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。
\item DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。
\item 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。
\item 最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。
\end{enumerate}

一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。

如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：
\begin{itemize}
\item 服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。
\item 服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。
\end{itemize}

可以发现，DHCP 交互中，全程都是使用 UDP 广播通信。
\subsection{ICMP协议}
\label{sec:orgd9d1b9d}
ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。

ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。

在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-14-44-00_1920x1080.png}
\end{center}

如上图例子，主机 A 向主机 B 发送了数据包，由于某种原因，途中的路由器 2 未能发现主机 B 的存在，这时，路由器 2 就会向主机 A 发送一个 ICMP 目标不可达数据包，说明发往主机 B 的包未能成功。

ICMP 的这种通知消息会使用 IP 进行发送

因此，从路由器 2 返回的 ICMP 包会按照往常的路由控制先经过路由器 1 再转发给主机 A 。收到该 ICMP 包的主机 A 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。
\subsection{IGMP}
\label{sec:orgcb09733}
在前面我们知道了组播地址，也就是 D 类地址，既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 IGMP 协议了。

IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间，如上图中的蓝色部分。

IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。

IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。
\section{期末复习部分}
\label{sec:org0cec4cc}
\subsection{互联网组成}
\label{sec:org16b2898}

从互联网的工作方式上看，可以划分为两大块：
\begin{enumerate}
\item 边缘部分： 由所有连接在互联网上的主机组成，由用户直接使用，用来进行通信（传送数据、音频或视频）和资源共享。
\item 由大量网络和连接这些网络的路由器组成，为边缘部分提供服务（提供连通性和交换）。
\end{enumerate}

处在互联网边缘部分的就是连接在互联网上的所有的主机。这些主机又称为端系统 (end system)。
\subsubsection{互联网的核心部分}
\label{sec:org73dec6b}
\begin{itemize}
\item 是互联网中最复杂的部分。
\item 向网络边缘中的主机提供连通性，使任何一台主机都能够向其他主机通信。
\item 在网络核心部分起特殊作用的是路由器 (router)。
\item 路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组。
\end{itemize}

分组转发是网络核心部分最重要的功能。

互联网的核心部分采用分组交换技术。
\begin{enumerate}
\item 典型交换技术
\label{sec:orgdb5969a}

\begin{enumerate}
\item 电路交换

电线对的数量与电话机数量的平方（N2）成正比。

每一部电话都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间可以很方便地通信。 这种交换方式就是电路交换 (circuit switching)。

\begin{itemize}
\item 过程
\begin{itemize}
\item 建立连接：建立一条专用的物理通路（占用通信资源）。

\item 通话：主叫和被叫双方互相通电话（一直占用通信资源）。

\item 释放连接：释放刚才使用的专用的物理通路（归还通信资源）。
\end{itemize}
\end{itemize}

电路交换特点：通话的两个用户始终占用端到端的通信资源
\item 分组交换
主要特点：
\begin{itemize}
\item 采用存储转发技术。

在发送端，先把较长的报文划分成更小的等长数据段。

数据段前面添加首部就构成了分组 (packet)

分组交换以“分组”作为数据传输单元。互联网采用分组交换技术。分组是在互联网中传送的数据单元。发送端依次把各分组发送到接收端。

接收端收到分组后剥去首部，还原成原来的报文
\end{itemize}
分组在互联网中的转发：
\begin{itemize}
\item 根据首部中包含的目的地址、源地址等重要控制信息进行转发。

\item 每一个分组在互联网中独立选择传输路径。

\item 位于网络核心部分的路由器负责转发分组，即进行分组交换。

\item 路由器要创建和动态维护转发表。
\end{itemize}

过程：
\begin{itemize}
\item 暂存收到的分组。

\item 检查分组首部。

\item 查找转发表。
\end{itemize}
\end{enumerate}


\begin{itemize}
\item 按照首部中的目的地址，找到合适的接口转发出去。
\end{itemize}
优点：
\begin{itemize}
\item 高效：分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。
\item 灵活：为每一个分组独立地选择最合适的转发路由。
\item 迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。
\item 可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。
\end{itemize}

问题：
\begin{itemize}
\item 排队延迟：分组在各路由器存储转发时需要排队。
\item 不保证带宽：动态分配。
\item 增加开销：各分组必须携带控制信息；路由器要暂存分组，维护转发表等。
\end{itemize}

\begin{enumerate}
\item 报文交换

在 20 世纪 40 年代，电报通信就采用了基于存储转发原理的报文交换 (message switching)。
\end{enumerate}

三种方式的比较
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-15-58-55_1920x1080.png}
\end{center}

若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。

报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。

由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。
\end{enumerate}
\subsection{计算机网络}
\label{sec:orgc52764e}

计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。
\subsubsection{分类}
\label{sec:org3b69cff}

\begin{enumerate}
\item 按照网络的作用范围进行分类；
\label{sec:org87957ae}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-16-04-37_1920x1080.png}
\end{center}
\item 按照网络的使用者进行分类；
\label{sec:orgc32ea21}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-16-04-57_1920x1080.png}
\end{center}
\item 用来把用户接入到互联网的网络。
\label{sec:org834eda9}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-16-05-13_1920x1080.png}
\end{center}
\end{enumerate}
\subsubsection{性能指标}
\label{sec:org41c490d}

\begin{enumerate}
\item \textbf{速率}
最重要的一个性能指标。
指的是数据的传送速率，也称为数据率 (data rate) 或比特率 (bit rate)。
速率往往是指额定速率或标称速率，非实际运行速率。
\item \textbf{带宽}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-16-08-38_1920x1080.png}
\end{center}
\item 吞吐量
单位时间内通过某个网络（或信道、接口）的实际数据量。
受网络的带宽或网络的额定速率的限制。
\item 时延
指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。
有时也称为延迟或迟延。

\begin{itemize}
\item 发送时延

也称为传输时延
是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-16-10-52_1920x1080.png}
\end{center}

\item 传播时延

是电磁波在信道中传播一定的距离需要花费的时间。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-16-11-27_1920x1080.png}
\end{center}

发送时延与传播时延有本质上的不同:
发送时延发生在机器内部的发送器中，与传输信道的长度（或信号传送的距离）没有任何关系。
传播时延则发生在机器外部的传输信道媒体上，而与信号的发送速率无关。信号传送的距离越远，传播时延就越大。

\item 处理时延
主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。

\item 排队时延
分组在路由器输入输出队列中排队等待处理和转发所经历的时延。

排队时延的长短往往取决于网络中当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。
\end{itemize}
\end{enumerate}


例题：
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-16-44-51_1920x1080.png}
\end{center}

传播时延=1000 Km/2.0 * 10\^{}5Km/s=5ms
(1) 发送时延=100 * 1024*1024 *8bit /(8 * 10\^{}6 bit/s)=838.9s
总时延约为838.9s
(2) 发送时延=100 * 1024 * 1024 bit /(8 * 100 *10\^{}6 bit/s)=8.389 s
总时延约为9.394s
(3)同样的，5.008ms
(4)5.000008ms
\begin{enumerate}
\item 时延带宽积
时延带宽积=传输时延 * 带宽
链路的时延带宽积又称为以比特为单位的链路长度。
管道中的比特数表示从发送端发出但尚未到达接收端的比特数。
只有在代表链路的管道都充满比特时，链路才得到了充分利用。

\item RTT往返时间
表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间。 

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-17-15-30_1920x1080.png}
\end{center}

发送时延=数据长度/发送速率=100*1024*1024*8/100*10\^{}6=8.39s
有效数据率=数据长度/（发送时间+RTT）=100*2\^{}20*8/(8.39+2)=80.7 Mbit/s

在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。

\item 利用率
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-17-18-11_1920x1080.png}
\end{center}
\end{enumerate}
\subsection{计算机网络的体系结构}
\label{sec:org549fee7}

\subsubsection{网络协议}
\label{sec:org9faa750}
网络协议 (network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。

三个要素：
\begin{itemize}
\item 语法：数据与控制信息的结构或格式 。
\item 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。
\item 同步：事件实现顺序的详细说明。

\item 分层的优点和缺点

\begin{itemize}
\item 差错控制：使相应层次对等方的通信更加可靠。

\item 流量控制：发送端的发送速率必须使接收端来得及接收，不要太快。

\item 分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。

\item 复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。

\item 连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。
\end{itemize}
\end{itemize}
\begin{enumerate}
\item 应用层
\label{sec:org445e77f}
任务：通过应用进程间的交互来完成特定网络应用。

协议：定义的是应用进程间通信和交互的规则。

把应用层交互的数据单元称为报文(message)。
\item 运输层
\label{sec:org05ec53b}
任务：负责向两台主机中进程之间的通信提供通用的数据传输服务。

具有复用和分用的功能。

主要使用两种协议： 传输控制协议 TCP， 用户数据报协议 UDP
\item 网络层
\label{sec:org201a2b6}
为分组交换网上的不同主机提供通信服务。

两个具体任务：
\begin{itemize}
\item 路由选择：通过一定的算法，在互联网中的每一个路由器上，生成一个用来转发分组的转发表。
\item 转发：每一个路由器在接收到一个分组时，要依据转发表中指明的路径把分组转发到下一个路由器。
\end{itemize}

互联网使用的网络层协议是无连接的网际协议 IP  (Internet Protocol) 和许多种路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。

IP 协议分组也叫做 IP 数据报，或简称为数据报。
\item 链路层
\label{sec:orgf84eae9}

任务：实现两个相邻节点之间的可靠通信。

在两个相邻节点间的链路上传送帧（frame）。

如发现有差错，就简单地丢弃出错帧。

如果需要改正出现的差错，就要采用可靠传输协议来纠正出现的差错。这种方法会使数据链路层协议复杂。
\item 物理层
\label{sec:orgecdc36b}

任务：实现比特（0 或 1）的传输。

确定连接电缆的插头应当有多少根引脚，以及各引脚应如何连接。
\end{enumerate}
\subsubsection{对等层与协议数据单元}
\label{sec:org55b11ff}
OSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDU (Protocol Data Unit)。

任何两个同样的层次把 PDU （即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“对等层”之间的通信。

\uline{各层协议实际上就是在各个对等层之间传递数据时的各项规定。}
\subsubsection{协议和服务}
\label{sec:org0a5dd48}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-21-16-39_3840x1080.png}
\end{center}
\subsubsection{TCP/IP的体系结构}
\label{sec:org21ab0be}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-21-18-00_3840x1080.png}
\end{center}
\subsection{物理层}
\label{sec:org53e1b39}

物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。

作用：尽可能屏蔽掉不同传输媒体和通信手段的差异。

用于物理层的协议也常称为物理层规程 (procedure)。
\subsubsection{主要任务}
\label{sec:orga67a340}
\begin{itemize}
\item 确定与传输媒体的接口的特性
\begin{itemize}
\item 机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。
\item 电气特性：指明在接口电缆的各条线上出现的电压的范围。
\item 功能特性：指明某条线上出现的某一电平的电压的意义。
\item 过程特性：指明对于不同功能的各种可能事件的出现顺序。
\end{itemize}
\end{itemize}
\subsubsection{数据通信系统的模型}
\label{sec:orgc0c0699}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-21-49-55_3840x1080.png}
\end{center}
\begin{enumerate}
\item 有关信道的基本概念
\label{sec:org6f9efff}

信道：一般用来表示向某一个方向传送信息的媒体。

单向通信（单工通信）：只能有一个方向的通信，没有反方向的交互。

双向交替通信（半双工通信）：通信的双方都可以发送信息，但双方不能同时发送（当然也就不能同时接收）。

双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。

基带信号（即基本频带信号）
  来自信源的信号。
  包含有较多的低频成分，甚至有直流成分。

调制
  基带调制：仅对基带信号的波形进行变换，把数字信号转换为另一种形式的数字信号。把这种过程称为编码 (coding)。
  带通调制：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号。经过载波调制后的信号称为带通信号（即仅在一段频率范围内能够通过信道）。

常用编码方式
不归零制：正电平代表 1，负电平代表 0。
归零制：正脉冲代表 1，负脉冲代表 0。
曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。
差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。

信号频率：
  曼彻斯特编码和差分曼彻斯特编码产生的信号频率比不归零制高。

自同步能力：
  不归零制不能从信号波形本身中提取信号时钟频率（这叫做没有自同步能力）。
  曼彻斯特编码和差分曼彻斯特编码具有自同步能力。
\item 信道的极限容量
\label{sec:orga40b483}

任何实际的信道都不是理想的，都不可能以任意高的速率进行传送。

码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形的失真就越严重。

限制码元在信道上的传输速率的两个因素：
  信道能够通过的频率范围。
  信噪比。

\begin{enumerate}
\item 信道能够通过的频率范围
具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。

码间串扰：接收端收到的信号波形失去了码元之间的清晰界限。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-21-56-48_3840x1080.png}
\end{center}

\item 信噪比
信噪比就是信号的平均功率和噪声的平均功率之比。常记为 S/N，并用分贝 (dB) 作为度量单位。即：
信噪比(dB) = 10 log10(S/N ) (dB)

例如：当 S/N =10 时，信噪比为10dB，而当 S/N =1000 时，信噪比为30dB。
\end{enumerate}
\item 香农公式
\label{sec:orgf6863d5}

信道的极限信息传输速率 C  可表达为：

\begin{equation}
  C= W \times \log_2(1+\frac{S}{N}) \quad \text{(bits/s)}
\end{equation}

W 信道的带宽 (Hz)；
S  为信道内所传信号的平均功率；
N 为信道内部的高斯噪声功率。y

信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 
只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。
\item 提高信息的传输速率的方法
\label{sec:org1ad0333}
方法：用编码的方法让每一个码元携带更多比特的信息量。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-22-47-59_3840x1080.png}
\end{center}
\item 奈氏准则和香农公式的意义不同
\label{sec:org1b51618}

奈氏准则：激励工程人员不断探索更加先进的编码技术，使每一个码元携带更多比特的信息量。

香农公式：告诫工程人员，在实际有噪声的信道上，不论采用多么复杂的编码技术，都不可能突破信息传输速率的绝对极限。
\end{enumerate}
\subsubsection{物理层下面的传输媒体}
\label{sec:orgea2004e}

\begin{enumerate}
\item 导引型传输媒体
\label{sec:orgfa49b94}

传输媒体是数据传输系统中在发送器和接收器之间的物理通路。

两大类：
  导引型传输媒体：电磁波被导引沿着固体媒体（铜线或光纤）传播。

非导引型传输媒体：指自由空间。非导引型传输媒体中电磁波的传输常称为无线传输。
\begin{enumerate}
\item 导引型传输媒体
\label{sec:org04b387f}
\begin{enumerate}
\item 双绞线
最古老但又最常用的传输媒体。

把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合 (twist) 起来就构成了双绞线。

绞合度越高，可用的数据传输率越高。

\item 同轴电缆
由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成。

具有很好的抗干扰特性，被广泛用于传输较高速率的数据。

\item 光缆

光纤是光纤通信的传输媒体。通过传递光脉冲来进行通信。

其传输带宽远远大于目前其他各种传输媒体的带宽。

发送端：要有光源，在电脉冲的作用下能产生出光脉冲。
  光源：发光二极管，半导体激光器等。

接收端：要有光检测器，利用光电二极管做成，在检测到光脉冲时还原出电脉冲。

优点：
\begin{itemize}
\item 通信容量非常大

\item 传输损耗小，中继距离长，对远距离传输特别经济。

\item 抗雷电和电磁干扰性能好。

\item 无串音干扰，保密性好，不易被窃听或截取数据。

\item 体积小，重量轻。
\end{itemize}
\end{enumerate}
\end{enumerate}
\item 非导引型传输媒体
\label{sec:orgd8a3530}

\begin{enumerate}
\item 无线电微波通信

占有特殊重要的地位。

在空间主要是直线传播。
地球表面：传播距离受到限制，一般只有 50 km左右。
100 m 高的天线塔：传播距离可增大到 100 km。

\item 多径效应
基站发出的信号可以经过多个障碍物的数次反射，从多条路径、按不同时间等到达接收方。多条路径的信号叠加后一般都会产生很大的失真，这就是所谓的多径效应。

\item 远距离微波通信：微波接力
微波接力：中继站把前一站送来的信号放大后再发送到下一站。

主要特点：
\begin{itemize}
\item 微波波段频率很高，频段范围很宽，其通信信道的容量很大。

\item 工业干扰和天电干扰对微波通信的危害小，微波传输质量较高。

\item 与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于实施。
\end{itemize}

主要缺点：
\begin{itemize}
\item 相邻站之间必须直视（常称为视距 LOS (Line Of Sight)），不能有障碍物，存在多径效应。

\item 有时会受到恶劣气候的影响。

\item 与电缆通信系统比较，微波通信的隐蔽性和保密性较差。

\item 对大量中继站的使用和维护要耗费较多的人力和物力。
\end{itemize}

\item 卫星通信
通信容量大，通信距离远，通信比较稳定，通信费用与通信距离无关。

传播时延较大：在 250\textasciitilde{}300 ms之间。
\end{enumerate}
\end{enumerate}
\subsubsection{信道复用技术}
\label{sec:org943eec5}

\begin{enumerate}
\item 频分复用、时分复用、统计时分复用
\label{sec:org7e9a3d2}

复用 (multiplexing) ：允许用户使用一个共享信道进行通信。
\begin{enumerate}
\item 频分复用
\label{sec:orgf0e9415}

最基本。

将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。

所有用户在同样的时间占用不同的带宽（即频带）资源。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-23-19-54_3840x1080.png}
\end{center}
\item 时分复用
\label{sec:org32e7e2a}

将时间划分为一段段等长的时分复用帧（TDM帧）。

每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。

每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。

TDM 信号也称为等时 (isochronous) 信号。

所有用户在不同的时间占用同样的频带宽度。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-23-20-18_3840x1080.png}
\end{center}
\begin{enumerate}
\item 频分多址与时分多址
\label{sec:org01c100a}

可让 N 个用户各使用一个频带，或让更多的用户轮流使用这 N 个频带。这种方式称为频分多址接入 FDMA (Frequency Division Multiple Access)，简称为频分多址。

可让 N 个用户各使用一个时隙，或让更多的用户轮流使用这 N 个时隙。这种方式称为时分多址接入 TDMA (Time Division Multiple Access)，简称为时分多址。
\item 复用器和分用器
\label{sec:orgc3c8adb}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-23-22-40_3840x1080.png}
\end{center}

时分复用会导致信道利用率不高

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-23-23-14_3840x1080.png}
\end{center}
\end{enumerate}
\item 统计时分复用
\label{sec:org412ac23}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-23-24-14_3840x1080.png}
\end{center}
\end{enumerate}
\item 波分复用
\label{sec:orga8b4206}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-23-27-08_3840x1080.png}
\end{center}
\item 码分复用
\label{sec:org0ad33fd}

每一个用户可以在同样的时间使用同样的频带进行通信。

各用户使用经过特殊挑选的不同码型，因此不会造成干扰。

当码分复用 CDM (Code Division Multiplexing) 信道为多个不同地址的用户所共享时，就称为码分多址 CDMA (Code Division Multiple Access)。
\begin{enumerate}
\item CDMA工作原理
\label{sec:orgecd83b5}

将每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。

为每个站指派一个唯一的 m bit 码片序列。

发送比特 1：发送自己的 m bit 码片序列。
发送比特 0：发送该码片序列的二进制反码。

\begin{itemize}
\item 码片序列实现了扩频

要发送信息的数据率 = b bit/s，实际发送的数据率 = mb bit/s，同时，所占用频带宽度也提高到原来的 m 倍。

扩频通常有 2 大类：

直接序列扩频 DSSS (Direct Sequence Spread Spectrum) 。

跳频扩频 FHSS (Frequency Hopping Spread Spectrum)。
\end{itemize}
\begin{enumerate}
\item 重要特点\hfill{}\textsc{CDMA码片序列计算}
\label{sec:org4328fd3}

\begin{enumerate}
\item 每个站分配的码片序列：各不相同，且必须互相正交 (orthogonal)。
\item 正交：向量 S 和 T 的规格化内积 (inner product) 等于 0。
\begin{equation}
  \mathbf{S} \cdot \mathbf{T} = \frac{1}{m}  \sum_{i=1}^m S_i T_i=0
\end{equation}
\item 任何一个码片向量和该码片向量自己的规格化内积都是 1 。
\begin{equation}
  \mathbf{S} \cdot \mathbf{S} = \frac{1}{m} \sum_{i=1}^m S_i S_i=1
\end{equation}
\item 一个码片向量和该码片反码的向量的规格化内积值是 –1。
\[
     \mathbf{S} \cdot \overline{\mathbf{S}} = -1
   \]
\end{enumerate}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-29-23-43-01_3840x1080.png}
\end{center}
\end{enumerate}
\end{enumerate}
\end{enumerate}
\subsubsection{数字传输系统}
\label{sec:orgefe60ce}

早期缺点

速率标准不统一。两个互不兼容的国际标准；

不是同步传输。主要采用准同步方式。
\begin{enumerate}
\item 同步光纤网
\label{sec:orgd3971bc}

各级时钟都来自一个非常精确的主时钟。 

为光纤传输系统定义了同步传输的线路速率等级结构。
\item 同步数字系列 SDH
\label{sec:orged784cb}

与 SONET 的主要不同：SDH 的基本速率为 155.52 Mbit/s，称为第 1 级同步传递模块 (Synchronous Transfer Module)，即 STM-1，相当于 SONET 体系中的 OC-3 速率。
\end{enumerate}
\subsubsection{宽带接入技术}
\label{sec:orgc97e4af}

从宽带接入的媒体来看，划分为 2 大类：
\begin{itemize}
\item 有线宽带接入。
\item 无线宽带接入。
\end{itemize}
\begin{enumerate}
\item ADSL技术
\label{sec:org255d0a2}

非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。

ADSL 的 ITU 的标准：G.992.1（或称 G.dmt）。

非对称：下行（从 ISP 到用户）带宽远大于上行（从用户到 ISP）带宽。
\begin{enumerate}
\item ADSL调制解调器
\label{sec:org85c65ff}

采用离散多音调 DMT（Discrete Multi-Tone）调制技术。

DMT 调制技术采用频分复用 FDM 方法。

相当于在一对用户线上使用许多小的调制解调器并行地传送数据。

ADSL 不能保证固定的数据率。
\item ADSL的组成
\label{sec:org841904f}

3 大组成部分：
数字用户线接入复用器 DSLAM（DSL Access Multiplexer），用户线和用户家中的一些设施。

ADSL 最大好处： \textbf{可以利用现有电话网中的用户线（铜线），而不需要重新布线。}
\item ADSL技术第二代
\label{sec:org6f5d008}

主要改进：
\begin{itemize}
\item 通过提高调制效率得到了更高的数据率。
\item 采用了无缝速率自适应技术 SRA (Seamless Rate Adaptation)。
\item 改善了线路质量评测和故障定位功能。
\end{itemize}

ADSL 并不适合于企业，因为企业往往需要使用上行信道发送大量数据给许多用户。
\end{enumerate}
\item 光纤同轴混合网（HFC网）
\label{sec:org32c1ad0}

HFC (Hybrid Fiber Coax) 网基于有线电视网 CATV 网。

改造：把原有线电视网中的同轴电缆主干部分改换为光纤

\uline{HFC 网具有双向传输功能，扩展了传输频带}
\begin{enumerate}
\item 机顶盒与电缆调制解调器（set-top box）
\label{sec:orge9040e6}

机顶盒（set-top box）：
  连接在同轴电缆和用户的电视机之间。
  使现有的模拟电视机能够接收数字电视信号。

电缆调制解调器（cable modem）：
  将用户计算机接入互联网。
  在上行信道中传送交互数字电视所需的一些信息。
  不需要成对使用，而只需安装在用户端。
  复杂，必须解决共享信道中可能出现的冲突问题。
\end{enumerate}
\item FTTx技术
\label{sec:org33dac3c}

代表多种宽带光纤接入方式。
FTTx 表示 Fiber To The…（光纤到…），例如：
光纤到户 FTTH (Fiber To The Home)：在光纤进入用户的家门后，才把光信号转换为电信号。
光纤到大楼 FTTB (Fiber To The Building)
光纤到路边 FTTC (Fiber To The Curb)
光纤到小区 FTTZ (Fiber To The Zone)
光纤到办公室 FTTO (Fiber To The Office)
光纤到桌面 FTTD (Fiber To The Desk) 等。
\begin{enumerate}
\item 光配线网 ODN (Optical Distribution Network)
\label{sec:org994d659}

光配线网 ODN (Optical Distribution Network)：位于光纤干线和广大用户之间。
无源的光配线网常称为无源光网络 PON (Passive Optical Network)。

采用波分复用 WDM，上行和下行分别使用不同的波长。

2 种最流行的无源光网络 PON (Passive Optical Network)：
\begin{itemize}
\item 以太网无源光网络 EPON (Ethernet PON)
在链路层使用以太网协议，利用 PON 的拓扑结构实现以太网的接入。
与现有以太网的兼容性好，并且成本低，扩展性强，管理方便。
\item 吉比特无源光网络 GPON (Gigabit PON)
采用通用封装方法 GEM (Generic Encapsulation Method)，可承载多业务，且对各种业务类型都能够提供服务质量保证，总体性能比EPON好。成本稍高。
\end{itemize}
\end{enumerate}
\end{enumerate}
\subsection{数据链路层}
\label{sec:org3f07715}

\subsubsection{使用点对点信道的数据链路层}
\label{sec:orgdcffdca}

\begin{enumerate}
\item 数据链路和帧
\label{sec:org6ee99c2}

\begin{itemize}
\item 链路

一条无源的点到点的物理线路段，中间没有任何其他的交换结点。

一条链路只是一条通路的一个组成部分。

或物理链路。

\item 数据链路
把实现控制数据传输的协议的硬件和软件加到链路上，就构成了数据链路。

或逻辑链路

典型实现：适配器（即网卡）

\item 数据链路层协议数据单元：帧

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-01-33-36_3840x1080.png}
\end{center}

\item 三个基本问题
\begin{enumerate}
\item 封装成帧

封装成帧 (framing)：在一段数据的前后分别添加首部和尾部，构成一个帧。
首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限）。

最大传送单元 MTU (Maximum Transfer Unit) ：规定了所能传送的帧的数据部分长度上限。

\item 透明传输
问题：如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”，导致错误。
用“字节填充”或“字符填充”法解决透明传输的问题

\item 差错控制
在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。

在传输过程中可能会产生比特差错：1    0， 0    1。

常用CRC循环冗余检验方法
\begin{enumerate}
\item 用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。
\item 得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q ，余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。
\item 将余数 R 作为冗余码拼接在数据 M 后面，一起发送出去。
\end{enumerate}
这种为了进行检错而添加的冗余码常称为帧检验序列 FCS (Frame Check Sequence)。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-02-20-43_3840x1080.png}
\end{center}

在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。
循环冗余检验 CRC 和帧检验序列 FCS 并不等同。
CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。
FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。
\end{enumerate}
\end{itemize}
\item PPP协议\hfill{}\textsc{PPP数据转换}
\label{sec:org0b0439d}

\begin{itemize}
\item 特点
对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。

PPP 协议在 1994 年就已成为互联网的正式标准

\item PPP协议应满足的需求
\begin{enumerate}
\item 简单——首要要求。

\item 封装成帧——必须规定特殊的字符作为帧定界符。

\item 透明性——必须保证数据传输的透明性。

\item 多种网络层协议——能够在同一条物理链路上支持多重网络层协议。

\item 多种类型链路——能够在多种类型的链路上运行。

\item 差错检测——能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。

\item 检测连接状态——能够及时自动检测出链路是否处于正常工作状态。

\item 最大传送单元——必须对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进各种实现之间的互操作性。

\item 网络层地址协商——必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。

\item 数据压缩协商——必须提供一种方法来协商使用数据压缩算法。
\end{enumerate}
\item PPP协议的组成
三个组成部分：
\begin{itemize}
\item 一个将 IP 数据报封装到串行链路的方法。

\item 一个链路控制协议 LCP (Link Control Protocol)。

\item 一套网络控制协议 NCP (Network Control Protocol)。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-02-37-14_3840x1080.png}
\end{center}
\end{itemize}

首部：4 个字段
  标志字段 F： 0x7E 。连续两帧之间只需要用一个标志字段。
  地址字段 A：只置为 0xFF。实际上不起作用。
  控制字段 C：通常置为 0x03。
  协议字段。
尾部：2 个字段。

\item 透明传输问题
当 PPP 用在异步传输时，使用字节填充法。

当 PPP 用在同步传输链路时，采用零比特填充法。

\begin{itemize}
\item 字节填充
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-02-43-37_3840x1080.png}
\end{center}

\item 零比特填充
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-02-44-18_3840x1080.png}
\end{center}
\end{itemize}
\end{itemize}
\begin{enumerate}
\item PPP协议的工作状态
\label{sec:org78deb3f}

PPP 链路初始化过程：
\begin{itemize}
\item 用户拨号接入 ISP 后，就建立了一条从用户个人电脑到 ISP 的物理连接。
\item 用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧），以便建立LCP连接。
\item 之后进行网络层配置。网络控制协议 NCP 给新接入的用户个人电脑分配一个临时的 IP 地址。
\item 当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的IP地址。LCP 释放数据链路层连接。最后释放的是物理层的连接。
\end{itemize}
\end{enumerate}
\item 局域网的数据链路层
\label{sec:org2cdcc5c}

\textbf{局域网最主要的特点：}
\begin{enumerate}
\item 网络为一个单位所拥有；
\item 地理范围和站点数目均有限。
\end{enumerate}
\textbf{局域网具有如下主要优点：}
\begin{enumerate}
\item 具有广播功能，从一个站点可很方便地访问全网。
\item 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。
\item 提高了系统的可靠性、可用性和生存性。
\end{enumerate}

共享信道带来的问题：
\uline{若多个设备在共享的广播信道上同时发送数据，则会造成彼此干扰，导致发送失败。}
\begin{enumerate}
\item 媒体共享技术
\label{sec:org1f773d2}
\begin{itemize}
\item 静态划分信道
\begin{enumerate}
\item 频分复用
\item 时分复用
\item 波分复用
\item 码分复用
\end{enumerate}
\item 动态媒体接入控制
\begin{enumerate}
\item 随机接入：所有的用户可随机地发送信息。
\item 受控接入：用户必须服从一定的控制，如轮询（polling）。
\end{enumerate}
\end{itemize}
\begin{enumerate}
\item 以太网的两个标准
\label{sec:org9633d76}
\begin{itemize}
\item 局域网数据链路层分为2个子层
逻辑链路控制 LLC (Logical Link Control) 子层：与传输媒体无关。
媒体接入控制 MAC (Medium Access Control) 子层：与传输媒体有关。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-03-07-21_3840x1080.png}
\end{center}

\item 适配器的作用
重要功能：
\begin{itemize}
\item 进行串行/并行转换。

\item 对数据进行缓存。

\item 在计算机的操作系统安装设备驱动程序。

\item 实现以太网协议。
\end{itemize}
\end{itemize}
\end{enumerate}
\item CSMA/CD协议
\label{sec:org8befabc}
最早的以太网：将许多计算机都连接到一根总线上。

总线特点：易于实现广播通信，简单，可靠。

为了实现一对一通信，将接收站的硬件地址写入帧首部中的目的地址字段中。仅当数据帧中的目的地址与适配器硬件地址一致时，才能接收这个数据帧。

总线缺点：多个站点同时发送时，会产生发送碰撞或冲突，导致发送失败。
\begin{enumerate}
\item 以太网采取的2种重要措施
\label{sec:org7552cc8}

\begin{enumerate}
\item 较为灵活的无连接的工作方式
不必先建立连接就可以直接发送数据。

对发送的数据帧不进行编号，也不要求对方发回确认。

提供不可靠的交付服务：尽最大努力的交付；对有差错帧是否需要重传则由高层来决定。

同一时间只能允许一台计算机发送：以太网采用最简单的随机接入；使用 CSMA/CD 协议减少冲突发生的概率。

\item 发送的数据都使用了曼彻斯特编码
曼彻斯特编码缺点：所占的频带宽度比原始的基带信号增加了一倍。

\item CSMA/CD协议的要点
\begin{itemize}
\item 多点接入
说明这是总线型网络。许多计算机以多点接入的方式连接在一根总线上。

\item 载波监听
即“边发送边监听”。不管在想要发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道。

\item 碰撞检测
适配器边发送数据，边检测信道上的信号电压的变化情况。电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞（或冲突）。
检测到碰撞后，适配器立即停止发送。等待一段随机事件后再次发送。
\end{itemize}
\item 为什么要进行碰撞检测？
因为信号传播时延对载波监听产生了影响。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-03-18-41_3840x1080.png}
\end{center}

\item 争用期
以太网的端到端往返时延 2 \(\delta\)  称为争用期，或碰撞窗口。
\end{enumerate}
具体的争用期时间 = 51.2 μs。

经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

\begin{itemize}
\item 碰撞后重传的时机
采用截断二进制指数退避 (truncated binary exponential backoff) 确定。

发生碰撞的站停止发送数据后，要退避一个随机时间后再发送数据。

\begin{enumerate}
\item 基本退避时间 = 2 \(\delta\)

\item 从整数集合 [0, 1, … , (2\^{}k - 1)] 中随机地取出一个数，记为 r。
重传所需的时延 =  r \texttimes{} 基本退避时间。

\item 参数 k = Min[重传次数, 10]

\item 当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。
\end{enumerate}

\item 10 Mbit/s以太网争用期的长度
争用期的长度 = 51.2 us

对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。

也就是说，以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突；以太网规定了最短有效帧长为 64 字节。凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧，应当立即将其丢弃；以太网最大端到端单程时延必须小于争用期的一半 (即 25.6 μs)，相当于以太网的最大端到端长度约为 5 km。

\item 强化碰撞：e人为干扰信号
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-03-38-34_3840x1080.png}
\end{center}

发送站检测到冲突后，立即停止发送数据帧，接着就发送 32 或 48 比特的人为干扰信号 (jamming signal) 。

以太网还规定了帧间最小间隔为 9.6 μs。

\item CSMA/CD协议的要点——总结
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-03-39-30_3840x1080.png}
\end{center}
\end{itemize}
\end{enumerate}
\item 使用集线器的星型拓扑
\label{sec:orgc9b06b8}
采用双绞线的以太网采用星形拓扑。

在星形的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub)。

集线器特点：
\begin{enumerate}
\item 使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。
\item 使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。
\item 很像一个多接口的转发器，工作在物理层。
\item 采用了专门芯片，进行自适应串音回波抵消，减少了近端串音。
\end{enumerate}
\end{enumerate}
\item 以太网的信道利用率
\label{sec:org86c7027}

多个站在以太网上同时工作就可能会发生碰撞。

当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到 100\%。

成功发送一个帧需要占用信道的时间是 T0 + τ ，比帧的发送时间要多一个单程端到端时延 τ 。

\begin{itemize}
\item 参数a和利用率

要提高以太网的信道利用率，就必须减小 \$ \(\tau\) \$ 与 T0 之比。

在以太网中定义了参数 a = 以太网单程端到端时延 \$ \(\tau\) \$ 与帧的发送时间 T0 之比：
\[
    a = \frac{ \tau }{T_0}
  \]

a → 0，表示一发生碰撞就立即可以检测出来， 并立即停止发送，因而信道利用率很高。

a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。

对a的要求
\begin{enumerate}
\item 为提高利用率，以太网的参数 a 的值应当尽可能小些。

\item 当数据率一定时，以太网的连线的长度受到限制，否则   的数值会太大。

\item 以太网的帧长不能太短，否则 T0 的值会太小，使 a 值太大。
\end{enumerate}

\item 信道利用率的最大值Smax
\[
    S_max=\frac{T_0}{T_0 + \tau}
  \]

只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率。

据统计，当以太网的利用率达到 30\% 时就已经处于重载的情况。
\end{itemize}
\item 以太网的MAC层
\label{sec:orged552ad}

\begin{enumerate}
\item MAC层的硬件地址
\label{sec:org51e318a}

硬件地址又称为物理地址，或 MAC 地址。 

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-04-00-50_1920x1080.png}
\end{center}

IEEE 注册管理机构 RA 负责向厂家分配前 3 个字节 (即高 24 位)，称为组织唯一标识符 OUI (Organizationally Unique Identifier)。

厂家自行指派后 3 个字节 (即低 24 位)，称为扩展标识符 (extended identifier)。

必须保证生产出的适配器没有重复地址。

地址被固化在适配器的 ROM 中。

IEEE 规定地址字段的第 1 字节的最低位为 I/G (Individual / Group) 位。

单站地址：I/G 位 = 0。
组地址：I/G 位 = 1。组地址用来进行多播。
广播地址：所有 48 位都为 1（全 1）。只能作为目的地址使用。

IEEE 把地址字段第 1 字节的最低第 2 位规定为 G/L (Global / Local) 位。

全球管理：G/L 位 = 0。厂商向 IEEE 购买的 OUI 都属于全球管理。
本地管理：G/L 位 = 1。 这时用户可任意分配网络上的地址。

\begin{itemize}
\item 适配器具有过滤功能
每收到一个 MAC 帧，先用硬件检查帧中的 MAC 地址。

如果是发往本站的帧则收下，然后再进行其他的处理。

否则就将此帧丢弃，不再进行其他的处理。
\end{itemize}

发送本站的帧有三种：
\begin{enumerate}
\item 单播 (unicast) 帧（一对一）
\item 广播 (broadcast) 帧（一对全体）
\item 多播 (multicast) 帧（一对多）

\item Mac帧的格式

最常用的 MAC 帧是以太网 V2 的格式。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-04-07-03_1920x1080.png}
\end{center}

类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。 

数据字段的正式名称是 MAC 客户数据字段。最小长度 64 字节 - 18 字节的首部和尾部 = 数据字段的最小长度（46字节

当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。 

由硬件在帧的前面插入 8 字节。第一个字段共 7 个字节，是前同步码，用来迅速实现 MAC 帧的比特同步。第二个字段 1 个字节是帧开始定界符，表示后面的信息就是 MAC 帧。
\end{enumerate}
\end{enumerate}
\item 拓展的以太网
\label{sec:orga25531d}

\begin{enumerate}
\item 在物理层拓展以太网
\label{sec:org0b5ce11}

\begin{itemize}
\item 使用光纤扩展

\item 使用集线器扩展
优点：使原来属于不同碰撞域（冲突域）的计算机能够跨碰撞域通信。扩大了以太网覆盖的地理范围。

缺点：碰撞域增大了，总的吞吐量未提高。如果使用不同的以太网技术（如数据率不同），那么就不能用集线器将它们互连起来。
\end{itemize}
\item 在数据链路层扩展以太网
\label{sec:orged78a4c}

更为常用。早期使用网桥，现在使用以太网交换机。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-04-11-24_1920x1080.png}
\end{center}

以太网交换机的特点：
实质上是一个多接口网桥。通常有十几个或更多的接口。

每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。

以太网交换机具有并行性。能同时连通多对接口，使多对主机能同时通信。相互通信的主机都独占传输媒体，无碰撞地传输数据。每一个端口和连接到端口的主机构成了一个碰撞域。

接口有存储器。

即插即用。其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。这种交换表就是一个内容可寻址存储器CAM (Content addressable Memory)。

使用专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。

优点：
每个用户独享带宽，增加了总容量

\begin{itemize}
\item 以太网交换机的交换方式

存储转发方式：把整个数据帧先缓存，再进行处理。

直通 (cut-through) 方式：接收数据帧的同时立即按数据帧的目的 MAC 地址决定该帧的转发接口；缺点：不检查差错就直接将帧转发出去，有可能转发无效帧。
\end{itemize}
\begin{enumerate}
\item 以太网的自学习功能
\label{sec:org4a65a5a}

存在的问题：回路

使用生成树协议消除回路，不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。
\item 虚拟局域网的优点
\label{sec:org1518001}

虚拟局域网（VLAN）技术具有以下主要优点：

\begin{enumerate}
\item 改善了性能

\item 简化了管理

\item 降低了成本

\item 改善了安全性

\item 划分虚拟局域网的方法
\begin{itemize}
\item 基于交换机端口

最简单、也是最常用的方法。
属于在第 1 层划分虚拟局域网的方法。
缺点：不允许用户移动。

\item 基于计算机网卡的 MAC 地址

根据用户计算机的 MAC 地址划分虚拟局域网。

属于在第 2 层划分虚拟局域网的方法。

允许用户移动。
\end{itemize}

缺点：需要输入和管理大量的 MAC 地址。如果用户的 MAC 地址改变了，则需要管理员重新配置VLAN。

\begin{itemize}
\item 基于协议类型
根据以太网帧的第三个字段“类型”确定该类型的协议属于哪一个虚拟局域网。
属于在第 2 层划分虚拟局域网的方法。

\item 基于 IP 子网地址
根据以太网帧的第三个字段“类型”和 IP 分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网。
属于在第 3 层划分虚拟局域网的方法。

\item 基于高层应用或服务
根据高层应用或服务、或者它们的组合划分虚拟局域网。

更加灵活，但更加复杂。
\end{itemize}
\end{enumerate}
\end{enumerate}
\end{enumerate}
\end{enumerate}
\subsection{网络层}
\label{sec:org373fd0e}

网络层的 2 个层面：数据层面和控制层面


\begin{itemize}
\item 数据层面
路由器根据本路由器生成的转发表，把收到的分组从查找到的对应接口转发出去。独立工作。采用硬件进行转发，快。
\item 控制层面
根据路由选择协议所用的路由算法计算路由，创建出本路由器的路由表。许多路由器协同动作。采用软件计算，慢。
\end{itemize}
\subsubsection{IP协议}
\label{sec:org11881a9}

与网际协议 IPv4 配套的 3 个协议：
地址解析协议 ARP (Address Resolution Protocol)
网际控制报文协议 ICMP (Internet Control Message Protocol)
网际组管理协议 IGMP (Internet Group Management Protocol)
\begin{enumerate}
\item 虚拟互联网络
\label{sec:org592f689}

使用转发器或网桥不称为网络互连

如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet)。
\item IP地址
\label{sec:org97afdd2}
互联网上的每台主机（或路由器）的每个接口分配一个在全世界唯一的 IP 地址。
由互联网名字和数字分配机构 ICANN (Internet Corporation for Assigned Names and Numbers) 进行分配。 

IP地址采用二级结构：网络号和主机号。

\begin{center}
\begin{tabular}{lrr}
IP类型 & net-id(byte) & host-id(byte)\\
\hline
A & 1 & 3\\
B & 2 & 2\\
C & 3 & 1\\
\end{tabular}
\end{center}

D类地址是多播地址，E类地址则是保留的。

\begin{itemize}
\item IP分类的优缺点
优点
\begin{itemize}
\item 管理简单；
\item 使用方便；
\item 转发分组迅速；
\item 划分子网，灵活地使用。
\end{itemize}
缺点
\begin{itemize}
\item 设计上不合理：
\item 大地址块，浪费地址资源；
\item 即使采用划分子网的方法，也无法解决 IP 地址枯竭的问题。
\end{itemize}

\item 无分类编址CIDR
消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，可以更加有效地分配 IPv4 的地址空间，但无法解决 IP 地址枯竭的问题。

\begin{enumerate}
\item 网络前缀
2 个字段：网络前缀和主机号

\item 地址块
CIDR 把网络前缀都相同的所有连续的 IP 地址组成一个 CIDR 地址块。
一个 CIDR 地址块包含的 IP 地址数目，取决于网络前缀的位数。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-09-43-40_1920x1080.png}
\end{center}

\item 地址掩码
目的：让机器从 IP 地址迅速算出网络地址。

由一连串 1 和接着的一连串 0 组成，而 1 的个数就是网络前缀的长度。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-09-46-38_1920x1080.png}
\end{center}
\end{enumerate}

构造超网
\begin{itemize}
\item 每一个 CIDR 地址块中的地址数一定是 2 的整数次幂。

\item 除最后几行外，CIDR 地址块都包含了多个 C 类地址（是一个 C 类地址的 2\^{}n 倍，n 是整数）。
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-09-54-34_1920x1080.png}
\end{center}

网络前缀越短，地址块所包含的地址数越多。
\end{itemize}
\begin{enumerate}
\item IP地址的特点
\label{sec:orgd6ae9cf}

\begin{enumerate}
\item 每个 IP 地址都由网络前缀和主机号两部分组成。

\item IP 地址是标志一台主机（或路由器）和一条链路的接口。

\item 转发器或交换机连接起来的若干个局域网仍为一个网络

\item 在 IP 地址中，所有分配到网络前缀的网络都是平等的。
\end{enumerate}

当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为多归属主机 (multihomed host)。

一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。

按照互联网的观点，一个网络（或子网）是指具有相同网络前缀的主机的集合。

具有不同网络号的局域网必须使用路由器进行互连。

同一个局域网上的主机或路由器的IP 地址中的网络号必须一样。

路由器的每一个接口都有一个不同网络号的 IP 地址。
\begin{enumerate}
\item IP地址和MAC地址比较
\label{sec:org9e9e7e9}
\begin{center}
\begin{tabular}{ll}
IP 地址 & MAC 地址\\
\hline
虚拟地址、软件地址、逻辑地址。 & 固化在网卡上的 ROM 中。硬件地址、物理地址。\\
网络层和以上各层使用。 & 数据链路层使用。\\
放在 IP 数据报的首部。 & 放在 MAC 帧的首部。\\
\end{tabular}
\end{center}
\end{enumerate}
\end{enumerate}
\item 地址解析协议 ARP
\label{sec:orgb61c29a}

实时IP通信时使用了两个地址：
\begin{itemize}
\item IP 地址（网络层地址）
\item MAC 地址（数据链路层地址）
\end{itemize}


\begin{itemize}
\item ARP 高速缓存 (ARP cache)

\begin{itemize}
\item 存放 IP 地址到 MAC 地址的映射表。

\item 映射表动态更新（新增或超时删除）。

\item 超过生存时间的项目都从高速缓存中删除，以适应网络适配器变化。
\end{itemize}

作用：
\begin{itemize}
\item 存放最近获得的 IP 地址到 MAC 地址的绑定。

\item 减少 ARP 广播的通信量。

\item 为进一步减少 ARP 通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到 MAC 地址的映射写入 ARP 请求分组。

\item 当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的 IP 地址及其对应的 MAC 地址映射写入主机 B 自己的 ARP 高速缓存中。不必在发送 ARP 请求。
\end{itemize}
\end{itemize}


\begin{itemize}
\item Arp工作
\begin{itemize}
\item 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-10-15-10_1920x1080.png}
\end{center}
\end{itemize}

\item ARP 查找 IP 地址对应的 MAC地址

\begin{itemize}
\item 本局域网上广播发送 ARP 请求（路由器不转发 ARP 请求）。

\item ARP 请求分组：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址(未知时填 0) / 目标方 IP 地址。

\item 播 ARP 响应分组：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址。

\item ARP 分组封装在以太网帧中传输。
\end{itemize}

\item 2 台主机不在同一个局域网上怎么办？

ARP 用于解决同一个局域网上的主机或路由器的 IP 地址和 MAC 地址的映射问题。

\item 使用ARP的四种情况
\begin{itemize}
\item 发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。

\item 发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。

\item 发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。

\item 发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。
\end{itemize}
\end{itemize}
\item IP数据报的格式
\label{sec:org24bb396}

IP 数据报由首部和数据两部分组成


\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-10-25-33_1920x1080.png}
\end{center}

首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。

版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)。

首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。

区分服务——占 8 位，用来获得更好的服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段 

总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。

标识 (identification) ——占 16 位，它是一个计数器，用来产生 IP 数据报的标识。 

标志(flag) ——占 3 位，目前只有前两位有意义。

标志字段的最低位是 MF (More Fragment)。MF=1 表示后面还有分片，MF=0 表示最后一个分片。标志字段中间的一位是 DF (Don't Fragment) 。只有当 DF=0 时才允许分片。 

片偏移——占 13 位，指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。

生存时间——占 8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值。

协议——占 8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程

首部检验和——占 16 位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 
\item IP层转发分组的过程
\label{sec:orgd3397e4}

\begin{enumerate}
\item 基于终点的转发
分组在互联网中是逐跳转发的。

基于终点的转发：基于分组首部中的目的地址传送和转发。

为了压缩转发表的大小，转发表中最主要的路由是（目的网络地址，下一跳地址） ，而不是（目的地址，下一跳地址）。查找转发表的过程就是逐行寻找前缀匹配。

\item 最长前缀匹配
使用 CIDR 时，在查找转发表时可能会得到不止一个匹配结果。 

最长前缀匹配 (longest-prefix matching) 原则：选择前缀最长的一个作为匹配的前缀。

网络前缀越长，其地址块就越小，因而路由就越具体。

可以把前缀最长的排在转发表的第 1 行。

转发表中的2种特殊路由
\begin{itemize}
\item 主机路由 (host route) ：
是对特定目的主机的 IP 地址专门指明的一个路由。

网络前缀就是 a.b.c.d/32

放在转发表的最前面。

\item 默认路由 (default route)

不管分组的最终目的网络在哪里，都由指定的路由器 R 来处理

用特殊前缀 0.0.0.0/0 表示。
\end{itemize}
\end{enumerate}


\begin{enumerate}
\item 使用二叉线索查找转发表

二叉线索 (binary trie)：一种特殊结构的树，可以快速在转发表中找到匹配的叶节点。

从二叉线索的根节点自顶向下的深度最多有 32 层，每一层对应于 IP 地址中的一位。

为简化二叉线索的结构，可以用唯一前缀 (unique prefix) 来构造二叉线索。

为了提高二叉线索的查找速度，广泛使用了各种压缩技术。
\end{enumerate}
\item ICMP协议
\label{sec:org8a7fea7}

ICMP (Internet Control Message Protocol) 允许主机或路由器报告差错情况和提供有关异常情况的报告。

ICMP 是互联网的标准协议。

但 ICMP 不是高层协议，而是 IP 层的协议。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-11-53-37_3840x1080.png}
\end{center}

\begin{itemize}
\item ICMP报文的种类
2 种：差错报告报文，询问报文。
\end{itemize}

\begin{center}
\begin{tabular}{lrl}
ICMP报文种类 & 类型的值 & ICMP报文的类型\\
\hline
差错报告报文 & 3 & 终点不可达\\
 & 11 & 时间超过\\
 & 12 & 参数问题\\
 & 5 & 改变路由\\
询问报文 & 8或0 & 回送请求或回答\\
 & 13或14 & 时间戳请求或应答\\
\end{tabular}
\end{center}

不应发送ICMP差错报告报文的几种情况
\begin{itemize}
\item 对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。
\item 对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。
\item 对具有多播地址的数据报都不发送 ICMP 差错报告报文。
\item 对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。
\end{itemize}
\begin{enumerate}
\item ICMP询问报文
\label{sec:orga15f7e9}
\begin{enumerate}
\item 回送请求和回答
\begin{itemize}
\item 由主机或路由器向一个特定的目的主机发出的询问。
\item 收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。
\item 这种询问报文用来测试目的站是否可达，以及了解其有关状态。
\end{itemize}
\item 时间戳请求和回答
\begin{itemize}
\item 请某台主机或路由器回答当前的日期和时间。
\item 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从1900 年 1 月 1 日起到当前时刻一共有多少秒。
\item 时间戳请求与回答可用于时钟同步和时间测量。
\end{itemize}
\end{enumerate}
\item ICMP的应用举例
\label{sec:org2d8e6ea}
PING (Packet InterNet Groper)：
\begin{itemize}
\item 用来测试两个主机之间的连通性。
\item 使用了 ICMP 回送请求与回送回答报文。
\item 是应用层直接使用网络层 ICMP 的例子，没有通过运输层的 TCP 或 UDP。
\end{itemize}
\end{enumerate}
\item IPv6
\label{sec:orgf826b41}

\begin{enumerate}
\item 基本首部
\label{sec:org66594d0}
IPv6 仍支持无连接的传送。

将协议数据单元 PDU 称为分组 (packet) 。

主要变化：
\begin{itemize}
\item 更大的地址空间。 将地址从 IPv4 的 32 位 增大到了 128 位。
\item 扩展的地址层次结构。可以划分为更多的层次。
\item 灵活的首部格式。定义了许多可选的扩展首部。
\item 改进的选项。允许数据报包含有选项的控制信息，其选项放在有效载荷中。
\item 允许协议继续扩充。更好地适应新的应用。
\item 支持即插即用（即自动配置）。不需要使用 DHCP。
\item 支持资源的预分配。支持实时视像等要求保证一定的带宽和时延的应用。
\item IPv6 首部改为 8 字节对齐。首部长度必须是 8 字节的整数倍。
\end{itemize}
\item 数据包的一般形式
\label{sec:org9f1bf12}
\begin{enumerate}
\item 基本首部
\item 有效载荷。有效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部 (extension header)，再后面是数据部分。
\end{enumerate}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-12-11-44_3840x1080.png}
\end{center}
\item IPv6的地址
\label{sec:org2f8b6e9}
三种基本类型：
\begin{enumerate}
\item 单播：传统的点对点通信。
\item 多播：一点对多点的通信。
\item 任播：IPv6增加的一种类型。任播的终点是一组计算机。但是数据包在交付时只交付其中的一个。
\end{enumerate}
\end{enumerate}
\item 互联网路由选择协议
\label{sec:orgb0e88c0}

路由选择协议属于网络层控制层面的内容

\textbf{静态路由} ： 非自适应路由选择；不能及时适应网络状态的变化；简单，开销较小。

\textbf{动态路由} ： 自适应路由选择；能较好地适应网络状态的变化；实现较为复杂，开销较大。

\begin{itemize}
\item 分层次的路由选择协议
互联网：采用自适应的（即动态的）、分布式路由选择协议。把整个互联网划分为许多较小的自治系统 AS，采用分层次的路由选择协议。

分为两个层次：
\begin{itemize}
\item 自治系统之间的路由选择 或 域间路由选择 (interdomain routing)；

\item 自治系统内部的路由选择 或 域内路由选择 (intradomain routing)；
\end{itemize}

\item 两大类路由选择协议
\begin{itemize}
\item 内部网关协议IGP
Interior Gateway Protocol
在一个自治系统内部使用的路由选择协议
常用：RIP，OSPF
\item 外部网关协议 EGP
External Gateway Protocol
在不同自治系统之间进行路由选择时使用的协议
使用最多：BGP-4
\end{itemize}
\end{itemize}
\begin{enumerate}
\item RIP协议
\label{sec:org427fcf3}
路由信息协议 RIP (Routing Information Protocol) 是一种分布式的、基于距离向量的路由选择协议。

互联网的标准协议。

最大优点：简单。

要求网络中的每个路由器都要维护从它自己到其他每一个目的网络的距离记录。 

\begin{itemize}
\item RIP距离的定义
路由器到直接连接的网络的距离 = 1。

路由器到非直接连接的网络的距离 = 所经过的路由器数 + 1。

RIP 协议中的“距离”也称为“跳数”(hop count)，每经过一个路由器，跳数就加 1。

好路由 = “距离短”的路由。最佳路由 = “距离最短”的路由。

一条路径最多只能包含 15 个路由器。

“距离”的最大值为 16 时即相当于不可达。

RIP 不能在两个网络之间同时使用多条路由，只选择距离最短”的路由。
\item 特点
\begin{enumerate}
\item 仅和相邻路由器交换信息。

\item 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。

\item 按固定时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。
\end{enumerate}

\item 路由表的建立
\begin{enumerate}
\item 路由器在刚刚开始工作时，路由表是空的。

\item 然后，得到直接连接的网络的距离（此距离定义为 1）。

\item 之后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。

\item 经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。

\item RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。
\end{enumerate}
\item 路由表主要信息和更新规则
\begin{itemize}
\item 主要信息
\begin{center}
\begin{tabular}{lll}
目的网络 & 距离（最短） & 下一跳地址\\
\hline
 &  & \\
 &  & \\
 &  & \\
\end{tabular}
\end{center}
\item 路由表更新规则
使用距离向量算法找出到达每个目的网络的最短距离。
\end{itemize}

\item 距离向量算法
对每个相邻路由器（假设其地址为 X）发送过来的 RIP 报文，路由器：
\begin{enumerate}
\item 修改RIP报文的所有项目（即路由）：把下一跳字段中的地址都改为X,并把所有的距离字段的值+1。

\item 对修改后的RIP报文中的每一个项目，重复以下步骤：
\begin{itemize}
\item 若路由表中没有目的网络N，则把该项目添加到路由表中。

\item 否则若路由表中网络 N 的下一跳路由器为 X，则用收到的项目替换原路由表中的项目。

\item 否则若收到项目中的距离小于路由表中的距离，则用收到项目更新原路由表中的项目。

\item 否则什么也不做。
\end{itemize}
\item 若 3 分钟还未收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为 16（表示不可达）。

\item 返回
\end{enumerate}

算法基础：Bellman-Ford算法。
要点：设 X 是结点 A 到 B 的最短路径上的一个结点。若把路径 A→B 拆成两段路径 A→X 和 X→B，则每一段路径 A→X 和 X→B 也都分别是结点 A 到 X 和结点 X 到 B 的最短路径。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-12-53-53_3840x1080.png}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-12-55-52_3840x1080.png}
\end{center}

\item 坏消息传播得慢

RIP 协议特点：好消息传播得快，坏消息传播得慢。

问题：坏消息传播得慢（慢收敛）。

当网络出现故障时，要经过比较长的时间才能将此信息（坏消息）传送到所有的路由器。

\item 优点/缺点
优点：实现简单，开销较小

缺点：
\begin{enumerate}
\item 网络规模有限，最大距离为15（16表示不可达）。

\item 交换的路由信息为完整的路由表，开销较大。

\item 坏消息传播得满，收敛时间长。
\end{enumerate}
\end{itemize}
\item 内部网关协议OSPF
\label{sec:org2523d0f}

使用了 Dijkstra 提出的最短路径算法 SPF。

采用分布式的链路状态协议 (link state protocol)。

三个主要特点：
\begin{enumerate}
\item 采用洪泛法 (flooding)，向本自治系统中所有路由器发送信息。
\item 发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。
\begin{itemize}
\item 链路状态：说明本路由器都和哪些路由器相邻，以及该链路的度量 (metric)。
\end{itemize}
\item 当链路状态发生变化或每隔一段时间（如30分钟），路由器才用洪泛法向所有路由器发送此信息。
\end{enumerate}


\begin{itemize}
\item 链路状态数据库
\begin{enumerate}
\item 每个路由器最终都能建立。
\item 全网的拓扑结构图。
\item 在全网范围内是一致的（这称为链路状态数据库的同步）。
\item 每个路由器使用链路状态数据库中的数据构造自己的路由表（例如，使用Dijkstra的最短路径路由算法）。
\end{enumerate}
\end{itemize}

重要优点：OSPF 更新过程收敛速度快。

OSPF 将自治系统划分为两种不同的区域 (area)

OSPF 中的路由器：区域边界路由器 ABR (area border router)

OSPF 中的路由器：主干路由器 BR (backbone router)

OSPF 中的路由器：自治系统边界路由器 ASBR (AS border router）

\begin{itemize}
\item 划分区域优点和缺点
\begin{itemize}
\item 优点
\begin{itemize}
\item 减少了整个网络上的通信量。
\item 减少了需要维护的状态数量。
\end{itemize}
\item 缺点
\begin{itemize}
\item 交换信息的种类增多了。
\item 使 OSPF 协议更加复杂了。
\end{itemize}
\end{itemize}
\item 其它特点
\begin{enumerate}
\item 对于不同类型的业务可计算出不同的路由。
\item 可实现多路径间的负载均衡（load balancing）。
\item 所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。
\item 支持可变长度的子网划分和无分类编址 CIDR。
\item 32 位的序号，序号越大状态就越新。全部序号空间在 600 年内不会产生重复号。
\end{enumerate}
\end{itemize}
\begin{enumerate}
\item 五种分组类型
\label{sec:org2d4ed61}
\begin{enumerate}
\item 问候分组
\item 数据库描述 (Database Description) 分组。
\item 链路状态请求 (Link State Request) 分组。
\item 链路状态更新 (Link State Update) 分组。
\item 链路状态确认 (Link State Acknowledgment)分组。
\end{enumerate}
\item 工作流程
\label{sec:org177000d}
\begin{enumerate}
\item 确认邻站可达
\begin{itemize}
\item 相邻路由器每隔 10 秒钟要交换一次问候分组。
\item 若有 40 秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的。
\end{itemize}
\item 同步链路状态数据库
\begin{itemize}
\item 同步：指不同路由器的链路状态数据库的内容是一样的。
\item 两个同步的路由器叫做完全邻接的 (fully adjacent) 路由器。
\end{itemize}
\item 更新链路状态
\begin{itemize}
\item 只要链路状态发生变化，路由器就使用链路状态更新分组，采用可靠的洪泛法向全网更新链路状态。
\item 为确保链路状态数据库与全网的状态保持一致，OSPF 还规定：每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。
\end{itemize}
\end{enumerate}

OSPF 没有“坏消息传播得慢”的问题，收敛数度快。

OSPF 使用可靠的洪泛法发送更新分组。

\begin{itemize}
\item 指定的路由器DR
\begin{itemize}
\item 多点接入的局域网采用了指定的路由器 DR (designated router) 的方法，使广播的信息量大大减少。
\item 指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。
\end{itemize}
\end{itemize}
\end{enumerate}
\item 外部网关协议BGP
\label{sec:orgd94cd6c}

BGP 是不同自治系统的路由器之间交换路由信息的协议。 

\begin{itemize}
\item 主要特点
\begin{itemize}
\item 用于自治系统 AS 之间的路由选择。
\item 只能是力求选择出一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要计算出一条最佳路由。
\begin{enumerate}
\item 互联网的规模太大，使得自治系统AS之间路由选择非常困难。
\item 自治系统AS之间的路由选择必须考虑有关策略。
\end{enumerate}
\item 采用了路径向量 (path vector) 路由选择协议。
\end{itemize}
\item eBGP和iBGP连接
在 AS 之间， BGP 发言者在半永久性 TCP 连接（端口号为179）上建立 BGP 会话(session)。这种连接又称为 eBGP 连接。

在 AS 内部，任何相互通信的两个路由器之间必须有一个逻辑连接（也使用 TCP 连接）。AS 内部所有的路由器之间的通信是全连通的。这种连接常称为 iBGP 连接。

eBGP (external BGP) 连接：运行 eBGP 协议，在不同 AS 之间交换路由信息。

iBGP (internal BGP) 连接：运行 iBGP 协议， 在 AS 内部的路由器之间交换 BGP 路由信息。

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-13-41-33_3840x1080.png}
\end{center}

\item eBGP和iBGP
\begin{itemize}
\item 同一个协议 BGP（使用的报文类型、使用的属性、使用的状态机等都完全一样）。

\item 但它们在通报前缀时采用的规则不同：
\begin{enumerate}
\item 在 eBGP 连接的对等端得知的前缀信息，可以通报给一个 iBGP 连接的对等端。反过来也是可以的。

\item 但从 iBGP 连接的对等端得知的前缀信息，则不能够通报给另一个 iBGP 连接的对等端。
\end{enumerate}
\end{itemize}
\end{itemize}
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-13-44-20_3840x1080.png}
\end{center}

\begin{itemize}
\item BGP路由信息
BGP 路由 = [ 前缀, BGP属性 ] = [ 前缀, AS-PATH, NEXT-HOP ]

前缀：指明到哪一个子网（用 CIDR 记法表示）。

BGP 属性：最重要的两个属性是：
\begin{enumerate}
\item 自治系统路径 AS-PATH
\item 下一跳 NEXT-HOP。
\end{enumerate}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-13-50-50_3840x1080.png}
\end{center}

AS2 可经 IP3a 到前缀 X 的路由 = [前缀, AS-PATH, NEXT-HOP] = [X, AS3, IP3a]

路由 1：AS1 可经 IP2a 到前缀 X 的路由 = [前缀, AS-PATH, NEXT-HOP] = [X, AS2 AS3, IP2a]

路由2：AS1 可经 IP3c 到前缀 X 的路由 = [前缀, AS-PATH, NEXT-HOP] = [X, AS3, IP3c]

路由器 R1a 的转发表中，沿 BGP 路由 1 到达前缀 X 的项目是：（匹配前缀X，下一跳路由器 R1b）或（匹配前缀X，转发接口 0）。

\item 三种不同的自治系统AS
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-13-51-54_3840x1080.png}
\end{center}

末梢 AS：不会把来自其他 AS 的分组再转发到另一个 AS。必须向所连接的 AS 付费。

多归属 AS (multihomed AS)：同时连接到两个或两个以上的 AS。增加连接的可靠性。

穿越 AS：为其他 AS 有偿转发分组。

对等 AS：经过事先协商的两个 AS，彼此之间的发送或接收分组都不收费。
\end{itemize}
\begin{enumerate}
\item BGP的路由选择
\label{sec:orgbb9dd1a}
\begin{enumerate}
\item 本地偏好值最高的路由
\item AS跳数最少的路由
\item 使用热土豆选择算法（分组在AS内的转发次数最少）
\item 路由器BGP ID数值最小的路由。具有多个接口的路由器有多个IP地址，BGP ID就使用该路由器的IP地址中数值最大的一个。
\end{enumerate}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-13-56-27_3840x1080.png}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-13-59-06_3840x1080.png}
\end{center}
\end{enumerate}
\item 路由器的构成
\label{sec:org20400fa}

路由器工作在网络层，用于互连网络。

互联网中的关键设备。

路由器的主要工作：转发分组。

把从某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。

\begin{itemize}
\item 转发和路由选择的区别
\end{itemize}
\begin{center}
\begin{tabular}{ll}
转发 & 路由选择\\
\hline
根据转发表将用户的IP数据包从合适的端口转发出去 & 按照路由选择算法，根据网络拓扑的变化情况，动态的改变所选择的路由，并由此构造出整个的路由表。\\
仅涉及到一个路由器 & 多个路由器\\
转发表是从路由表得出的。 & 涉及到很多路由器\\
转发表必须包含完成转发功能所必需的信息，每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息（如下一条的以太网地址）的映射。 & 路由表一般仅包含从目的网络到下一跳的映射\\
\end{tabular}
\end{center}

\begin{itemize}
\item 输入端口对线路上收到的分组的处理
\begin{enumerate}
\item 物理层处理：从输入端口接收比特
\item 数据链路层：剥去帧的首部和尾部
\item 网络层处理分组排队/查表和转发：若收到的分组是交换路由信息的分组，送交路由选择处理机。若收到的是数据分组，按目的地址查找转发表，根据得出的结果，经交换结构到达合适的输出端口。若某分组正在查找转发表，该分组排队等待。
\end{enumerate}

\item 输出端口将交换结构传送来的分组发送到线路
\begin{enumerate}
\item 网络层处理分组排队/缓存管理：从交换结构接收分组。当交换结构传送的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须缓存在队列中。若分组处理的速率赶不上分组进入队列的速率，队列满时，丢弃后面进入的分组。
\item 数据链路层处理：给分组加上链路层的首部和尾部。
\item 物理层处理：发送到输出线路上。
\end{enumerate}
\end{itemize}
\begin{enumerate}
\item 三种交换结构
\label{sec:org2249a2e}
\begin{enumerate}
\item 通过存储器
\begin{itemize}
\item 当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。
\item 路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。
\item 若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）一定小于 M/2。
\end{itemize}
\item 通过总线
\begin{itemize}
\item 数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。
\item 当分组到达输入端口时若发现总线忙，则被阻塞而不能通过交换结构，并在输入端口排队等待。
\item 因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。
\end{itemize}
\item 通过互联网络
\begin{itemize}
\item 它有 2N 条总线，控制交叉节点可以使 N 个输入端口和 N 个输出端口相连接。
\item 当输入端口收到一个分组时，就将它发送到水平总线上。
\item 若通向输出端口的垂直总线空闲，则将垂直总线与水平总线接通，把该分组转发到这个输出端口。若输出端口已被占用，分组在输入端口排队等待。
\item 特点：是一种无阻塞的交换结构，分组可以转发到任何一个输出端口，只要这个输出端口没有被别的分组占用。
\end{itemize}
\end{enumerate}
\item 为什么路由器的端口有物理地址，而网桥（交换机）的端口没有物理地址？
\label{sec:orgf45185b}
\begin{center}
\begin{tabular}{lll}
比较 & 交换机 & 路由器\\
\hline
工作层次 & 交换机工作在链路层，是一个二层设备，主要根据MAC地址转发数据帧。 & 工作在网络层，根据IP转发数据包。\\
转发机制 & 交换机根据接收到的帧的目标MAC地址，查询其MAC地址表，转发到对应MAC地址；如果查表找不到，就会把数据帧广播到所有端口（除了来源端口）。交换机自己并不负责生成或者修改数据帧，只需要进行转发，所以他的端口不需要物理地址 & 当数据包到达路由器时，路由器会查看数据包的目标 IP 地址，并根据路由表决定将数据包转发到哪个下一跳。在转发过程中，路由器需要将数据包封装进新的数据帧，并指定新的目标 MAC 地址和源 MAC 地址。数据帧在数据链路层传输时，需要有源 MAC 地址和目标 MAC 地址。路由器的每个端口需要有自己的 MAC 地址，作为源地址写入帧头中。这样，当数据包离开路由器的端口时，下一跳设备才能识别该帧的发送者，并正确回复。\\
结果 & 交换机的端口不主动参与通信，它只是作为转发的中介，不需要标识自己，因此端口不需要物理地址。 & 路由器的端口需要参与数据的生成和终止过程（拆解旧数据帧、生成新数据帧），所以必须有物理地址来标识自己。\\
\end{tabular}
\end{center}
\end{enumerate}
\end{enumerate}
\end{enumerate}
\subsubsection{IP多播}
\label{sec:org723725f}

多播 (multicast)：以前曾译为组播。

目的：更好地支持一对多通信。

一对多通信：一个源点发送到许多个终点。

在 IP 多播数据报的目的地址需要写入多播组的标识符。

多播组的标识符就是 IP 地址中的 D 类地址（多播地址）。
	地址范围：224.0.0.0 \textasciitilde{} 239.255.255.255

每一个 D 类地址标志一个多播组。
\begin{enumerate}
\item 网际组管理协议IGMP
\label{sec:org23f8283}

在 IGMP 报文加上 IP 首部构成 IP 数据报。

但 IGMP 也向 IP 提供服务。

因此，不把 IGMP 看成是一个单独的协议，而是整个网际协议 IP 的一个组成部分。

\begin{itemize}
\item 分为两个阶段
\begin{enumerate}
\item 加入多播组。
\begin{itemize}
\item 当某个主机加入多播组时，该主机向多播组的多播地址发送 IGMP 报文，声明自己要成为该组的成员。
\item 本地的多播路由器收到 IGMP 报文后，将组成员关系转发给互联网上的其他多播路由器。
\end{itemize}

\item 探询组成员变化情况。
\begin{itemize}
\item 本地多播路由器周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。
\item 只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。
\end{itemize}
\end{enumerate}

\item IGMP采用的一些具体措施，以避免增加大量开销
\begin{itemize}
\item 分散相应。

\item 抑制机制。
\end{itemize}
\end{itemize}
\item 多播路由选择
\label{sec:orgb079f8f}
\begin{enumerate}
\item 洪泛与剪除
适合于较小的多播组，所有组成员接入的局域网也是相邻接的。

开始时，路由器转发多播数据报使用洪泛的方法（这就是广播）。

为避免兜圈子，采用反向路径广播 RPB (Reverse Path Broadcasting) 的策略。
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-15-01-49_3840x1080.png}
\end{center}

\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-15-02-47_3840x1080.png}
\end{center}

剪枝：如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播组的成员，就把它和下游的树枝一起剪除。

嫁接：当某个树枝有新增加的组成员时，可以再接入到多播转发树上。

\item 隧道技术
\begin{center}
\includegraphics[width=.9\linewidth]{/home/jask/Pictures/Screenshots/Screenshot_2024-12-30-15-04-03_3840x1080.png}
\end{center}

\item 基于核心的发现技术
\begin{itemize}
\item 对于多播组的大小在较大范围内变化时都适合。

\item 对每一个多播组 G 指定一个核心 (core) 路由器，并给出它的 IP 单播地址。

\item 核心路由器按照前面讲过的 2 种方法创建出对应于多播组 G 的转发树（核心路由器为根节点）。

\item 为一个多播组构建一棵转发树，而不是为每个（源，组）组合构建一棵转发树。

\item 构建转发树开销较小，扩展性较好。

\item 如果有一个路由器 R1 向核心路由器发送数据报，那么它在途中经过的每一个路由器都要检查其内容。

\item 当数据报到达参加了多播组 G 的路由器 R2 时，R2 就处理这个数据报。

\item 如果 R1 发出的是一个多播数据报，其目的地址是 G 的组地址，R2 就向 G 的成员转发这个多播数据报。

\item 如果 R1 发出的数据报是一个请求加入多播组 G 的数据报，R2 就把这个信息加到它的路由中，并用隧道技术向 R1 转发每一个多播数据报的副本。
\end{itemize}
\end{enumerate}
\end{enumerate}
\subsubsection{VPN和NAT}
\label{sec:org2fded4c}

三个专用 IP 地址块：
\begin{enumerate}
\item 10.0.0.0/8。A类，从 10.0.0.0 到 10.255.255.255。1 个。
\item 172.16.0.0/12。B类，从 172.16.0.0 到 172.31.255.255。连续 16 个。
\item 192.168.0.0/16。C类，从 192.168.0.0 到 192.168.255.255。连续 256 个。
\end{enumerate}
\begin{enumerate}
\item 多协议标签交换MPLS
\label{sec:orgc41f855}

MPLS (MultiProtocol Label Switching)：互联网建议标准。

\textbf{多协议} ：在 MPLS 的上层可以采用多种协议。

\textbf{标签} ：MPLS 利用面向连接技术，使每个分组携带一个叫做标签 (label) 的小整数。标签交换路由器用标签值检索转发表，实现分组的快速转发。

MPLS 并没有取代 IP，而是作为一种 IP 增强技术。

特点：
\begin{enumerate}
\item 支持面向连接的服务质量；
\item 支持流量工程，平衡网络负载；
\item 有效地支持虚拟专用网 VPN。
\end{enumerate}
\begin{enumerate}
\item 工作原理
\label{sec:org97903c9}

\begin{enumerate}
\item MPLS基本工作过程

\begin{itemize}
\item 在 MPLS 域的入口处，给每一个 IP 数据报打上固定长度标签。

\item 对打上标签的 IP 数据报在第二层（链路层）用硬件进行转发。

\item 采用硬件技术对打上标签的 IP 数据报进行转发就称为标签交换。

\item 可以使用多种数据链路层协议，如 PPP、以太网、ATM 以及帧中继等。
\end{itemize}

\item MPLS域
MPLS 域 (MPLS domain) ：指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持 MPLS 技术的标记交换路由器 LSR (Label Switching Router)。

LSR 同时具有标记交换和路由选择这两种功能。标记交换功能是为了快速转发，路由选择功能是为了构造转发表。
\end{enumerate}
\item 基本工作过程
\label{sec:org4bdefaf}
\begin{enumerate}
\item 找出标签交换路径 LSP。
各 LSR 使用标签分配协议 LDP (Label Distribution Protocol) 交换报文，找出和标签相对应的标签交换路径 LSP (Label Switched Path)。整个标签交换路径就像一条虚连接一样。
\item 打标签，然后转发。
入口节点 (ingress node) 给进入 MPLS 域的 IP 数据报打上标签（实际上是插入一个 MPLS 首部），并按照转发表把它转发给下一个 LSR。以后的所有 LSR 都按照标签进行转发。

给 IP 数据报打标签的过程叫做分类 (classification)。
\item 标签对换。
一个标签仅在两个 LSR 之间才有意义。

LSR 要做两件事：转发，更新标记。

更新标记：把入标记更换成为出标记。称之为标签对换 (label swapping)。
\item 去除标签。

当分组离开 MPLS 域时，MPLS 出口节点 (egress node) 把分组的标签去除。

把 IP 数据报交付给非 MPLS 的主机或路由器。
\end{enumerate}
这种“由入口 LSR 确定进入 MPLS 域以后的转发路径”称为显式路由选择 (explicit routing)
\item 转发等价类FEC
\label{sec:orgbd692d8}
给 IP 数据报打标签的过程叫做分类。
\begin{enumerate}
\item 第三层（网络层）分类：只使用 IP 首部中的源和目的 IP 地址等。
\item 大多数运营商实现了第四层（运输层）分类：除了要检查 IP 首部外，运输层还要检查 TCP 或 UDP 端口号。
\item 有些运营商则实现了第五层（应用层）分类：进一步地检查数据报的内部并考虑其有效载荷。
\end{enumerate}

转发等价类FEC: 路由器按照同样方式对待的分组的集合。

按照同样方式对待含义：从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。

特点：
\begin{enumerate}
\item 划分 FEC 的方法不受限制，由网络管理员来控制。
\item 入口节点并不是给每一个 IP 数据报指派一个不同的标签，而是将属于同样 FEC 的 IP 数据报都指派同样的标签。
\item FEC 和标签是一一对应的关系。
\end{enumerate}
\end{enumerate}
\end{enumerate}
\subsection{无线局域网}
\label{sec:orgd8cb254}
组成：有固定基础设施和无固定基础设施。

星形拓扑、中心叫做接入点AP。

AP是无线局域网的基础设施、链路层设备。

AP也叫无线接入点WAP。

无线局域网中的站点对网内/网外的通信都必须通过WAP。

在MAC层使用CSMA/CA协议。

802.11系列又叫做WIFI。

基本服务集BSS是无线局域网的最小构件。一个BSS包括一个接入点AP和若干移动站。

必须为一个AP分配不超过32字节的服务集标识符SSID和一个通信信道。

一个BSS覆盖范围叫做BSA基本服务区。
\subsubsection{建立关联}
\label{sec:org15c4c9b}
主动扫描、被动扫描。
\subsubsection{信道p}
\label{sec:orgf0e7ae6}
每一个AP有一个唯一的48位MAC地址，叫做基本服务集标识符BSSID。无线局域网的各种帧首部都必须有节点的MAC地址。
\subsubsection{移动自组网络}
\label{sec:orga0523cc}

优点：
\begin{itemize}
\item 方便灵活
\item 生存性好
\end{itemize}
缺点：
\begin{itemize}
\item 服务范围受限
\end{itemize}
\subsubsection{802.11隐蔽站问题/暴露节点？}
\label{sec:org39e2bc2}
隐藏节点：由于距离太远而导致一个站点无法检测到介质竞争对手的存在。

暴露节点指由于侦听到其他站点的发送而误以为介质忙导致不能发送，和隐藏节点正好相反。

无线局域网802.11中，没有监听到载波，不代表可以传输。

暴露节点和隐藏节点问题是无线局域网802.11特有的，802.3是没有的，所以对于802.11有一种特殊的解决隐藏节点问题的机制，也就是RTS和CTS。

RTS/CTS机制的基本思想：用短的控制包来预留出带宽。

\begin{enumerate}
\item 发送方通过发送RTS请求请求发送。
\item 接收方用CTS回应发送请求
\item CTS为发送方预留带宽的同时通告所有节点
\end{enumerate}
\section{题目}
\label{sec:org5fb3bb7}
\subsection{基于端口的VLAN工作在链路层，结合网络层、链路层以及VLAN相关协议原理，说明基于Ping命令验证VLAN结果的合理性。}
\label{sec:org5bf2060}

\subsubsection{VLAN 和链路层的原理}
\label{sec:org228a43f}

广播域隔离：基于端口的 VLAN 将交换机的端口划分为不同的广播域。一个 VLAN 内的设备可以相互通信，不同 VLAN 之间的通信需要通过三层设备（如路由器或三层交换机）的转发。

标记与转发：在支持 IEEE 802.11 标准的网络中，链路层帧可以通过 VLAN 标记（Tagging）来标识其所属的 VLAN。当帧在未标记的 VLAN 端口上传输时，交换机会根据配置移除或添加 VLAN Tag。
\subsubsection{Ping 命令的原理和作用}
\label{sec:org311211f}
Ping 命令工作在网络层（OSI 第三层），依赖于 ICMP 协议 来发送和接收回显请求和回显应答。这些包最终封装为链路层帧，在网络中传输。

Ping 的特点：

\begin{itemize}
\item 验证主机之间的连通性：可以验证目标主机是否可达。
\item 传输依赖链路层：Ping 数据包需要网络层 IP 地址与链路层 MAC 地址的映射（通过 ARP 协议完成），并通过链路层进行传输。
\end{itemize}
\subsubsection{VLAN 与 Ping 的结合}
\label{sec:orgd191234}
Ping 命令的结果可以合理验证 VLAN 的配置效果，原因如下：
\begin{enumerate}
\item 同一 VLAN 的连通性验证
\begin{itemize}
\item 同一 VLAN 的主机在相同的广播域中，可以通过交换机直接转发帧，无需三层设备介入。
\item 若 Ping 成功：
\begin{itemize}
\item VLAN 配置正确。
\item ARP 请求能够在同一 VLAN 内广播并获得响应。
\item 数据帧的转发未受阻。
\end{itemize}
\item 若 Ping 失败：
\begin{itemize}
\item VLAN 配置可能错误（如主机不在同一 VLAN 内）。
\item 链路层或网络层出现问题（如 IP 配置错误）。
\end{itemize}
\end{itemize}
\item 不同 VLAN 的隔离性验证
\begin{itemize}
\item 不同 VLAN 之间的通信需要通过三层设备进行路由，直接发送的广播帧不会跨越 VLAN。
\item 若直接 Ping 失败：VLAN 隔离配置有效。
\item 若 Ping 成功：存在跨 VLAN 路由或三层交换配置。
\end{itemize}
\end{enumerate}
\end{document}
