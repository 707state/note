<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>标准库容器 - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#%E7%BA%BF%E6%80%A7%E5%AE%B9%E5%99%A8">线性容器</a>
<ul>
<li><a href="#array">array</a></li>
<li><a href="#vector">vector</a></li>
<li><a href="#deque">deque</a></li>
<li><a href="#forward_list">forward_list</a></li>
<li><a href="#list">list</a></li>
</ul>
</li>
<li><a href="#associative-containers">associative
containers</a>
<ul>
<li><a href="#set">set</a></li>
<li><a href="#multiset">multiset</a></li>
<li><a href="#map">map</a></li>
<li><a href="#multimap">multimap</a></li>
</ul>
</li>
<li><a href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%9E%8B%E5%AE%B9%E5%99%A8">无序关联型容器</a>
<ul>
<li><a href="#unordered_set">unordered_set</a></li>
<li><a href="#unordered_map">unordered_map</a></li>
<li><a href="#unordered_multimap-unordered_multiset">unordered_multimap,
unordered_multiset</a></li>
</ul>
</li>
<li><a href="#container-adapter">container adapter</a>
<ul>
<li><a href="#stack">stack</a></li>
<li><a href="#deque-1">deque</a></li>
<li><a href="#priority_queue">priority_queue</a></li>
<li><a href="#flat_set-since-c23">flat_set (since
c++23)</a></li>
</ul>
</li>
<li><a href="#views-%E8%A7%86%E5%9B%BE">views 视图</a>
<ul>
<li><a href="#span">span</a></li>
<li><a href="#mdspan">mdspan</a></li>
</ul>
</li>
<li><a href="#numeric">numeric</a>
<ul>
<li><a href="#partial_sum">partial_sum</a></li>
</ul>
</li>
<li><a href="#algorithm">algorithm</a>
<ul>
<li><a href="#fill">fill</a></li>
</ul>
</li>
</ul>
<h1 id="线性容器"><a class="header" href="#线性容器">线性容器</a></h1>
<h2 id="array"><a class="header" href="#array">array</a></h2>
<p>固定长度的序列，array&lt;T,size_t&gt;，但是固定长度不代表内存分配在栈上。</p>
<p>cppreference介绍如下：</p>
<blockquote>
<p>This container is an aggregate type with the same semantics as a
struct holding a C-style array T[N] as its only non-static data
member. Unlike a C-style array, it doesn't decay to T*
automatically. As an aggregate type, it can be initialized with
aggregate-initialization given at most N initializers that are
convertible to T: std::array&lt;int, 3&gt; a = {1, 2, 3};.</p>
</blockquote>
<hr />
<p>这个容器与一个拥有T[N]作为成员的结构体语义相同。</p>
<h2 id="vector"><a class="header" href="#vector">vector</a></h2>
<p>cppreference:</p>
<blockquote>
<ol>
<li>std::vector is a sequence container that encapsulates dynamic size
arrays.</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>std::pmr::vector is an alias template that uses a polymorphic
allocator.</li>
</ol>
</blockquote>
<hr />
<p>对动态申请内存的封装。</p>
<h2 id="deque"><a class="header" href="#deque">deque</a></h2>
<p>cppreference:</p>
<blockquote>
<p>std::deque (double-ended queue) is an indexed sequence container that
allows fast insertion and deletion at both its beginning and its end.
In addition, insertion and deletion at either end of a deque never
invalidates pointers or references to the rest of the elements.</p>
</blockquote>
<blockquote>
<p>As opposed to std::vector, the elements of a deque are not stored
contiguously: typical implementations use a sequence of individually
allocated fixed-size arrays, with additional bookkeeping, which means
indexed access to deque must perform two pointer dereferences,
compared to vector's indexed access which performs only one.</p>
</blockquote>
<blockquote>
<p>The storage of a deque is automatically expanded and contracted as
needed. Expansion of a deque is cheaper than the expansion of a
std::vector because it does not involve copying of the existing
elements to a new memory location. On the other hand, deques typically
have large minimal memory cost; a deque holding just one element has
to allocate its full internal array (e.g. 8 times the object size on
64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is
larger, on 64-bit libc++).</p>
</blockquote>
<p>这里就说了，deque用的是两个array和额外的标记，也就是说从下标访问deque需要执行两次指针解引用。</p>
<h2 id="forward_list"><a class="header" href="#forward_list">forward_list</a></h2>
<p>单向链表</p>
<p>cppreference:</p>
<blockquote>
<p>std::forward_list is a container that supports fast insertion and
removal of elements from anywhere in the container. Fast random access
is not supported. It is implemented as a singly-linked list. Compared
to std::list this container provides more space efficient storage when
bidirectional iteration is not needed.</p>
</blockquote>
<blockquote>
<p>Adding, removing and moving the elements within the list, or across
several lists, does not invalidate the iterators currently referring
to other elements in the list. However, an iterator or reference
referring to an element is invalidated when the corresponding element
is removed (via erase_after) from the list.</p>
</blockquote>
<p>支持快速从容器任何位置的插入和删除。</p>
<h2 id="list"><a class="header" href="#list">list</a></h2>
<p>双向链表</p>
<p>cppreference:</p>
<blockquote>
<p>std::list is a container that supports constant time insertion and
removal of elements from anywhere in the container. Fast random access
is not supported. It is usually implemented as a doubly-linked list.
Compared to std::forward_list this container provides bidirectional
iteration capability while being less space efficient.</p>
</blockquote>
<blockquote>
<p>Adding, removing and moving the elements within the list or across
several lists does not invalidate the iterators or references. An
iterator is invalidated only when the corresponding element is
deleted.</p>
</blockquote>
<p>注意，forward_list,
list虽然都是线性容器，但是不支持下标访问（没有重载），因此，要做到访问可以用std::advance作为解决方案。</p>
<p>插入和删除可以用迭代器+要插入的元素/要插入的范围来完成，会在对应的迭代器后面添加一个新的元素。</p>
<p>可以指定次数。</p>
<h1 id="associative-containers"><a class="header" href="#associative-containers">associative containers</a></h1>
<p>关联容器</p>
<h2 id="set"><a class="header" href="#set">set</a></h2>
<p>原型:</p>
<pre><code class="language-cpp">template&lt;
    class Key,
    class Compare=std::less&lt;Key&gt;,
    class Allocator=std::allocator&lt;Key&gt;
&gt; class set;
</code></pre>
<p>暂时不考虑pmr。</p>
<p>cppreference:</p>
<blockquote>
<p>std::set is an associative container that contains a sorted set of
unique objects of type Key. Sorting is done using the key comparison
function Compare. Search, removal, and insertion operations have
logarithmic complexity. Sets are usually implemented as Red--black
trees.</p>
</blockquote>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements,
uniqueness is determined by using the equivalence relation. In
imprecise terms, two objects a and b are considered equivalent if
neither compares less than the other: !comp(a, b) &amp;&amp; !comp(b, a).</p>
</blockquote>
<p>底层实现使用的是（自平衡二叉查找树）红黑树，但是标准委员会实际上并不要求实现细节的统一，而只要求实现行为的统一。</p>
<p>set保证元素的有序，这是因为红黑树是保证顺序的。</p>
<h2 id="multiset"><a class="header" href="#multiset">multiset</a></h2>
<p>cppreference:</p>
<blockquote>
<p>std::multiset is an associative container that contains a sorted set
of objects of type Key. Unlike set, multiple keys with equivalent
values are allowed. Sorting is done using the key comparison function
Compare. Search, insertion, and removal operations have logarithmic
complexity.</p>
</blockquote>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements,
equivalence is determined by using the equivalence relation as
described on Compare. In imprecise terms, two objects a and b are
considered equivalent if neither compares less than the other:
!comp(a, b) &amp;&amp; !comp(b, a).</p>
</blockquote>
<p>注意，multiset也是红黑树，并且允许用count方法来统计键的数量。</p>
<h2 id="map"><a class="header" href="#map">map</a></h2>
<p>原型:</p>
<pre><code class="language-cpp">template&lt;
    class Key,
    class T,
    class Compare=std::less&lt;Key&gt;,
    class Allocator=std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class map;
</code></pre>
<p>cppreference:</p>
<blockquote>
<p>std::map is a sorted associative container that contains key-value
pairs with unique keys. Keys are sorted by using the comparison
function Compare. Search, removal, and insertion operations have
logarithmic complexity. Maps are usually implemented as Red--black
trees.</p>
</blockquote>
<blockquote>
<p>Iterators of std::map iterate in ascending order of keys, where
ascending is defined by the comparison that was used for construction.
That is, given</p>
</blockquote>
<pre><code> m, a std::map

it_l and it_r, dereferenceable iterators to m, with it_l &lt; it_r. 

 m.value_comp()(*it_l, *it_r) == true (least to greatest if using the default comparison).
</code></pre>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements,
uniqueness is determined by using the equivalence relation. In
imprecise terms, two objects a and b are considered equivalent (not
unique) if neither compares less than the other: !comp(a, b) &amp;&amp;
!comp(b, a).</p>
</blockquote>
<p>底层实现通常采用红黑树，每一个pair&lt;K,V&gt;中的K对应二叉树中的树节点的值，因此必须实现大小比较。</p>
<h2 id="multimap"><a class="header" href="#multimap">multimap</a></h2>
<p>也是采用的红黑树实现，</p>
<h1 id="无序关联型容器"><a class="header" href="#无序关联型容器">无序关联型容器</a></h1>
<h2 id="unordered_set"><a class="header" href="#unordered_set">unordered_set</a></h2>
<p>注意，unordered_set不使用平衡二叉树，而是哈希表。</p>
<p>cppreference:</p>
<blockquote>
<p>std::unordered_set is an associative container that contains a set of
unique objects of type Key. Search, insertion, and removal have
average constant-time complexity.</p>
</blockquote>
<blockquote>
<p>Internally, the elements are not sorted in any particular order, but
organized into buckets. Which bucket an element is placed into depends
entirely on the hash of its value. This allows fast access to
individual elements, since once a hash is computed, it refers to the
exact bucket the element is placed into.</p>
</blockquote>
<blockquote>
<p>Container elements may not be modified (even by non const iterators)
since modification could change an element's hash and corrupt the
container.</p>
</blockquote>
<p>注意第三段说的，iterator指向的元素不可以被修改。</p>
<h2 id="unordered_map"><a class="header" href="#unordered_map">unordered_map</a></h2>
<p>内部实现是哈希表。</p>
<p>原型:</p>
<pre><code class="language-cpp">template&lt;

    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class unordered_map;
</code></pre>
<p>cppreference:</p>
<blockquote>
<p>std::unordered_map is an associative container that contains key-value
pairs with unique keys. Search, insertion, and removal of elements
have average constant-time complexity.</p>
</blockquote>
<blockquote>
<p>Internally, the elements are not sorted in any particular order, but
organized into buckets. Which bucket an element is placed into depends
entirely on the hash of its key. Keys with the same hash code appear
in the same bucket. This allows fast access to individual elements,
since once the hash is computed, it refers to the exact bucket the
element is placed into.</p>
</blockquote>
<blockquote>
<p>Two keys are considered equivalent if the map's key equality
predicate returns true when passed those keys. If two keys are
equivalent, the hash function must return the same value for both
keys.</p>
</blockquote>
<p>基本概念：</p>
<ol>
<li>
<p>哈希函数：将键转化为整数索引；好的哈希函数应该尽可能均匀地分布键值，减少哈希冲突。</p>
</li>
<li>
<p>桶（bucket）：哈希表通常是用一个固定大小的桶，每个数组元素称为一个桶；每一个桶可以存储一个/多个键值对。</p>
</li>
<li>
<p>冲突解决：</p>
<p>链地址法：每个桶存储一个链表或类似的数据结构，用于处理冲突。</p>
<p>开放地址法：当发生冲突时，寻找下一个可用的桶位置。</p>
</li>
</ol>
<h2 id="unordered_multimap-unordered_multiset"><a class="header" href="#unordered_multimap-unordered_multiset">unordered_multimap, unordered_multiset</a></h2>
<p>都是用的哈希表来实现的。</p>
<p>通常是用链地址法处理冲突。</p>
<h1 id="container-adapter"><a class="header" href="#container-adapter">container adapter</a></h1>
<p>一种设计模式，将现有容器包装成新的容器类型，通常用于实现stack, queue,
priority_queue, flat_set, flat_map等。</p>
<h2 id="stack"><a class="header" href="#stack">stack</a></h2>
<p>cppreference:</p>
<blockquote>
<p>The std::stack class is a container adaptor that gives the programmer
the functionality of a stack - specifically, a LIFO (last-in,
first-out) data structure.</p>
</blockquote>
<blockquote>
<p>The class template acts as a wrapper to the underlying container -
only a specific set of functions is provided. The stack pushes and
pops the element from the back of the underlying container, known as
the top of the stack.</p>
</blockquote>
<p>一种LIFO数据结构的抽象，常用的实现方法有数组和链表。</p>
<h2 id="deque-1"><a class="header" href="#deque-1">deque</a></h2>
<p>cppreference:</p>
<blockquote>
<p>The std::queue class template is a container adaptor that gives the
functionality of a queue - specifically, a FIFO (first-in, first-out)
data structure.</p>
</blockquote>
<blockquote>
<p>The class template acts as a wrapper to the underlying container -
only a specific set of functions is provided. The queue pushes the
elements on the back of the underlying container and pops them from
the front.</p>
</blockquote>
<p>提供了一种FIFO的数据结构，也是数组/链表实现。</p>
<h2 id="priority_queue"><a class="header" href="#priority_queue">priority_queue</a></h2>
<p>cppreference:</p>
<blockquote>
<p>The priority queue is a container adaptor that provides constant time
lookup of the largest (by default) element, at the expense of
logarithmic insertion and extraction.</p>
</blockquote>
<blockquote>
<p>A user-provided Compare can be supplied to change the ordering, e.g.
using std::greater<code>&lt;T&gt;</code>{=html} would cause the smallest element to
appear as the top().</p>
</blockquote>
<blockquote>
<p>Working with a priority_queue is similar to managing a heap in some
random access container, with the benefit of not being able to
accidentally invalidate the heap.</p>
</blockquote>
<p>优先级队列通常使用堆（Heap）数据结构来实现，因为堆能够在 O(log n)
时间内完成插入和删除操作，同时能够在 O(1) 时间内找到优先级最高的元素。</p>
<p>使用数组实现堆</p>
<p>堆通常使用数组来实现，数组的索引关系可以表示树的结构。对于一个索引为 i
的节点：</p>
<pre><code>其父节点的索引为 (i - 1) / 2。
其左子节点的索引为 2 * i + 1。
其右子节点的索引为 2 * i + 2。
</code></pre>
<p>堆的基本操作</p>
<pre><code>插入操作（Push）：将新元素添加到数组的末尾，然后向上调整（Heapify Up）以保持堆的性质。
删除操作（Pop）：移除堆顶元素，将数组的最后一个元素移动到堆顶，然后向下调整（Heapify Down）以保持堆的性质。
构建堆：从数组构建堆的过程可以通过自底向上的方式来完成。
</code></pre>
<h2 id="flat_set-since-c23"><a class="header" href="#flat_set-since-c23">flat_set (since c++23)</a></h2>
<p>cppreference:</p>
<blockquote>
<p>he flat set is a container adaptor that gives the functionality of an
associative container that stores a sorted set of unique objects of
type Key. Sorting is done using the key comparison function Compare.</p>
</blockquote>
<blockquote>
<p>The class template flat_set acts as a wrapper to the underlying sorted
container passed as object of type KeyContainer.</p>
</blockquote>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements,
uniqueness is determined by using the equivalence relation.
Informally, two objects a and b are considered equivalent if neither
compares less than the other: !comp(a, b) &amp;&amp; !comp(b, a).</p>
</blockquote>
<p>flat_set 的设计目的是提供一种类似于 std::set
的有序集合，但使用不同的内部实现来优化某些操作的性能。</p>
<pre><code>内部实现：flat_set 内部使用一个动态数组（通常是 std::vector）来存储元素。这意味着元素是连续存储的，而不是像 std::set 那样使用红黑树。
排序：元素在插入时会自动排序，确保集合中的元素始终是有序的。
性能：由于使用数组实现，flat_set 在某些操作上可能会比 std::set 更快，尤其是在迭代和随机访问方面。但是，插入和删除操作的时间复杂度通常较高，为 O(n)，因为需要保持数组的有序性。
内存效率：由于使用连续的内存存储，flat_set 通常比 std::set 更节省内存。
</code></pre>
<h1 id="views-视图"><a class="header" href="#views-视图">views 视图</a></h1>
<h2 id="span"><a class="header" href="#span">span</a></h2>
<p>std::span
是一个非拥有、可变长的数组视图。它提供了一个安全的、非拥有的方式来引用一个数组或数组的一部分。std::span
可以用于函数参数，避免不必要的数据复制，提高性能。</p>
<p>非拥有：std::span 不拥有它引用的数据，因此数据必须在其生命周期内有效。</p>
<p>轻量级：std::span 只包含一个指针和一个大小，非常轻量。</p>
<p>类型安全：std::span 是类型安全的，可以避免类型错误。</p>
<p>灵活：可以引用任何连续的内存区域，包括数组、std::vector、std::array 等。</p>
<h2 id="mdspan"><a class="header" href="#mdspan">mdspan</a></h2>
<p>std::mdspan 是 std::span
的多维扩展，用于表示多维数组视图。它提供了一种安全的、非拥有的方式来引用多维数组或数组的一部分。</p>
<p>特点</p>
<p>多维支持：std::mdspan 支持任意维度的数组视图。</p>
<p>灵活的布局：可以指定不同的内存布局，例如行优先（row-major）或列优先（column-major）。</p>
<p>类型安全：std::mdspan 是类型安全的，可以避免类型错误。</p>
<p>轻量级：std::mdspan 也只包含必要的信息，非常轻量。</p>
<h1 id="numeric"><a class="header" href="#numeric">numeric</a></h1>
<h2 id="partial_sum"><a class="header" href="#partial_sum">partial_sum</a></h2>
<p>std::partial_sum
会按照给定的范围，将每个位置的元素替换为从起始位置到当前位置所有元素的累积结果。</p>
<p>返回值：指向输出范围中最后一个元素的下一个位置。</p>
<pre><code class="language-cpp">namespace std {
    template&lt;class InputIt, class OutputIt&gt;
    OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first);

    template&lt;class InputIt, class OutputIt, class BinaryOperation&gt;
    OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first, BinaryOperation op);
}
</code></pre>
<p>典型应用场景</p>
<p>计算累积和：如统计总和的变化趋势。</p>
<p>模拟前缀数组：在算法问题中，用来快速处理子数组的和。</p>
<p>几何变换或积分计算：累积多步的计算结果。</p>
<p>自定义操作累积：使用自定义操作（如乘法、最大值等）进行更复杂的累计。</p>
<h1 id="algorithm"><a class="header" href="#algorithm">algorithm</a></h1>
<h2 id="fill"><a class="header" href="#fill">fill</a></h2>
<p>td::fill 将给定范围 [first, last) 中的每个元素都赋值为一个指定值。</p>
<p>std::reduce
用于将范围内的所有元素通过一个二元操作（默认加法）进行归约（reduce），类似于
std::accumulate，但可以并行执行。</p>
<p>返回值是规约后的结果。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../cpp/深度探索C++对象模型（总结篇）.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../cpp/SSO.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../cpp/深度探索C++对象模型（总结篇）.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../cpp/SSO.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
