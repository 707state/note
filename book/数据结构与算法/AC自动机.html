<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AC 自动机 - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="aho-corasick-algorithm"><a class="header" href="#aho-corasick-algorithm">Aho-Corasick Algorithm</a></h1>
<p>字符串搜索算法：用于在输入的一串字符串中匹配有限组“字典”中的子串。</p>
<p>它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。</p>
<p>算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。然而由于需要找到所有匹配数，如果每个子串互相匹配（如字典为a，aa，aaa，aaaa，输入的字符串为aaaa），算法的时间复杂度会近似于匹配的二次函数。</p>
<p>该算法主要依靠构造一个有限状态机（类似于在一个trie树中添加失配指针）来实现。这些额外的失配指针允许在查找字符串失败时进行回退（例如设Trie树的单词cat匹配失败，但是在Trie树中存在另一个单词cart，失配指针就会指向前缀ca），转向某前缀的其他分支，免于重复匹配前缀，提高算法效率。</p>
<h2 id="前缀函数"><a class="header" href="#前缀函数">前缀函数</a></h2>
<p>一个长度为n的字符串s，前缀函数就是一个长度为n的数组n。其中n[i]的定义：</p>
<p>如果字串t[0..i]有一对相等的真前缀和真后缀：s[0..k-1]和s[i-(k-1)..i]，那么n[i]就是这个相等的真前缀的长度k，即n[i]=k。</p>
<p>如果有不止一对相等的，那么n[i]就是其中最长的那一对的长度。</p>
<p>如果没有相等的，那么n[i]就是0。</p>
<p>规定: n[0]=0。</p>
<p>朴素实现：</p>
<details>
<pre><code class="language-cpp">vector&lt;int&gt; prefix_function(string s) {
  int n = (int)s.length();
  vector&lt;int&gt; pi(n);
  for (int i = 1; i &lt; n; i++)
    for (int j = i; j &gt;= 0; j--)
      if (s.substr(0, j) == s.substr(i - j + 1, j)) {
        pi[i] = j;
        break;
      }
  return pi;
}
</code></pre>
</details>
<p>这个算法的时间复杂度是O(n^3)。</p>
<p>第一个优化：</p>
<p>相邻的前缀函数值至多增加1。所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。</p>
<p>这时的实现：</p>
<details>
<pre><code class="language-cpp">vector&lt;int&gt; prefix_function(string s) {
  int n = (int)s.length();
  vector&lt;int&gt; pi(n);
  for (int i = 1; i &lt; n; i++)
    for (int j = pi[i - 1] + 1; j &gt;= 0; j--)  // improved: j=i =&gt; j=pi[i-1]+1
      if (s.substr(0, j) == s.substr(i - j + 1, j)) {
        pi[i] = j;
        break;
      }
  return pi;
}
</code></pre>
</details>
<p>这里，再计算每一个n[i]时，最好的情况是第一次字符串比较就完成匹配。</p>
<p>由此我们可以得出字符串比较次数最多的一种情况：至少 1 次字符串比较次数的消耗和最多 n-2 次比较次数的积累，此时字符串比较次数为 n-1 + n-2 = 2n-3。</p>
<p>可见经过此次优化，计算前缀函数只需要进行 O(n) 次字符串比较，总复杂度降为了 O(n^2) 。</p>
<p>第二个优化：</p>
<p>当s[i+1]!=s[n[i]]时怎么跳转，也就是失配时怎么跳转。</p>
<p>失配时，我们希望找到对于字串s[0..i]仅次于n[i]的第二长度j, 使得在位置i的前缀性质仍然能够保持，也就是s[0..j-1]=s[i-j+1..i。</p>
<p>如果我们找到这样的j，那么仅需要比较s[i+1]和s[j]，就有n[i+1]=j+1。否则就需要找到字串s[0..i]仅次于j的第二长度k, 使得前缀树的性质能够保持，反复之后，如果s[i+1]!=s[0]。，则n[i+1]=0。</p>
<p>这是可以注意到：</p>
<p>因为s[0..n[i]-1]=s[i-n[i]+1..i]，所以对于s[0..i]的第二长度j，有如下性质：</p>
<p>s[0..j-1]=s[i-k+1..i]=s[n[i]-j..n[i]-1]。</p>
<p>也就是说，j等价于字串s[n[i]-1]的前缀函数值，即j=n[n[i]-1]；同理，次于j的第二长度k=n[j-1]。</p>
<p>因此就可以得到转移方程：</p>
<p>\( j^{n}=n[j^{n-1}-1]   \)</p>
<p>最终实现：</p>
<pre><code class="language-cpp">vector&lt;int&gt; prefix_function(string s) {
  int n = (int)s.length();
  vector&lt;int&gt; pi(n);
  for (int i = 1; i &lt; n; i++) {
    int j = pi[i - 1];
    while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1];
    if (s[i] == s[j]) j++;
    pi[i] = j;
  }
  return pi;
}
</code></pre>
<p>这是一个 在线 算法，即其当数据到达时处理它——举例来说，你可以一个字符一个字符的读取字符串，立即处理它们以计算出每个字符的前缀函数值。该算法仍然需要存储字符串本身以及先前计算过的前缀函数值，但如果我们已经预先知道该字符串前缀函数的最大可能取值 [M] ，那么我们仅需要存储该字符串的前 [M + 1] 个字符以及对应的前缀函数值。</p>
<h1 id="应用"><a class="header" href="#应用">应用</a></h1>
<h2 id="knuth-morris-pratt算法"><a class="header" href="#knuth-morris-pratt算法">Knuth-Morris-Pratt算法</a></h2>
<h3 id="过程"><a class="header" href="#过程">过程</a></h3>
<p>给定一个文本 [t] 和一个字符串 [s] ，我们尝试找到并展示 [s] 在 [t] 中的所有出现（occurrence）。</p>
<p>为了简便起见，我们用 [n] 表示字符串 [s] 的长度，用 [m] 表示文本 [t] 的长度。</p>
<p>我们构造一个字符串 [s + # + t] ，其中 [#] 为一个既不出现在 [s] 中也不出现在 [t] 中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始 [n + 1] 个值（即属于字符串 [s] 和分隔符的函数值）后其余函数值的意义。</p>
<p>根据定义，n[i]为右端点在i且同时为一个前缀的最长真子串的长度，其值为与s的前缀相同且右端点位于i的最长子串的长度。</p>
<p>由于分隔符的存在，该长度不可能超过 n。而如果等式 n[i] = n 成立，则意味着 [s] 完整出现在该位置（即其右端点位于位置 [i] ）。注意该位置的下标是对字符串 [s + # + t] 而言的。</p>
<p>因此如果在某一处位置i有n[i]==n出现，则字符串s在字符串t的i-(n-1)-(n+1)=i-2*n的位置出现。</p>
<p>正如在前缀函数的计算中已经提到的那样，如果我们知道前缀函数的值永远不超过一特定值，那么我们不需要存储整个字符串以及整个前缀函数，而只需要二者开头的一部分。在我们这种情况下这意味着只需要存储字符串 [s + #] 以及相应的前缀函数值即可。我们可以一次读入字符串 [t] 的一个字符并计算当前位置的前缀函数值。</p>
<p>实现如下：</p>
<pre><code class="language-cpp">vector&lt;int&gt; find_occurrences(string text, string pattern) {
  string cur = pattern + '#' + text;
  int sz1 = text.size(), sz2 = pattern.size();
  vector&lt;int&gt; v;
  vector&lt;int&gt; lps = prefix_function(cur);
  for (int i = sz2 + 1; i &lt;= sz1 + sz2; i++) {
    if (lps[i] == sz2) v.push_back(i - 2 * sz2);
  }
  return v;
}
</code></pre>
<h3 id="字符串的周期"><a class="header" href="#字符串的周期">字符串的周期</a></h3>
<p>对于字符串s和0 &lt; p &lt; |s|，如果s[i]=s[i+p]对0到|s|-p-1的i都成立，就称p是s的周期。</p>
<p>对于字符串s和0&lt;=r&lt;=|s| , 若s长度为r的前缀和长度为r的后缀相等，就称s长度为r的前缀是s的Border。</p>
<p>简单来说，一个“border”是指既是一个前缀又是一个后缀的非空子串，但不包括整个字符串本身。</p>
<p>由s有长度为r的border可以推导出|s|-r是s的周期。</p>
<p>根据前缀函数的定义，可以得到s所有的border长度，即n[n-1], n[n[n-1]-1]。</p>
<p>所以根据前缀函数可以在 O(n) 的时间内计算出 [s] 所有的周期。</p>
<h1 id="ac自动机"><a class="header" href="#ac自动机">AC自动机</a></h1>
<p>AC 自动机本质上是 Trie 上的自动机。</p>
<p>建立一个AC自动机有两个步骤：</p>
<ol>
<li>
<p>基础的Trie结构：将所有的模式构建成一个Trie；</p>
</li>
<li>
<p>KMP的思想：对Trie上的所有节点构造失配指针。</p>
</li>
</ol>
<p>建立完毕后，就可以利用它进行多模式匹配。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../数据结构与算法/数学.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../数据结构与算法/Shuffle.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../数据结构与算法/数学.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../数据结构与算法/Shuffle.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
