<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>位运算 - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88">遍历集合</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E9%9B%86%E5%90%88">枚举集合</a>
<ul>
<li><a href="#%E6%9E%9A%E4%B8%BE%E9%9D%9E%E7%A9%BA%E5%AD%90%E9%9B%86">枚举非空子集</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E8%B6%85%E9%9B%86">枚举超集</a></li>
</ul>
</li>
<li><a href="#2595-%E5%A5%87%E5%81%B6%E4%BD%8D%E6%95%B0">2595 奇偶位数</a></li>
<li><a href="#476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0">476 数字的补数</a></li>
<li><a href="#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E7%BB%9F%E8%AE%A1">338 比特位统计</a></li>
<li><a href="#3226-%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9B%B8%E7%AD%89%E7%9A%84%E4%BD%8D%E6%9B%B4%E6%94%B9%E6%AC%A1%E6%95%B0">3226
使两个整数相等的位更改次数</a></li>
<li><a href="#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">461 汉明距离</a></li>
<li><a href="#868-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D">868 二进制间距</a></li>
<li><a href="#3211-%E7%94%9F%E6%88%90%E4%B8%8D%E5%90%AB%E7%9B%B8%E9%82%BB%E9%9B%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2">3211
生成不含相邻零的二进制字符串</a></li>
<li><a href="#2917-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84k-or%E5%80%BC">2917
找出数组中的K-or值</a></li>
<li><a href="#693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0">693 交替位二进制数</a></li>
<li><a href="#1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C">1486 数组异或操作</a></li>
<li><a href="#2433-%E6%89%BE%E5%87%BA%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84">2433
找出前缀异或的原始数组</a></li>
<li><a href="#1310-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2">1310
子数组异或查询</a></li>
<li><a href="#2683-%E7%9B%B8%E9%82%BB%E5%80%BC%E7%9A%84%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96">2683
相邻值的按位异或</a></li>
<li><a href="#2429-%E6%9C%80%E5%B0%8F%E5%BC%82%E6%88%96">2429 最小异或</a></li>
<li><a href="#2997-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E5%92%8C%E7%AD%89%E4%BA%8Ek%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0">2997
使数组异或和等于K的最少操作次数</a></li>
<li><a href="#2980-%E6%A3%80%E6%9F%A5%E6%8C%89%E4%BD%8D%E6%88%96%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%B0%BE%E9%9A%8F0">2980
检查按位或是否存在尾随0</a></li>
<li><a href="#1318-%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0">1318
或运算的最小翻转次数</a></li>
<li><a href="#2419-%E6%8C%89%E4%BD%8D%E4%BA%8E%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84">2419
按位于最大的最长子数组</a></li>
<li><a href="#2401-%E6%9C%80%E9%95%BF%E4%BC%98%E9%9B%85%E5%AD%90%E6%95%B0%E7%BB%84">2401
最长优雅子数组</a></li>
<li><a href="#3171-%E6%89%BE%E5%88%B0%E6%8C%89%E4%BD%8D%E6%88%96%E6%9C%80%E6%8E%A5%E8%BF%91k%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">3171
找到按位或最接近K的子数组</a></li>
<li><a href="#1521-%E6%89%BE%E5%88%B0%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E5%80%BC">1521
找到最接近目标值的函数值</a></li>
<li><a href="#3158-%E6%B1%82%E5%87%BA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E6%95%B0%E5%AD%97%E7%9A%84xor%E5%80%BC">3158
求出出现两次数字的XOR值</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E4%BD%8D%E8%BF%90%E7%AE%97%E6%95%B0%E7%BB%841">构造最小位运算数组1</a></li>
<li><a href="#3191-%E4%BD%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%BB%84%E5%85%A8%E9%83%A8%E7%AD%89%E4%BA%8E1%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B01">3191
使二进制数组全部等于1的最少操作次数1</a></li>
<li><a href="#3192-%E4%BD%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%BB%84%E5%85%A8%E9%83%A8%E7%AD%89%E4%BA%8E1%E7%9A%84%E6%9C%80%E5%B0%91%E6%AC%A1%E6%95%B0-2">3192 使二进制数组全部等于1的最少次数
2</a></li>
<li><a href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84">49 字母异位词分组</a></li>
<li><a href="#128-%E8%BF%9E%E7%BB%AD%E6%9C%80%E9%95%BF%E5%BA%8F%E5%88%97">128 连续最长序列</a></li>
</ul>
<p>在集合论中，有交集 ∩∩、并集 ∪∪、包含于 ⊆⊆
等等概念。如果编程实现「求两个哈希表的交集」，需要一个一个地遍历哈希表中的元素。那么，有没有效率更高的做法呢？</p>
<p>该二进制登场了。</p>
<p>集合可以用二进制表示，二进制从低到高第 ii 位为 11 表示 ii 在集合中，为
00 表示 ii 不在集合中。例如集合 {0,2,3}{0,2,3} 可以用二进制数
1101(2)1101(2) 表示；反过来，二进制数 1101(2)1101(2) 就对应着集合
{0,2,3}{0,2,3}。</p>
<p>例如集合 {0,2,3}{0,2,3} 可以压缩成
20+22+23=1320+22+23=13，也就是二进制数 1101(2)。</p>
<p>利用位运算「并行计算」的特点，我们可以高效地做一些和集合有关的运算。按照常见的应用场景，可以分为以下四类：</p>
<pre><code>集合与集合
集合与元素
遍历集合
枚举集合
</code></pre>
<p><img src="../../Pictures/Screenshots/Screenshot_2024-10-05-10-31-11_3840x1080.png" alt="常见操作" /></p>
<h2 id="遍历集合"><a class="header" href="#遍历集合">遍历集合</a></h2>
<p>设元素范围从 00 到 n−1n−1，枚举范围中的元素 ii，判断 ii 是否在集合 ss
中。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">for(int i=0;i&lt;n;i++){
  if((s&gt;&gt;i)&amp;1){//i在s中

  }
}
</code></pre>
</details>
<p>也可以直接遍历集合 ss
中的元素：不断地计算集合最小元素、去掉最小元素，直到集合为空。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">for(int t=s;t;t&amp;=t-1){
  int i=__builtin_ctz(i);
}
</code></pre>
</details>
<h2 id="枚举集合"><a class="header" href="#枚举集合">枚举集合</a></h2>
<p>设元素范围从 00 到 n−1n−1，从空集 ∅∅ 枚举到全集 UU：</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">for(int s=0;s&lt; (1&lt;&lt;n);s++){

}
</code></pre>
</details>
<h3 id="枚举非空子集"><a class="header" href="#枚举非空子集">枚举非空子集</a></h3>
<p>设集合为 ss，从大到小枚举 ss 的所有非空子集 subsub：</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">for (int sub = s; sub; sub = (sub - 1) &amp; s) {
    // 处理 sub 的逻辑
}
</code></pre>
</details>
<h3 id="枚举超集"><a class="header" href="#枚举超集">枚举超集</a></h3>
<p>如果 TT 是 SS 的子集，那么称 SS 是 TT 的超集（superset）。</p>
<p>枚举超集的原理和上文枚举子集是类似的，这里通过或运算保证枚举的集合 SS
一定包含集合 TT 中的所有元素。</p>
<p>枚举 SS，满足 SS 是 TT 的超集，也是全集 U={0,1,2,⋯ ,n−1}U={0,1,2,⋯,n−1}
的子集。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">for (int s = t; s &lt; (1 &lt;&lt; n); s = (s + 1) | t) {
    // 处理 s 的逻辑
}
</code></pre>
</details>
<h1 id="2595-奇偶位数"><a class="header" href="#2595-奇偶位数">2595 奇偶位数</a></h1>
<p>给你一个 正 整数 n 。</p>
<p>用 even 表示在 n 的二进制形式（下标从 0 开始）中值为 1
的偶数下标的个数。</p>
<p>用 odd 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的奇数下标的个数。</p>
<p>返回整数数组 answer ，其中 answer = [even, odd] 。</p>
<p>常规解法</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; evenOddBit(int n) {
        vector&lt;int&gt; ans(2);
        for(int i=0;n;i^=1,n&gt;&gt;=1){
            ans[i]+=n&amp;1;
        }
        return ans;
    }
};
</code></pre>
</details>
<p>位掩码+库函数</p>
<p>利用位掩码 0x55555555（二进制的
010101⋯），取出偶数下标比特和奇数下标比特，分别用库函数统计 1 的个数。</p>
<p>本题由于 n 范围比较小，取 0x5555 作为位掩码。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; evenOddBit(int n) {
        constexpr int MASK=0x5555;
        return {__builtin_popcount(n&amp;MASK),__builtin_popcount(n&amp;(MASK&gt;&gt;1))};
    }
};
</code></pre>
</details>
<h1 id="476-数字的补数"><a class="header" href="#476-数字的补数">476 数字的补数</a></h1>
<p>对整数的二进制表示取反（0 变 1 ，1 变
0）后，再转换为十进制表示，可以得到这个整数的补数。</p>
<pre><code>例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。
</code></pre>
<p>给你一个整数 num ，输出它的补数。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int findComplement(int num) {
        return ~num&amp;((1L&lt;&lt;(32-__builtin_clz(num)))-1);
    }
};
</code></pre>
</details>
<h1 id="338-比特位统计"><a class="header" href="#338-比特位统计">338 比特位统计</a></h1>
<p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1
的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p>
<p>动态规划做法</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
 public:
  vector&lt;int&gt; countBits(int n) {
    vector&lt;int&gt; bits(n + 1);
    for (int i = 1; i &lt;= n; i++) {
      
      bits[i] = bits[i &gt;&gt;1] + (i&amp;1);
    }
    return bits;
  }
};
</code></pre>
</details>
<p>库函数做法</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; countBits(int n) {
        vector&lt;int&gt; ans;
        for(int i=0;i&lt;=n;i++){
            ans.emplace_back(__builtin_popcount(i));
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="3226-使两个整数相等的位更改次数"><a class="header" href="#3226-使两个整数相等的位更改次数">3226 使两个整数相等的位更改次数</a></h1>
<p>给你两个正整数 n 和 k。</p>
<p>你可以选择 n 的 二进制表示 中任意一个值为 1 的位，并将其改为 0。</p>
<p>返回使得 n 等于 k 所需要的更改次数。如果无法实现，返回 -1。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int minChanges(int n, int k) {
        return (n&amp;k)!=k?-1: (__builtin_popcount(n^k));
    }
};
</code></pre>
</details>
<h1 id="461-汉明距离"><a class="header" href="#461-汉明距离">461 汉明距离</a></h1>
<p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">public:
    int hammingDistance(int x, int y) {
        return __builtin_popcount(x^y);
    }
};
</code></pre>
</details>
<h1 id="868-二进制间距"><a class="header" href="#868-二进制间距">868 二进制间距</a></h1>
<p>给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离
。如果不存在两个相邻的 1，返回 0 。</p>
<p>如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻
。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001"
中的两个 1 的距离为 3 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int binaryGap(int n) {
        int last=-1;
        int ans=0;
        for(int i=0;n;i++){
            if(n&amp;1){
                if(last!=-1){
                    ans=max(ans,i-last);
                }
                last=i;
            }
            n&gt;&gt;=1;
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="3211-生成不含相邻零的二进制字符串"><a class="header" href="#3211-生成不含相邻零的二进制字符串">3211 生成不含相邻零的二进制字符串</a></h1>
<p>给你一个正整数 n。</p>
<p>如果一个二进制字符串 x 的所有长度为 2 的 子字符串 中包含 至少 一个
"1"，则称 x 是一个 有效 字符串。</p>
<p>返回所有长度为 n 的 有效 字符串，可以以任意顺序排列。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;string&gt; validStrings(int n) {
        vector&lt;string&gt; ans;
        int mask=(1&lt;&lt;n)-1;
        for(int i=0;i&lt;(1&lt;&lt;n);i++){
            int x=mask^i;
            if(((x&gt;&gt;1)&amp;x)==0){
                ans.push_back(bitset&lt;18&gt;(i).to_string().substr(18-n));
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="2917-找出数组中的k-or值"><a class="header" href="#2917-找出数组中的k-or值">2917 找出数组中的K-or值</a></h1>
<p>给你一个整数数组 nums 和一个整数 k 。让我们通过扩展标准的按位或来介绍
K-or 操作。在 K-or 操作中，如果在 nums 中，至少存在 k 个元素的第 i
位值为 1 ，那么 K-or 中的第 i 位的值是 1 。</p>
<p>返回 nums 的 K-or 值。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int findKOr(vector&lt;int&gt;&amp; nums, int k) {
        int ans=0;
        for(int i=0;i&lt;32;i++){
            int count=0;
            for(auto num: nums){
                if(num&amp;(1&lt;&lt;i)){
                    count++;
                }
            }
            if(count&gt;=k){
                ans+=1&lt;&lt;i;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="693-交替位二进制数"><a class="header" href="#693-交替位二进制数">693 交替位二进制数</a></h1>
<p>给定一个正整数，检查它的二进制表示是否总是 0、1
交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    bool hasAlternatingBits(int n) {
        bool tail=n&amp;1;
        bool last=n&amp;1;
        n&gt;&gt;=1;
        while(n){
            tail=(last^(n&amp;1));
            if(!tail){
                return false;
            }
            last=n&amp;1;
            n&gt;&gt;=1;
        }
        return tail;
    }
};

# 2657 找到两个数组的前缀公共数组

注意__builtin_popcountll是对于long long类型的

```cpp
&lt;/details&gt;
  class Solution {
public:
    vector&lt;int&gt; findThePrefixCommonArray(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {
        vector&lt;int&gt; ans;
        long long setA=0;
        long long setB=0;
        int n=A.size();
        for(int i=0;i&lt;n;i++){
            setA|=1LL&lt;&lt;A[i];
            setB|=1LL&lt;&lt;B[i];
            ans.push_back(__builtin_popcountll(setA&amp;setB));
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="1486-数组异或操作"><a class="header" href="#1486-数组异或操作">1486 数组异或操作</a></h1>
<p>给你两个整数，n 和 start 。</p>
<p>数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n ==
nums.length 。</p>
<p>请返回 nums 中所有元素按位异或（XOR）后得到的结果。</p>
<p>利用异或的性质</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first) {
        int n=encoded.size()+1;
        vector&lt;int&gt; ans(n);
        ans[0]=first;
        for(int i=1;i&lt;n;i++){
            ans[i]=ans[i-1]^encoded[i-1];
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="2433-找出前缀异或的原始数组"><a class="header" href="#2433-找出前缀异或的原始数组">2433 找出前缀异或的原始数组</a></h1>
<p>给你一个长度为 n 的 整数 数组 pref 。找出并返回满足下述条件且长度为 n
的数组 arr ：</p>
<pre><code>pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
</code></pre>
<p>注意 ^ 表示 按位异或（bitwise-xor）运算。</p>
<p>可以证明答案是 唯一 的。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    vector&lt;int&gt; findArray(vector&lt;int&gt;&amp; pref) {
        int n=pref.size();
        vector&lt;int&gt; ans(n);
        ans[0]=pref[0];
        int first=0;
        for(int i=0;i&lt;n;i++){
            int tmp=first^pref[i];
            ans[i]=tmp;
            first ^=tmp;
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="1310-子数组异或查询"><a class="header" href="#1310-子数组异或查询">1310 子数组异或查询</a></h1>
<p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中
queries[i] = [Li, Ri]。</p>
<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor
arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 queries 所有结果的数组。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    vector&lt;int&gt; xorQueries(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {
        int n=arr.size();
        vector&lt;int&gt; xors(n+1);
        for(int i=0;i&lt;n;i++){
            xors[i+1]=xors[i]^arr[i];
        }
        int m=queries.size();
        vector&lt;int&gt; ans(m);
        for(int i=0;i&lt;m;i++){
            ans[i]=xors[queries[i][0]]^xors[queries[i][1]+1];
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="2683-相邻值的按位异或"><a class="header" href="#2683-相邻值的按位异或">2683 相邻值的按位异或</a></h1>
<p>下标从 0 开始、长度为 n 的数组 derived 是由同样长度为 n 的原始
二进制数组 original 通过计算相邻值的 按位异或（⊕）派生而来。</p>
<p>特别地，对于范围 [0, n - 1] 内的每个下标 i ：</p>
<pre><code>如果 i = n - 1 ，那么 derived[i] = original[i] ⊕ original[0]
否则 derived[i] = original[i] ⊕ original[i + 1]
</code></pre>
<p>给你一个数组 derived ，请判断是否存在一个能够派生得到 derived 的
有效原始二进制数组 original 。</p>
<p>如果存在满足要求的原始二进制数组，返回 true ；否则，返回 false 。</p>
<pre><code>二进制数组是仅由 0 和 1 组成的数组。
</code></pre>
<p><img src="../../Pictures/Screenshots/Screenshot_2024-10-05-18-49-39_3840x1080.png" alt="思路" /></p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    bool doesValidArrayExist(vector&lt;int&gt;&amp; derived) {
        int tmp=0;
        for(int &amp;x: derived){
            tmp^=x;
        }   
        return tmp==0;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="2429-最小异或"><a class="header" href="#2429-最小异或">2429 最小异或</a></h1>
<p>给你两个正整数 num1 和 num2 ，找出满足下述条件的正整数 x ：</p>
<pre><code>x 的置位数和 num2 相同，且
x XOR num1 的值 最小
</code></pre>
<p>注意 XOR 是按位异或运算。</p>
<p>返回整数 x 。题目保证，对于生成的测试用例， x 是 唯一确定 的。</p>
<p>整数的 置位数 是其二进制表示中 1 的数目。</p>
<p>基本思路：</p>
<p>x 的置位数和 num2相同，意味着 x 的二进制表示中有 c2 个
1，我们需要合理地分配这 c2个 1。</p>
<p>为了让异或和尽量小，这些 1 应当从高位到低位匹配 num1 中的
1；如果匹配完了还有多余的 1，那么就从低位到高位把 0 改成 1。</p>
<p>分类讨论：</p>
<pre><code>如果 c2≥n1，x 只能是 2^c2−1，任何其他方案都会使异或和变大；
如果 c2=c1，那么 x=num1；
如果 c2&lt;c1，那么将 num1的最低的 c1−c2 个 1 变成 0，其结果就是 x；
如果 c2&gt;c1，那么将 num1 的最低的 c2−c1 个 0 变成 1，其结果就是 x；
</code></pre>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int minimizeXor(int num1, int num2) {
        int c1=__builtin_popcount(num1);
        int c2=__builtin_popcount(num2);
        for(;c2&lt;c1;++c2) num1&amp;=num1-1;
        for(;c2&gt;c1;--c2) num1|=num1+1;
        return num1;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="2997-使数组异或和等于k的最少操作次数"><a class="header" href="#2997-使数组异或和等于k的最少操作次数">2997 使数组异或和等于K的最少操作次数</a></h1>
<p>给你一个下标从 0 开始的整数数组 nums 和一个正整数 k 。</p>
<p>你可以对数组执行以下操作 任意次 ：</p>
<pre><code>选择数组里的 任意 一个元素，并将它的 二进制 表示 翻转 一个数位，翻转数位表示将 0 变成 1 或者将 1 变成 0 。
</code></pre>
<p>你的目标是让数组里 所有 元素的按位异或和得到 k ，请你返回达成这一目标的
最少 操作次数。</p>
<p>注意，你也可以将一个数的前导 0 翻转。比方说，数字 (101)2
翻转第四个数位，得到 (1101)2 。</p>
<p>思路：</p>
<p>设 x=s⊕k，我们把 nums 中的任意数字的某个比特位翻转，那么 x
的这个比特位也会翻转。要让 x=0，就必须把 x 中的每个 1 都翻转，所以 x
中的 1 的个数就是我们的操作次数。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums, int k) {
        for(auto &amp;e:nums){
            k^=e;
        }
        return __builtin_popcount(k);
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="2980-检查按位或是否存在尾随0"><a class="header" href="#2980-检查按位或是否存在尾随0">2980 检查按位或是否存在尾随0</a></h1>
<p>给你一个 正整数 数组 nums 。</p>
<p>你需要检查是否可以从数组中选出 两个或更多
元素，满足这些元素的按位或运算（ OR）结果的二进制表示中 至少
存在一个尾随零。</p>
<p>例如，数字 5 的二进制表示是 "101"，不存在尾随零，而数字 4
的二进制表示是 "100"，存在两个尾随零。</p>
<p>如果可以选择两个或更多元素，其按位或运算结果存在尾随零，返回
true；否则，返回 false 。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    bool hasTrailingZeros(vector&lt;int&gt;&amp; nums) {
        auto size=nums.size();
        for(auto&amp; num:nums){
            size-=num%2;
        }
        return size&gt;=2;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="1318-或运算的最小翻转次数"><a class="header" href="#1318-或运算的最小翻转次数">1318 或运算的最小翻转次数</a></h1>
<p>给你三个正整数 a、b 和 c。</p>
<p>你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算 a OR b
== c 成立的最小翻转次数。</p>
<p>「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0
变成 1 。</p>
<p>由于在或（OR）运算中，二进制表示的每一位都是独立的，即修改 a 或 b
二进制表示中的第 i 位，只会影响 a OR b 中第 i
位的值，因此我们可以依次枚举并考虑每一位。注意到 a、b 和 c 均小于
10^9，它们的二进制表示最多有 30 位（包含 31 个二进制位的数最小为 2^30
= 1073741824，已经大于 10^9），因此我们只需要从低位到高位枚举这 30
位即可。</p>
<p>设 a、b 和 c 二进制表示的第 i 位分别为 bit_a、bit_b 和 bit_c，根据 bit_c
的值，会有以下两种情况：</p>
<pre><code>若 bit_c 的值为 0，那么 bit_a 和 bit_b 必须都为 0，需要的翻转次数为 bit_a + bit_b；

若 bit_c 的值为 1，那么 bit_a 和 bit_b 中至少有一个为 1，只有当它们都为 0 时，才需要 1 次翻转；
</code></pre>
<p>我们将每一位的翻转次数进行累加，在枚举完所有位之后，就得到了最小翻转次数。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int minFlips(int a, int b, int c) {
        int ans=0;
        for(int i=0;i&lt;31;i++){
            int bit_a=(a&gt;&gt;i)&amp;1;
            int bit_b=(b&gt;&gt;i)&amp;1;
            int bit_c=(c&gt;&gt;i)&amp;1;
            if(bit_c==0){
                ans+=bit_a+bit_b;
            }else{
                ans+=(bit_a+bit_b==0);
            }
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="2419-按位于最大的最长子数组"><a class="header" href="#2419-按位于最大的最长子数组">2419 按位于最大的最长子数组</a></h1>
<p>给你一个长度为 n 的整数数组 nums 。</p>
<p>考虑 nums 中进行 按位与（bitwise AND）运算得到的值 最大 的 非空 子数组。</p>
<pre><code>换句话说，令 k 是 nums 任意 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 k 的子数组。
</code></pre>
<p>返回满足要求的 最长 子数组的长度。</p>
<p>数组的按位与就是对数组中的所有数字进行按位与运算。</p>
<p>子数组 是数组中的一个连续元素序列。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int longestSubarray(vector&lt;int&gt;&amp; nums) {
        int max_=ranges::max(nums);
        int ans=0,cnt=0;
        for (auto&amp; x: nums){
            if (x==max_){
                cnt+=1;
                ans=max(ans,cnt);
            }else{
                cnt=0;
            }
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="2401-最长优雅子数组"><a class="header" href="#2401-最长优雅子数组">2401 最长优雅子数组</a></h1>
<p>给你一个由 正 整数组成的数组 nums 。</p>
<p>如果 nums 的子数组中位于 不同 位置的每对元素按位 与（AND）运算的结果等于
0 ，则称该子数组为 优雅 子数组。</p>
<p>返回 最长 的优雅子数组的长度。</p>
<p>子数组 是数组中的一个 连续 部分。</p>
<p>注意：长度为 1 的子数组始终视作优雅子数组。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int longestNiceSubarray(vector&lt;int&gt;&amp; nums) {
        int ans=0;
        for(int i=0;i&lt;nums.size();i++){
            int or_num=0,j=i;
            while(j&gt;=0&amp;&amp;(or_num&amp;nums[j])==0){
                or_num|=nums[j--];
            }
            ans=max(ans,i-j);
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="3171-找到按位或最接近k的子数组"><a class="header" href="#3171-找到按位或最接近k的子数组">3171 找到按位或最接近K的子数组</a></h1>
<p>给你一个数组 nums 和一个整数 k 。你需要找到 nums 的一个 子数组
，满足子数组中所有元素按位或运算 OR 的值与 k 的 绝对差 尽可能 小
。换言之，你需要选择一个子数组 nums[l..r] 满足 |k - (nums[l] OR
nums[l + 1] ... OR nums[r])| 最小。</p>
<p>请你返回 最小 的绝对差值。</p>
<p>子数组 是数组中连续的 非空 元素序列。</p>
<p>把二进制数看成集合，两个数的 OR 就是两个集合的并集。</p>
<pre><code>把 nums[i] 对应的集合记作 Ai。
i=1 时，我们会把 A0到 A1 的并集记录在 A0 中，也就是把 A1 并入 A0。所以 A1 必然是 A0 的子集，即 A0⊇A1。
i=2 时，我们会把 A2 并入 A1 和 A0，所以有 A0⊇A1⊇A2。
i=3 时，我们会把 A3 并入 A2、A1 和 A0，所以有 A0⊇A1⊇A2⊇A3。
一般地，上述代码的内层循环结束时，有 A0⊇A1⊇A2⊇⋯⊇Ai。
</code></pre>
<p>想一想，如果 Ai 是 Aj 的子集，那么内层循环还需要继续跑吗？</p>
<p>不需要。如果 Ai 已经是 Aj 的子集，那么 Ai 必然也是更左边的
A0,A1,A2,⋯,Aj−1 的子集。既然 Ai
都已经是这些集合的子集了，那么并入操作不会改变这些集合。</p>
<p>所以当我们发现 Ai 是 Aj 的子集时，就可以退出内层循环了。</p>
<p>具体到代码，对于两个二进制数 a 和 b，如果 a ∣ b=a，那么 b 对应的集合是 a
对应的集合的子集。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int minimumDifference(vector&lt;int&gt;&amp; nums, int k) {
        int ans=INT_MAX;
        for(int i=0;i&lt;nums.size();i++){
            int x=nums[i];
            ans=min(ans,abs(x-k));
            for(int j=i-1;j&gt;=0&amp;&amp;(nums[j]|x)!=nums[j];j--){
                nums[j]|=x;
                ans=min(ans,abs(nums[j]-k));
            }
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="1521-找到最接近目标值的函数值"><a class="header" href="#1521-找到最接近目标值的函数值">1521 找到最接近目标值的函数值</a></h1>
<pre><code class="language-js">&lt;/details&gt;
func(arr,l,r){
  if(r&lt;l) return -10000000
}
ans=arr[l] 
for(i=l+1;i&lt;=r;i++) ans=ans&amp;arr[i]
return ans 
  }
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<p>Winston 构造了一个如上所示的函数 func 。他有一个整数数组 arr 和一个整数
target ，他想找到让 |func(arr, l, r) - target| 最小的 l 和 r 。</p>
<p>请你返回 |func(arr, l, r) - target| 的最小值。</p>
<p>请注意， func 的输入参数 l 和 r 需要满足 0 &lt;= l, r &lt; arr.length 。</p>
<p>思路：</p>
<p>把二进制数看成集合，两个数的 AND 就是两个集合的交集。</p>
<p>对于两个二进制数 a 和 b，如果 a&amp;b=a，从集合的角度上看，a 对应的集合是 b
对应的集合的子集。或者说，b 对应的集合是 a 对应的集合的超集。</p>
<p>据此我们可以提出如下优化（把 target 记作 k）：</p>
<p>仍然是从左到右正向遍历 arr，对于 x=arr[i]，从 i−1 开始倒着遍历
arr[j]：</p>
<p>如果 arr[j]&amp;x=arr[j]，说明 arr[j]
可以变小（求交集后，集合元素只会减少不会变多），更新
arr[j]=arr[j]&amp;x。</p>
<p>否则 arr[j]&amp;x=arr[j]，从集合的角度看，此时 x 不仅是 arr[j]
的超集，同时也是 arr[k] (k&lt;j)
的超集（因为前面的循环保证了每个集合都是其左侧相邻集合的超集）。在 A⊆B
的前提下，A∩B=A，所以后续的循环都不会改变元素值，退出内层循环。具体例子可以看
视频讲解 第四题。</p>
<p>在循环中，用 ∣arr[j]−k∣ 更新答案的最小值。</p>
<p>注意单个元素也可以组成子数组，用 ∣arr[i]−k∣ 更新答案的最小值。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int closestToTarget(vector&lt;int&gt;&amp; arr, int target) {
        int ans=INT_MAX;
        for(int i=0;i&lt;arr.size();i++){
            int x=arr[i];
            ans=min(ans,abs(x-target));
            for(int j=i-1;j&gt;=0&amp;&amp;((arr[j]&amp;x)!=arr[j]);j--){
                arr[j]&amp;=x;
                ans=min(ans,abs(arr[j]-target));
            }
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="3158-求出出现两次数字的xor值"><a class="header" href="#3158-求出出现两次数字的xor值">3158 求出出现两次数字的XOR值</a></h1>
<p>给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。</p>
<p>请你返回数组中所有出现两次数字的按位 XOR
值，如果没有数字出现过两次，返回 0 。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int duplicateNumbersXOR(vector&lt;int&gt;&amp; nums) {
        if(nums.size()==1) return 0;
        long long set=0LL;
        int x_or=0;
        for(auto&amp; num: nums){
            if((set&gt;&gt;num)&amp;1){
                if(x_or==0) x_or=num;
                else x_or^=num;
            }
            set|=(1LL&lt;&lt;num);
        }
        return x_or;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="构造最小位运算数组1"><a class="header" href="#构造最小位运算数组1">构造最小位运算数组1</a></h1>
<p>给你一个长度为 n 的 质数 数组 nums 。你的任务是返回一个长度为 n 的数组
ans ，对于每个下标 i ，以下 条件 均成立：</p>
<pre><code>ans[i] OR (ans[i] + 1) == nums[i]
</code></pre>
<p>除此以外，你需要 最小化 结果数组里每一个 ans[i] 。</p>
<p>如果没法找到符合 条件 的 ans[i] ，那么 ans[i] = -1 。</p>
<p>质数 指的是一个大于 1 的自然数，且它只有 1 和自己两个因数。</p>
<p>思路：</p>
<p>例如 x=100111，那么 x ∣ (x+1)=100111 ∣ 101000=101111。</p>
<p>可以发现，x ∣ (x+1) 的本质是把二进制最右边的 0 置为 1。</p>
<p>反过来，如果我们知道了 x ∣ (x+1) 的结果 101111，那么对应的 x
只能是这些：</p>
<pre><code>100111。
101011。
101101。
101110。
</code></pre>
<p>其中最小的是 100111，也就是把 101111 最右边的 0 的右边的 1 置为 0。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    vector&lt;int&gt; minBitwiseArray(vector&lt;int&gt;&amp; nums) {
        for(auto&amp; x:nums){
            if(x==2){
                x=-1;
            }else{
                int t=~x;
                x^=(t&amp;-t)&gt;&gt;1;
            }
        }
        return nums;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="3191-使二进制数组全部等于1的最少操作次数1"><a class="header" href="#3191-使二进制数组全部等于1的最少操作次数1">3191 使二进制数组全部等于1的最少操作次数1</a></h1>
<p>给你一个二进制数组 nums 。</p>
<p>你可以对数组执行以下操作 任意 次（也可以 0 次）：</p>
<pre><code>选择数组中 任意连续 3 个元素，并将它们 全部反转 。
</code></pre>
<p>反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。</p>
<p>请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1
，返回 -1 。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        int ans=0;
        for(int i=0;i&lt;n-2;i++){
            if(nums[i]==0){
                nums[i+1]^=1;
                nums[i+2]^=1;
                ans++;
            }
        }
        return nums[n-2]&amp;&amp;nums[n-1]? ans:-1;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="3192-使二进制数组全部等于1的最少次数-2"><a class="header" href="#3192-使二进制数组全部等于1的最少次数-2">3192 使二进制数组全部等于1的最少次数 2</a></h1>
<p>给你一个二进制数组 nums 。</p>
<p>你可以对数组执行以下操作 任意 次（也可以 0 次）：</p>
<pre><code>选择数组中 任意 一个下标 i ，并将从下标 i 开始一直到数组末尾 所有 元素 反转 。
</code></pre>
<p>反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。</p>
<p>请你返回将 nums 中所有元素变为 1 的 最少 操作次数。</p>
<p>思路：</p>
<p>由于 nums[i] 会被发生在 i 左侧的操作影响，我们先从最左边的 nums[0]
开始思考。</p>
<p>讨论是否要在 i=0 处操作：</p>
<pre><code>如果 nums[0]=1，不需要操作，问题变成剩下 n−1 个数的子问题。
如果 nums[0]=0，一定要操作，问题变成剩下 n−1 个数（在操作次数是 1 的情况下）的子问题。
</code></pre>
<p>对后续元素来说，由于反转偶数次等于没反转，所以只需考虑操作次数的奇偶性。</p>
<p>一般地，设遍历到 x=nums[i] 时，之前执行了 k 次操作，分类讨论：</p>
<pre><code>如果 x=0 且 k 是奇数，或者 x=1 且 k 是偶数，那么这 k 次操作执行完后 nums[i] 变成 1。所以如果 x=kmod2，则不需要操作。
如果 x=0 且 k 是偶数，或者 x=1 且 k 是奇数，那么这 k 次操作执行完后 nums[i] 变成 0。所以如果 x=kmod2，则一定要操作。
</code></pre>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums) {
        int ans=0;
        for(auto &amp;x:nums){
            if(x==(ans&amp;1)){
                ans++;
            }
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="49-字母异位词分组"><a class="header" href="#49-字母异位词分组">49 字母异位词分组</a></h1>
<p>给你一个字符串数组，请你将 字母异位词
组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string,vector&lt;string&gt;&gt; sorted_str;
        for(auto&amp; v: strs){
            string key=v;
            ranges::sort(key);
            sorted_str[key].emplace_back(v);
        }
        vector&lt;vector&lt;string&gt;&gt; ans;
        for(auto&amp; each: sorted_str){
            ans.emplace_back(each.second);
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>
<h1 id="128-连续最长序列"><a class="header" href="#128-连续最长序列">128 连续最长序列</a></h1>
<p>给定一个未排序的整数数组 nums
，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<pre><code class="language-cpp">&lt;/details&gt;
class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; set;
        for_each(nums.begin(),nums.end(),[&amp;](int &amp;i){
            set.insert(i);
        });
        int ans=0;
        for(const auto&amp; num: set){
            int current=1;
            if(!set.contains(num-1)){
                int current_num=num;
                while(set.count(++current_num)){
                    current++;
                }
                ans=max(ans,current);
            }
        }
        return ans;
    }
};
&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../数据结构与算法/二分.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../数据结构与算法/回溯法.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../数据结构与算法/二分.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../数据结构与算法/回溯法.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
