<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>双指针 - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E4%B8%BA0">三数之和为0</a></li>
<li><a href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">16 最接近的三数之和</a></li>
<li><a href="#3309-%E8%BF%9E%E6%8E%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%8F%AF%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC">3309 连接二进制表示可形成的最大数值</a></li>
<li><a href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C">18 四数之和</a></li>
<li><a href="#259-%E8%BE%83%E5%B0%8F%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">259 较小的三数之和</a></li>
<li><a href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">88 合并两个有序数组</a></li>
<li><a href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">31 下一个排列</a></li>
<li><a href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">5 最长回文子串</a></li>
<li><a href="#186-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D2">186 反转字符串中的单词2</a></li>
<li><a href="#415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0">415 字符串相加</a></li>
<li><a href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8">盛最多水的容器</a></li>
<li><a href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">26 删除有序数组中的重复项</a></li>
<li><a href="#165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7">165 比较版本号</a></li>
<li><a href="#3239-%E6%9C%80%E5%B0%91%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0%E4%BD%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E5%9B%9E%E6%96%87-i">3239 最少翻转次数使二进制矩阵回文I</a></li>
<li><a href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8">11 盛水最多的容器</a></li>
<li><a href="#1847-unsolved-%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4">1847 最近的房间</a></li>
</ul>
<h1 id="三数之和为0"><a class="header" href="#三数之和为0">三数之和为0</a></h1>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; ans;
        for(int first=0;first&lt;n;first++){
            if(first&gt;0&amp;&amp;nums[first]==nums[first-1]){
                continue;
            }
            int third=n-1;
            int target=-nums[first];
            for(int second=first+1;second&lt;n;second++){
                if(second&gt;first+1&amp;&amp;nums[second]==nums[second-1]){
                    continue;
                }
                while(second&lt;third&amp;&amp;nums[second]+nums[third]&gt;target){
                    --third;
                }
                if(second==third){
                    break;
                }
                if(nums[second]+nums[third]==target){
                    ans.emplace_back(vector&lt;int&gt;{nums[first],nums[second],nums[third]});
                }
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="16-最接近的三数之和"><a class="header" href="#16-最接近的三数之和">16 最接近的三数之和</a></h1>
<p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums
中选出三个整数，使它们的和与 target 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        ranges::sort(nums);
        int ans=0;
        int n=nums.size();
        int minDiff=INT_MAX;
        for(int first=0;first&lt;n;++first){
            if(first&gt;0&amp;&amp;nums[first]==nums[first-1]) continue;
            int third=n-1;
            int second=first+1;
            while(second&lt;third){
                int sum=nums[first]+nums[second]+nums[third];
                if(sum==target) return target;
                if(abs(sum-target)&lt;minDiff) {minDiff=abs(sum-target);ans=sum;}
                if(sum&gt;target){
                    int k=third-1;
                    while(second&lt;k&amp;&amp;nums[k]==nums[third]) --k;
                    third=k;
                }else {
                    int k=second+1;
                    while(k&lt;third&amp;&amp;nums[k]==nums[second]) ++k;
                    second=k;
                }
                if(second==third) break;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="3309-连接二进制表示可形成的最大数值"><a class="header" href="#3309-连接二进制表示可形成的最大数值">3309 连接二进制表示可形成的最大数值</a></h1>
<p>给你一个长度为 3 的整数数组 nums。</p>
<p>现以某种顺序 连接 数组 nums 中所有元素的 二进制表示
，请你返回可以由这种方法形成的 最大 数值。</p>
<p>注意 任何数字的二进制表示 不含 前导零。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int maxGoodNumber(vector&lt;int&gt;&amp; nums) {
        ranges::sort(nums,[](int a,int b){
            int a_log=log2(a)+1;
            int b_log=log2(b)+1;
            return a*(pow(2,b_log)-1)&gt;b*(pow(2,a_log)-1);
        });
        int ans=0;
        for(auto&amp; each: nums){
            ans=ans&lt;&lt;(__lg(each)+1)|each;
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="18-四数之和"><a class="header" href="#18-四数之和">18 四数之和</a></h1>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target
。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b],
nums[c], nums[d]]
（若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<pre><code>0 &lt;= a, b, c, d &lt; n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
</code></pre>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        ranges::sort(nums);
        vector&lt;vector&lt;int&gt;&gt; ans;
        int n = nums.size();
        for (int a = 0; a &lt; n - 3; a++) {
            long long x = nums[a];
            if (a &gt; 0 &amp;&amp; x == nums[a - 1])
                continue;
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] &gt; target)
                break;
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target)
                continue;
            for (int b = a + 1; b &lt; n - 2; b++) {
                long long y = nums[b];
                if (b &gt; a + 1 &amp;&amp; y == nums[b - 1])
                    continue;
                if (x + y + nums[b + 1] + nums[b + 2] &gt; target) break;
                if (x + y + nums[n - 2] + nums[n - 1] &lt; target) continue;
                int c=b+1,d=n-1;
                while(c&lt;d){
                    long long s=x+y+nums[c]+nums[d];
                    if(s&gt;target) d--;
                    else if(s&lt;target) cpp;
                    else{
                        ans.emplace_back(vector&lt;int&gt;{(int)x,(int)y,nums[c],nums[d]});
                        for(cpp;c&lt;d&amp;&amp;nums[c]==nums[c-1];c++);
                        for(d--;c&lt;d&amp;&amp;nums[d]==nums[d+1];d--);
                    }
                }
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="259-较小的三数之和"><a class="header" href="#259-较小的三数之和">259 较小的三数之和</a></h1>
<p>给定一个长度为 n 的整数数组和一个目标值 target ，寻找能够使条件
nums[i] + nums[j] + nums[k] &lt; target 成立的三元组 i, j, k 个数（0
&lt;= i &lt; j &lt; k &lt; n）。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int threeSumSmaller(vector&lt;int&gt;&amp; nums, int target) {
        int n=nums.size();
        ranges::sort(nums);
        int ans=0;
        for(int first=0;first&lt;n-2;first++){
           int second=first+1;
           int third=n-1;
           while(second&lt;third){
            if(nums[first]+nums[second]+nums[third]&gt;=target) third--;
            else {
                ans+=third-second;
                second++;
            }
           }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="88-合并两个有序数组"><a class="header" href="#88-合并两个有序数组">88 合并两个有序数组</a></h1>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n
，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1
中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m
个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>思路：这道题需要从后向前排序</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
            int p1=m-1,p2=n-1,p=m+n-1;
            while(p2&gt;=0){
                if(p1&gt;=0&amp;&amp;nums1[p1]&gt;nums2[p2]){
                    nums1[p--]=nums1[p1--];
                }else{
                    nums1[p--]=nums2[p2--];
                }
            }
    }
};
</code></pre>
</details>
<h1 id="31-下一个排列"><a class="header" href="#31-下一个排列">31 下一个排列</a></h1>
<p>整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr = [1,2,3] ，以下这些都可以视作 arr
的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p>
<p>整数数组的 下一个排列
是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的
下一个排列
就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</p>
<p>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</p>
<p>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1]
不存在一个字典序更大的排列。</p>
<p>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p>思路：</p>
<p>我们希望下一个数 比当前数大，这样才满足 "下一个排列" 的定义。因此只需要
将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如
123456，将 5 和 6 交换就能得到一个更大的数 123465。 我们还希望下一个数
增加的幅度尽可能的小，这样才满足"下一个排列与当前排列紧邻"的要求。为了满足这个要求，我们需要：</p>
<p>在 尽可能靠右的低位 进行交换，需要 从后向前 查找</p>
<p>将一个 尽可能小的「大数」 与前面的「小数」交换。比如
123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</p>
<p>将「大数」换到前面后，需要将「大数」后面的所有数
重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换
5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然
123546 比 123564 更小，123546 就是 123465 的下一个排列</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        if (nums.size() &lt;= 1)
            return;
        int i = nums.size() - 2, j = nums.size() - 1;
        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) {
            i--, j--;
        }
        if (i &gt;= 0) {
            int k = nums.size() - 1;
            while (nums[i] &gt;= nums[k]) {
                k--;
            }
            swap(nums[i], nums[k]);
        }
        reverse(nums.begin() + j, nums.end());
    }
};
</code></pre>
</details>
<h1 id="5-最长回文子串"><a class="header" href="#5-最长回文子串">5 最长回文子串</a></h1>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    string longestPalindrome(string s) {
        int len=1;
        int max_len=0;
        int left_max=0,right_max=0;
        int right_ans=0;
        int left_ans=0;
        for(int mid=0;mid&lt;s.length();mid++){
            left_max=mid-1;
            right_max=mid+1;
            while(left_max&gt;=0&amp;&amp;s[left_max]==s[mid]){
                len++;
                left_max--;
            }
            while(right_max&lt;s.length()&amp;&amp;s[mid]==s[right_max]){
                len++;
                right_max++;
            }
            while(left_max&gt;=0&amp;&amp;right_max&lt;s.length()&amp;&amp;s[left_max]==s[right_max]){
                len+=2;
                left_max--;
                right_max++;
            }
            if(len&gt;max_len){
                max_len=len;
                left_ans=left_max;
                right_ans=right_max;
            }
            len=1;
        }
        return s.substr(left_ans+1, max_len);
    }
};
</code></pre>
</details>
<h1 id="186-反转字符串中的单词2"><a class="header" href="#186-反转字符串中的单词2">186 反转字符串中的单词2</a></h1>
<p>给你一个字符数组 s ，反转其中 单词 的顺序。</p>
<p>单词 的定义为：单词是一个由非空格字符组成的序列。s
中的单词将会由单个空格分隔。</p>
<p>必须设计并实现 原地 解法来解决此问题，即不分配额外的空间。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    void reverseWords(vector&lt;char&gt;&amp; s) {
        if(s.size()==2) return;
        ranges::reverse(s);
        int n=s.size();
        int prev_blancket=0;
        for(int i=0;i&lt;=n;i++){
            if(i==n||s[i]==' '){
                reverse(s.begin()+prev_blancket,s.begin()+i);
                prev_blancket=i+1;
            }
        }
    }
};
</code></pre>
</details>
<h1 id="415-字符串相加"><a class="header" href="#415-字符串相加">415 字符串相加</a></h1>
<p>给定两个字符串形式的非负整数 num1 和num2
，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger），
也不能直接将输入的字符串转换为整数形式。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    string addStrings(string num1, string num2) {
        int i=num1.length()-1;
        int j=num2.length()-1;
        int carry=0;
        string ans;
        while(i&gt;=0||j&gt;=0||carry){
            int x=i&gt;=0?num1[i--]-'0':0;
            int y=j&gt;=0?num2[j--]-'0':0;
            int result=x+y+carry;
            ans.push_back(result%10+'0');
            carry=result/10;
        }
        ranges::reverse(ans);
        return ans;
    }
};
</code></pre>
</details>
<h1 id="盛最多水的容器"><a class="header" href="#盛最多水的容器">盛最多水的容器</a></h1>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是
(i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
       int left=0,right=height.size()-1;
       int ans=0;
       while(left&lt;right){
        ans=max(ans,(right-left)*(min(height[left],height[right])));
        if(height[left]&gt;height[right]){
            right--;
        }else{
            left++;
        }
       } 
       return ans;
    }
};
</code></pre>
</details>
<h1 id="26-删除有序数组中的重复项"><a class="header" href="#26-删除有序数组中的重复项">26 删除有序数组中的重复项</a></h1>
<p>给你一个 非严格递增排列 的数组 nums ，请你 原地
删除重复出现的元素，使每个元素 只出现一次
，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums
中唯一元素的个数。</p>
<p>考虑 nums 的唯一元素的数量为 k
，你需要做以下事情确保你的题解可以被通过：</p>
<p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums
中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int fast=1;
        int slow=1;
        int n=nums.size();
        if(n&lt;1){
            return n;
        }
        while(fast&lt;n){
            if(nums[fast]!=nums[fast-1]){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
</code></pre>
</details>
<h1 id="165-比较版本号"><a class="header" href="#165-比较版本号">165 比较版本号</a></h1>
<p>给你两个 版本号字符串 version1 和 version2 ，请你比较它们。版本号由被点
'.' 分开的修订号组成。修订号的值 是它 转换为整数 并忽略前导零。</p>
<p>比较版本号时，请按 从左到右的顺序
依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为
0。</p>
<p>返回规则如下：</p>
<p>如果 version1 &lt; version2 返回 -1， 如果 version1 &gt; version2 返回 1，
除此之外返回 0。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int compareVersion(string version1, string version2) {
        int n=version1.length();
        int m=version2.length();
        int i=0,j=0;
        while(i&lt;n||j&lt;m){
            long long x=0;
            for(;i&lt;n&amp;&amp;version1[i]!='.';++i){
                x=x*10+version1[i]-'0';
            }
            ++i;
            long long y=0;
            for(;j&lt;m&amp;&amp;version2[j]!='.';++j){
                y=y*10+version2[j]-'0';
            }
            ++j;
            if(x!=y){
                return x&gt;y?1:-1;
            }
        }
        return 0;
    }
};
</code></pre>
</details>
# 125 验证回文串
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个
回文串 。 字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    bool isPalindrome(string s) {
        for(int i=0;i&lt;s.length();){
            if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z'){
                s[i]+=32;
            }
            if((s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')||(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')){
                i++;
                continue;
            }else{
                s.erase(i, 1);
            }
        }
        int left=0,right=s.length()-1;
        while(left&lt;right){
            if(s[left++]!=s[right--]){
                return false;
            }
        }
        return true;
    }
};
</code></pre>
</details>
<h1 id="3239-最少翻转次数使二进制矩阵回文-i"><a class="header" href="#3239-最少翻转次数使二进制矩阵回文-i">3239 最少翻转次数使二进制矩阵回文 I</a></h1>
<p>给你一个 m x n 的二进制矩阵 grid 。</p>
<p>如果矩阵中一行或者一列从前往后与从后往前读是一样的，那么我们称这一行或者这一列是
回文 的。</p>
<p>你可以将 grid 中任意格子的值 翻转 ，也就是将格子里的值从 0 变成 1
，或者从 1 变成 0 。</p>
<p>请你返回 最少 翻转次数，使得矩阵 要么 所有行是 回文的 ，要么所有列是
回文的 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int minFlips(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m=grid.size();
        int n=grid[0].size();
        int diff_row=0;
        for(auto&amp; row:grid){
            for(int j=0;j&lt;n/2;j++){
                diff_row+=row[j]!=row[n-1-j];
            }
        }
        int diff_col=0;
        for(int j=0;j&lt;n;j++){
            for(int i=0;i&lt;m/2;i++){
                diff_col+=grid[i][j]!=grid[m-1-i][j];
            }
        }
        return min(diff_col,diff_row);
    }
};
</code></pre>
</details>
# 3240 最少翻转次数使二进制矩阵回文 2 
<p>给你一个 m x n 的二进制矩阵 grid 。</p>
<p>如果矩阵中一行或者一列从前往后与从后往前读是一样的，那么我们称这一行或者这一列是
回文 的。</p>
<p>你可以将 grid 中任意格子的值 翻转 ，也就是将格子里的值从 0 变成 1
，或者从 1 变成 0 。</p>
<p>请你返回 最少 翻转次数，使得矩阵中 所有 行和列都是 回文的 ，且矩阵中 1
的数目可以被 4 整除 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int minFlips(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m=grid.size();
        int n=grid[0].size();
        int ans=0;
        for(int i=0;i&lt;m/2;i++){
            for(int j=0;j&lt;n/2;j++){
                int cnt1=grid[i][j]+grid[i][n-1-j]+grid[m-1-i][j]+grid[m-1-i][n-1-j];
                ans+=min(cnt1,4-cnt1);
            }
        }
        if(m%2&amp;&amp;n%2){
            ans+=grid[m/2][n/2];
        }
        int diff=0,cnt1=0;
        if(m%2){
            for(int j=0;j&lt;n/2;j++){
                if(grid[m/2][j]!=grid[m/2][n-1-j]) diff++;
                else cnt1+=grid[m/2][j]*2;
            }
        }
        if(n%2){
            for(int i=0;i&lt;m/2;i++){
                if(grid[i][n/2]!=grid[m-1-i][n/2]){
                    diff++;
                }else{
                    cnt1+=grid[i][n/2]*2;
                }
            }
        }
        return ans+(diff?diff:cnt1%4);
    }
};
</code></pre>
</details>
<h1 id="11-盛水最多的容器"><a class="header" href="#11-盛水最多的容器">11 盛水最多的容器</a></h1>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是
(i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<details>
<pre><code class="language-cpp">class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
       int left=0,right=height.size()-1;
       int ans=0;
       while(left&lt;right){
        ans=max(ans,(right-left)*(min(height[left],height[right])));
        if(height[left]&gt;height[right]){
            right--;
        }else{
            left++;
        }
       } 
       return ans;
    }
};
</code></pre>
</details>
<h1 id="1847-unsolved-最近的房间"><a class="header" href="#1847-unsolved-最近的房间">1847 UNSOLVED 最近的房间</a></h1>
<p>一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] = [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。</p>
<p>同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] = [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：</p>
<pre><code>房间的面积 至少 为 minSizej ，且
abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。
</code></pre>
<p>如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。</p>
<p>请你返回长度为 k 的数组 answer ，其中 answer[j] 为第 j 个查询的结果。</p>
<details>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; closestRoom(vector&lt;vector&lt;int&gt;&gt;&amp; rooms,
                            vector&lt;vector&lt;int&gt;&gt;&amp; queries) {
        // 按照 size 从大到小排序
        ranges::sort(rooms, {}, [](auto&amp; a) { return -a[1]; });
        int q = queries.size();
        vector&lt;int&gt; query_ids(q);
        iota(query_ids.begin(), query_ids.end(), 0);
        // 按照 minSize 从大到小排序
        ranges::sort(query_ids, {}, [&amp;](int i) { return -queries[i][1]; });
        vector&lt;int&gt; ans(q, -1);
        set&lt;int&gt; room_ids;
        int j = 0;
        for (int i : query_ids) {
            int preferred_id = queries[i][0], min_size = queries[i][1];
            while (j &lt; rooms.size() &amp;&amp; rooms[j][1] &gt;= min_size) {
                room_ids.insert(rooms[j][0]);
                j++;
            }
            int diff = INT_MAX;
            auto it = room_ids.lower_bound(preferred_id);
            if (it != room_ids.begin()) {
                auto p = prev(it);
                diff = preferred_id - *p; // 左边的差
                ans[i] = *p;
            }
            if (it != room_ids.end() &amp;&amp;
                *it - preferred_id &lt; diff) { // 右边的差更小
                ans[i] = *it;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../数据结构与算法/SkipList.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../数据结构与算法/滑动窗口.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../数据结构与算法/SkipList.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../数据结构与算法/滑动窗口.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
