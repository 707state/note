<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>一些有技巧的题目 - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E6%96%87%E6%95%B0">295 数据流的中文数</a></li>
<li><a href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4">42 接雨水</a></li>
<li><a href="#3162-%E4%BC%98%E8%B4%A8%E6%95%B0%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B01">3162优质数对的总数1</a></li>
<li><a href="#lcr-170-%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0">LCR 170交易逆序对的总数</a>
<ul>
<li><a href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">前置知识</a></li>
</ul>
</li>
<li><a href="#3200-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6">3200三角形的最大高度</a></li>
<li><a href="#71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84">71 简化路径</a></li>
<li><a href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5">54 螺旋矩阵</a></li>
<li><a href="#164-%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D">164 最大间距</a></li>
<li><a href="#910-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC1">910 最小差值1</a></li>
<li><a href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">31 下一个排列</a></li>
<li><a href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0">287 寻找重复数</a></li>
<li><a href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0">41缺失的第一个正数</a></li>
<li><a href="#3233-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E6%98%AF%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E9%87%8F">3233统计不是特殊数字的数字数量</a></li>
<li><a href="#1739-%E6%94%BE%E7%BD%AE%E7%9B%92%E5%AD%90">1739 放置盒子</a></li>
<li><a href="#407-%E6%8E%A5%E9%9B%A8%E6%B0%B4-2">407 接雨水 2</a></li>
<li><a href="#408-%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E7%BC%A9%E5%86%99">408 有效单词缩写</a></li>
<li><a href="#3208-%E4%BA%A4%E6%9B%BF%E6%95%B0%E7%BB%84">3208 交替数组</a></li>
<li><a href="#unsolved-3209-%E5%AD%90%E6%95%B0%E7%BB%84%E6%8C%89%E4%BD%8D%E4%B8%8E%E5%80%BC%E4%B8%BA-k-%E7%9A%84%E6%95%B0%E7%9B%AE">UNSOLVED 3209 子数组按位与值为 K的数目</a></li>
<li><a href="#782-%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98">782 变为棋盘</a></li>
</ul>
<h1 id="295-数据流的中文数"><a class="header" href="#295-数据流的中文数">295 数据流的中文数</a></h1>
<p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<pre><code>例如 arr = [2,3,4] 的中位数是 3 。
例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。
</code></pre>
<p>实现 MedianFinder 类:</p>
<pre><code>MedianFinder() 初始化 MedianFinder 对象。

void addNum(int num) 将数据流中的整数 num 添加到数据结构中。

double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。
</code></pre>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class MedianFinder {
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;&gt;&gt;  queMax;
    priority_queue&lt;int,vector&lt;int&gt;,less&lt;&gt;&gt; queMin;
public:
    MedianFinder() {

    }
    
    void addNum(int num) {
        if(queMin.empty()||num&lt;=queMin.top()){
            queMin.push(num);
            if(queMax.size()+1&lt;queMin.size()){
                queMax.push(queMin.top());
                queMin.pop();
            }
        }else{
            queMax.push(num);
            if(queMin.size()&lt;queMax.size()){
                queMin.push(queMax.top());
                queMax.pop();
            }
        }
    }
    
    double findMedian() {
        if(queMin.size()&gt;queMax.size()){
            return queMin.top();
        }
        return (queMin.top()+queMax.top())/2.0;
    }
};
</code></pre>
</details>
<h1 id="42-接雨水"><a class="header" href="#42-接雨水">42 接雨水</a></h1>
<p>给定 n 个非负整数表示每个宽度为 1
的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        vector&lt;int&gt; left_max(height.size(),0);
        vector&lt;int&gt; right_max(height.size(),0);
        for(int i=1;i&lt;height.size();i++){
            left_max[i]=std::max(height[i-1],left_max[i-1]);
        }
        for(int i=height.size()-1;i&gt;0;i--){
            right_max[i-1]=std::max(right_max[i],height[i]);
        }
        int sum=0;
        for(int i=1;i&lt;height.size();i++){
            int min_=(std::min(left_max[i],right_max[i]));
            if(min_&gt;height[i]) sum+=(min_-height[i]);
        }
        return sum;
    }
};
</code></pre>
</details>
<h1 id="3162-优质数对的总数1"><a class="header" href="#3162-优质数对的总数1">3162 优质数对的总数1</a></h1>
<p>给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数
k。</p>
<p>如果 nums1[i] 可以被 nums2[j] * k 整除，则称数对 (i, j) 为
优质数对（0 &lt;= i &lt;= n - 1, 0 &lt;= j &lt;= m - 1）。</p>
<p>返回 优质数对 的总数。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    long long numberOfPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) {
        unordered_map&lt;int, int&gt; cnt;
        for (int x : nums1) {
            if (x % k) {
                continue;
            }
            x /= k;
            for (int d = 1; d * d &lt;= x; d++) { // 枚举因子
                if (x % d) {
                    continue;
                }
                cnt[d]++; // 统计因子
                if (d * d &lt; x) {
                    cnt[x / d]++; // 因子总是成对出现
                }
            }
        }

        long long ans = 0;
        for (int x : nums2) {
            ans += cnt.contains(x) ? cnt[x] : 0;
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="lcr-170-交易逆序对的总数"><a class="header" href="#lcr-170-交易逆序对的总数">LCR 170 交易逆序对的总数</a></h1>
<p>在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录
record，返回其中存在的「交易逆序对」总数。</p>
<p>思路：</p>
<ol>
<li>归并排序</li>
</ol>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int mergeSort(vector&lt;int&gt;&amp; record,vector&lt;int&gt;&amp; tmp,int l,int r){
        if(l&gt;=r) return 0;
        int mid=(l+r)/2;
        int inv_count=mergeSort(record,tmp,l,mid)+mergeSort(record,tmp,mid+1,r);
        int i=l,j=mid+1,pos=l;
        while(i&lt;=mid&amp;&amp;j&lt;=r){
            if(record[i]&lt;=record[j]){
                tmp[pos]=record[i++];
                inv_count+=(j-(mid+1));
            }else{
                tmp[pos]=record[j++];
            }
            ++pos;
        }
        for(int k=i;k&lt;=mid;k++){
            tmp[pos++]=record[k];
            inv_count+=(j-(mid+1));
        }
        for(int k=j;k&lt;=r;k++){
            tmp[pos++]=record[k];
        }
        copy(tmp.begin()+l,tmp.begin()+r+1,record.begin()+l);
        return inv_count;
    }
    int reversePairs(vector&lt;int&gt;&amp; record) {
        int n=record.size();
        vector&lt;int&gt; tmp(n);
        return mergeSort(record,tmp,0,n-1);
    }
};
</code></pre>
</details>
<ol start="2">
<li>树状数组</li>
</ol>
<h2 id="前置知识"><a class="header" href="#前置知识">前置知识</a></h2>
<p>「树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：</p>
<pre><code>单点更新 update(i, v)： 把序列 i 位置的数加上一个值 v，这题 v=1
区间查询 query(i)： 查询序列 [1⋯i] 区间的区间和，即 i 位置的前缀和
</code></pre>
<p>修改和查询的时间代价都是 O(logn)，其中 n 为需要维护前缀和的序列的长度。</p>
<p>记题目给定的序列为 a，我们规定 ai 的取值集合为 a
的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设a={5,5,2,3,6}，那么遍历这个序列得到的桶是这样的：</p>
<p>index -&gt; 1 2 3 4 5 6 7 8 9 value -&gt; 0 1 1 0 2 1 0 0 0</p>
<p>我们可以看出它第 i−1 位的前缀和表示「有多少个数比 i
小」。那么我们可以从后往前遍历序列 a，记当前遍历到的元素为 ai，我们把 ai
对应的桶的值自增 1，把 i−1
位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的
i−1 位置的前缀和就是「已入桶」的元素中比
ai大的元素的总和，而这些元素在原序列中排在 ai 的后面，但它们本应该排在
ai 的前面，这样就形成了逆序对。</p>
<p>我们显然可以用数组来实现这个桶，可问题是如果 ai 中有很大的元素，比如
109，我们就要开一个大小为 109
的桶，内存中是存不下的。这个桶数组中很多位置是
0，有效位置是稀疏的，我们要想一个办法让有效的位置全聚集到一起，减少无效位置的出现，这个时候我们就需要用到一个方法------离散化。</p>
<p>离散化一个序列的前提是我们只关心这个序列里面元素的相对大小，而不关心绝对大小（即只关心元素在序列中的排名）；离散化的目的是让原来分布零散的值聚集到一起，减少空间浪费。那么如何获得元素排名呢，我们可以对原序列排序后去重，对于每一个
ai
通过二分查找的方式计算排名作为离散化之后的值。当然这里也可以不去重，不影响排名。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class BIT{
    vector&lt;int&gt; tree;
    int n;
    public :
    BIT( int _n): n(_n),tree(_n+1){

    }
    static int lowbit(int x){
        return x&amp;(-x);
    }
    int query(int x){
        int ret=0;
        while(x){
            ret+=tree[x];
            x-=lowbit(x);
        }
        return ret;
    }
    void update(int x){
        while(x&lt;=n){
            ++tree[x];
            x+=lowbit(x);
        }
    }
};
class Solution {
public:
    int reversePairs(vector&lt;int&gt;&amp; record) {
        int n=record.size();
        vector&lt;int&gt; tmp=record;
        //离散化
        sort(tmp.begin(),tmp.end());
        for(auto&amp; num: record){
            num=lower_bound(tmp.begin(),tmp.end(),num)-tmp.begin()+1;
        }
        //树状数组统计逆序对
        BIT bit(n);
        int ans=0;
        for(int i=n-1;i&gt;=0;--i){
            ans+=bit.query(record[i]-1);
            bit.update(record[i]);
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="3200-三角形的最大高度"><a class="header" href="#3200-三角形的最大高度">3200 三角形的最大高度</a></h1>
<p>给你两个整数 red 和
blue，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第
1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。</p>
<p>每一行的球必须是 相同 颜色，且相邻行的颜色必须 不同。</p>
<p>返回可以实现的三角形的 最大 高度。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int maxHeight(int a,int b){
        for(int i=1;;i++){
            if(i%2==1) {
                a-=i;
                if(a&lt;0){
                    return i-1;
                }
            }
            else{
                b-=i;
                if(b&lt;0) return i-1;
            }
        }
    }
    int maxHeightOfTriangle(int red, int blue) {
        return max(maxHeight(red,blue),maxHeight(blue,red));
    }
};
</code></pre>
</details>
<h1 id="71-简化路径"><a class="header" href="#71-简化路径">71 简化路径</a></h1>
<p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以
'/' 开头），请你将其转化为 更加简洁的规范路径。</p>
<p>在 Unix 风格的文件系统中规则如下：</p>
<pre><code>一个点 '.' 表示当前目录本身。
此外，两个点 '..' 表示将目录切换到上一级（指向父目录）。
任意多个连续的斜杠（即，'//' 或 '///'）都被视为单个斜杠 '/'。
任何其他格式的点（例如，'...' 或 '....'）均被视为有效的文件/目录名称。
</code></pre>
<p>返回的 简化路径 必须遵循下述格式：</p>
<pre><code>始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
</code></pre>
<p>返回简化后得到的 规范路径 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; str_st;
        auto split=[](const string&amp; s,char delim)-&gt;vector&lt;string&gt;{
            vector&lt;string&gt; res;
            string cur;
            for(auto ch: s){
                if(ch==delim){
                    res.emplace_back(move(cur));
                }else{
                    cur+=ch;
                }
            }
            res.emplace_back(move(cur));
            return res;
        };
        vector&lt;string&gt; names=split(path,'/');
        for(auto&amp; name: names){
            if(name==".."){
                if(str_st.size()) str_st.pop_back();
            }
            else if(!name.empty()&amp;&amp;name!="."){
                str_st.push_back(name);
            }
        }
        string ans;
        if(str_st.empty()){
            ans="/";
        }else{
            for(auto&amp; name: str_st){
                ans+="/"+move(name);
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="54-螺旋矩阵"><a class="header" href="#54-螺旋矩阵">54 螺旋矩阵</a></h1>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序
，返回矩阵中的所有元素。</p>
<p>注意，dx, dy有顺序要求。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
    constexpr static array&lt;int,4&gt; dy={1,0,-1,0};
    constexpr static array&lt;int,4&gt; dx={0,1,0,-1};
    vector&lt;int&gt; ans;
    int n,m,pos=0;
    void dfs(int x,int y,vector&lt;vector&lt;int&gt;&gt;&amp; matrix){
        if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||matrix[x][y]==INT_MAX) return;
        ans.emplace_back(matrix[x][y]);
        matrix[x][y]=INT_MAX;
        int nx=x+dx[pos],ny=y+dy[pos];
        if(nx&lt;0||ny&lt;0||nx&gt;=m||ny&gt;=n||matrix[nx][ny]==INT_MAX){
            pos=(pos+1)%4;
            nx=x+dx[pos];
            ny=y+dy[pos];
        }
        dfs(nx,ny,matrix);
    }
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        m=matrix.size();
        n=matrix[0].size();
        dfs(0,0,matrix);
        return ans;
    }
};
</code></pre>
</details>
<h1 id="164-最大间距"><a class="header" href="#164-最大间距">164 最大间距</a></h1>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值
。如果数组元素个数小于 2，则返回 0 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p>
<p>思路：</p>
<p>看示例 1，想象有一根木棍，其左端点位置为 1，右端点位置为 9，长度为
9−1=8。我们在位置 3 和 6 处各切一刀，分成 3
个小木棍。问：最长小木棍的长度是多少？ 下界</p>
<p>最长小木棍的长度，至少是多少？</p>
<p>设 n 为 nums 的长度，m 为 nums 的最小值，M 为 nums 的最大值。</p>
<p>m=M 时，直接返回 0；m+1=M 时，直接返回 1。下面讨论 m+1&lt;M
的情况，注意这意味着 n≥2。</p>
<p>木棍的长度为 M−m，我们要切 n−2 刀，分成 n−1
个小木棍，那么小木棍的平均长度为(M-m)/(n-1)。</p>
<p>由于最大值不低于平均值（见下面答疑），所以最长小木棍的长度至少为
n−1M−m。由于小木棍的长度是整数，所以最长小木棍的长度至少为
d=(M-m+n-1)/(n-1)的下取整。</p>
<p>怎么利用「答案至少为 d」这一性质呢？</p>
<p>如果把两两之差小于 d
的数，分到同一组（桶）中，那么答案一定不会是同一个桶内的两数之差，而是不同的桶的两数之差！</p>
<p>示例 1 的 nums=[3,6,9,1]，分到三个桶中：第一个桶装入 1 和
3，第二个桶装入 6，第三个桶装入
9。答案一定不会是第一个桶的两数之差，因为
3−1=2&lt;d=3。所以我们只需要考虑不同的桶之间的两数之差。由于题目要计算的是排序后相邻元素之间的差值，所以应当取第一个桶的最大值，和第二个桶的最小值作差；取第二个桶的最大值，和第三个桶的最小值作差；依此类推。这些差值中的最大值即为答案。对于示例
1 来说，答案为 max(6−3,9−6)=3。</p>
<p>一般地，从 m 开始，把元素值在 m,m+1,⋯,m+d−1
中的数分到第一个桶，把元素值在 m+d,m+d+1,⋯,m+2d−1
中的数分到第二个桶，依此类推。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int maximumGap(vector&lt;int&gt;&amp; nums) {
        auto [m,M]=ranges::minmax(nums);
        if(M-m&lt;=1) return M-m;
        int n=nums.size();
        int d=(M-m+n-2)/(n-1);//答案至少是d
        vector&lt;pair&lt;int,int&gt;&gt; buckets((M-m)/d+1,{INT_MAX,INT_MIN});
        for(int x: nums){
            auto&amp; [mn,mx]=buckets[(x-m)/d];//这里要引用
            mn=min(mn,x);//维护桶内元素的最小值和最大值
            mx=max(mx,x);
        }
        int ans=0;
        int pre_max=INT_MAX;
        for(auto [mn,mx]: buckets){
            if(mn!=INT_MAX){//非空桶
                ans=max(ans,mn-pre_max);//桶内最小值，减去上一个非空桶的最大值
                pre_max=mx;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="910-最小差值1"><a class="header" href="#910-最小差值1">910 最小差值1</a></h1>
<p>给你一个整数数组 nums，和一个整数 k 。</p>
<p>对于每个下标 i（0 &lt;= i &lt; nums.length），将 nums[i] 变成 nums[i] +
k 或 nums[i] - k 。</p>
<p>nums 的 分数 是 nums 中最大元素和最小元素的差值。</p>
<p>在更改每个下标对应的值之后，返回 nums 的最小 分数 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int smallestRangeII(vector&lt;int&gt;&amp; nums, int k) {
        ranges::sort(nums);
        int ans=nums.back()-nums.front();
        for(int i=1;i&lt;nums.size();++i){
            int mx=max(nums[i-1]+k,nums.back()-k);
            int mn=min(nums[0]+k,nums[i]-k);
            ans=min(ans,mx-mn);
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="31-下一个排列"><a class="header" href="#31-下一个排列">31 下一个排列</a></h1>
<p>整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。</p>
<pre><code>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
</code></pre>
<p>整数数组的 下一个排列
是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的
下一个排列
就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<pre><code>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
</code></pre>
<p>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int i=nums.size()-2;
        while(i&gt;=0&amp;&amp;nums[i]&gt;=nums[i+1]){
            i--;
        }
        if(i&gt;=0){
            int j=nums.size()-1;
            while(j&gt;=0&amp;&amp;nums[i]&gt;=nums[j]){
                j--;
            }
            swap(nums[i],nums[j]);
        }
        reverse(nums.begin()+i+1,nums.end());
    }
};
</code></pre>
</details>
<h1 id="287-寻找重复数"><a class="header" href="#287-寻找重复数">287 寻找重复数</a></h1>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括
1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<p>思路和算法</p>
<p>这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是
1 还是 0 就可以按位还原出重复的数是什么。</p>
<p>考虑第 i 位，我们记 nums 数组中二进制展开后第 i 位为 1 的数有 x 个，数字
[1,n] 这 n 个数二进制展开后第 i 位为 1 的数有 y 个，那么重复的数第 i
位为 1 当且仅当 x&gt;y。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int n=nums.size(),ans=0;
        int bit_max=31;
        while(!((n-1)&gt;&gt;bit_max)){
            bit_max-=1;
        }
        for(int bit=0;bit&lt;=bit_max;++bit){
            int x=0,y=0;
            for(int i=0;i&lt;n;i++){
                if(nums[i]&amp;(1&lt;&lt;bit)){
                    x+=1;
                }
                if(i&gt;=1&amp;&amp;(i&amp;(1&lt;&lt;bit))){
                    y+=1;
                }
            }
            if(x&gt;y){
                ans|=1&lt;&lt;bit;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="41-缺失的第一个正数"><a class="header" href="#41-缺失的第一个正数">41 缺失的第一个正数</a></h1>
<p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        for(int&amp; num:nums){
            if(num&lt;=0) num=n+1;
        }   
        for(int i=0;i&lt;n;i++){
            int num=abs(nums[i]);
            if(num&lt;=n) nums[num-1]=-abs(nums[num-1]);
        }
        for(int i=0;i&lt;n;i++){
            if(nums[i]&gt;0){
                return i+1;
            }
        }
        return n+1;
    }
};
</code></pre>
</details>
# 3222 求出硬币游戏的赢家
<p>给你两个 正 整数 x 和 y ，分别表示价值为 75 和 10 的硬币的数目。</p>
<p>Alice 和 Bob 正在玩一个游戏。每一轮中，Alice 先进行操作，Bob
后操作。每次操作中，玩家需要拿出价值 总和 为 115
的硬币。如果一名玩家无法执行此操作，那么这名玩家 输掉 游戏。</p>
<p>两名玩家都采取 最优 策略，请你返回游戏的赢家。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    string losingPlayer(int x, int y) {
        return min(x,y/4)%2?"Alice":"Bob";
    }
};
</code></pre>
</details>
# 936 戳印序列
<p>你想要用小写字母组成一个目标字符串 target。</p>
<p>开始的时候，序列由 target.length 个 '?'
记号组成。而你有一个小写字母印章 stamp。</p>
<p>在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行
10 * target.length 个回合。</p>
<p>举个例子，如果初始序列为 "?????"，而你的印章 stamp 是
"abc"，那么在第一回合，你可以得到
"abc??"、"?abc?"、"??abc"。（请注意，印章必须完全包含在序列的边界内才能盖下去。）</p>
<p>如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。</p>
<p>例如，如果序列是 "ababc"，印章是 "abc"，那么我们就可以返回与操作
"?????" -&gt; "abc??" -&gt; "ababc" 相对应的答案 [0, 2]；</p>
<p>另外，如果可以印出序列，那么需要保证可以在 10 * target.length
个回合内完成。任何超过此数字的答案将不被接受。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; movesToStamp(string stamp, string target) {
        auto m=stamp.size();
        auto n=target.size();
        vector&lt;int&gt; inDegreee(n-m+1,m);
        vector&lt;vector&lt;int&gt;&gt; edges(n);
        vector&lt;int&gt; seen(n);
        vector&lt;int&gt; q;
        for(auto i=0;i&lt;n-m+1;i++){
            for(auto j=0;j&lt;m;j++){
                if(target[i+j]==stamp[j]){
                    inDegreee[i]-=1;
                    if(inDegreee[i]==0) q.emplace_back(i);
                }else{
                    edges[i+j].emplace_back(i);
                }
            }
        }
        vector&lt;int&gt; ans;
        while(!q.empty()){
            int cur=q.back();
            q.pop_back();
            ans.emplace_back(cur);
            for(size_t i=0;i&lt;m;i++){
                if(!seen[cur+i]){
                    seen[cur+i]=true;
                    for(auto &amp;&amp;edge: edges[cur+i]){
                        inDegreee[edge]-=1;
                        if(inDegreee[edge]==0) q.emplace_back(edge);
                    }
                }
            }
        }
        if(ans.size()&lt;n-m+1) return {};
        ranges::reverse(ans);
        return ans;
    }
};
</code></pre>
</details>
# 60 排列序列
<p>给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<pre><code>"123"
"132"
"213"
"231"
"312"
"321"
</code></pre>
<p>给定 n 和 k，返回第 k 个排列。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    string getPermutation(int n, int k) {
        vector&lt;int&gt; s(n);
        iota(s.begin(),s.end(),1);
        for(int i=0;i&lt;k-1;i++){
            next_permutation(s.begin(),s.end());
        }
        string ans;
        for(auto t:s){
            ans+=to_string(t);
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="3233-统计不是特殊数字的数字数量"><a class="header" href="#3233-统计不是特殊数字的数字数量">3233 统计不是特殊数字的数字数量</a></h1>
<p>给你两个 正整数 l 和 r。对于任何数字 x，x 的所有正因数（除了 x
本身）被称为 x 的 真因数。</p>
<p>如果一个数字恰好仅有两个 真因数，则称该数字为 特殊数字。例如：</p>
<pre><code>数字 4 是 特殊数字，因为它的真因数为 1 和 2。
数字 6 不是 特殊数字，因为它的真因数为 1、2 和 3。
</code></pre>
<p>返回区间 [l, r] 内 不是 特殊数字 的数字数量。</p>
<details>
<pre><code class="language-cpp">class Solution {
public:
    int nonSpecialCount(int l, int r) {
        int n=sqrt(r);
        vector&lt;int&gt; v(n+1);
        int res=r-l+1;
        for(int i=2;i&lt;=n;i++){
            if(v[i]==0){
                if(i*i&gt;=l&amp;&amp;i*i&lt;=r){
                    res--;
                }
            }
            for(int j=i*i;j&lt;=n;j+=i){
                v[j]=1;
            }
        }
        return res;
    }
};
</code></pre>
</details>
<h1 id="1739-放置盒子"><a class="header" href="#1739-放置盒子">1739 放置盒子</a></h1>
<p>有一个立方体房间，其长度、宽度和高度都等于 n 个单位。请你在房间里放置 n
个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：</p>
<pre><code>你可以把盒子放在地板上的任何地方。
如果盒子 x 需要放置在盒子 y 的顶部，那么盒子 y 竖直的四个侧面都 必须 与另一个盒子或墙相邻。
</code></pre>
<p>给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。</p>
<details>
<pre><code class="language-cpp">class Solution {
public:
    int minimumBoxes(int n) {
        int ans = 0, max_n = 0;
        for (int i = 1; max_n + ans + i &lt;= n; ++i) {
            ans += i;
            max_n += ans;
        }
        for (int j = 1; max_n &lt; n; ++j) {
            ++ans;
            max_n += j;
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="407-接雨水-2"><a class="header" href="#407-接雨水-2">407 接雨水 2</a></h1>
<p>给你一个 m x n
的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
 <details>
<p>思路： 哪个格子的接水量，在一开始就能确定？</p>
<pre><code>最外面一圈的格子是无法接水的。
假设 (0,1) 的高度是最外面一圈的格子中最小的，且高度等于 5，那么和它相邻的 (1,1)，我们能知道：
    (1,1) 的水位不能超过 5，否则水会从 (0,1) 流出去。
    (1,1) 的水位一定可以等于 5，这是因为 (0,1) 的高度是最外面一圈的格子中最小的，(1,1) 的水不可能从其他地方流出去。
</code></pre>
<p>我们从最外面一圈的格子开始。想象成一个木桶，最外面一圈格子的高度视作木板的高度。</p>
<p>接着上面的讨论：</p>
<pre><code>如果 (1,1) 的高度 ≥5，那么 (0,1) 这块木板就没用了，我们去掉 (0,1) 这块木板，改用 (1,1) 这块木板。
如果 (1,1) 的高度 &lt;5，假设我们接的不是水，是水泥。那么把 (1,1) 的高度填充为 5，仍然可以去掉 (0,1) 这块木板，改用 (1,1) 这块（填充水泥后）高为 5 的木板水泥板。
</code></pre>
<p>继续，从当前木板中，找到一根最短的木板。假设 (1,1)
是当前所有木板中最短的，那么其邻居 (1,2) 和 (2,1) 的水位就是 (1,1)
的高度，因为超过 (1,1) 高度的水会流出去。然后，去掉 (1,1) 这块木板，改用
(1,2) 和 (2,1) 这两块木板。依此类推。</p>
<p>由于每次都要找最短的木板，所以用一个最小堆维护木板的高度。按照上述做法，不断循环，直到堆为空。</p>
<pre><code class="language-cpp">class Solution {
    static constexpr int dxy[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
public:
    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) {
        int m=heightMap.size(),n=heightMap[0].size();
        priority_queue&lt;tuple&lt;int,int,int&gt;,vector&lt;tuple&lt;int,int,int&gt;&gt;,greater&lt;&gt;&gt; pq;
        for(int i=0;i&lt;m;i++){
            for(int j=0;j&lt;n;j++){
                if(i==0||i==m-1||j==0||j==n-1){
                    pq.emplace(heightMap[i][j],i,j);
                    heightMap[i][j]=-1;//标记(i,j)，表示访问过
                }
            }
        }
        int ans=0;
        while(!pq.empty()){
            auto [min_height,i,j]=pq.top();
            pq.pop();
            for(auto&amp; [dx,dy]:dxy){
                int x=i+dx,y=j+dy;//(x,y)的邻居
                if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;heightMap[x][y]&gt;=0){//(x,y)没有访问过
                    //如果(x,y)的高度小于min_height,那么接水量为min_height-heightMap[x][y]
                    ans+=max(min_height-heightMap[x][y],0);
                    //给木桶新增一块高为max(heightMap[x][y],min_height)的木板
                    pq.emplace(max(min_height,heightMap[x][y]),x,y);
                    heightMap[x][y]=-1;
                }
            }
        }
        return ans;
    }
};
</code></pre>
 </details>
<h1 id="408-有效单词缩写"><a class="header" href="#408-有效单词缩写">408 有效单词缩写</a></h1>
<p>字符串可以用 缩写 进行表示，缩写 的方法是将任意数量的 不相邻
的子字符串替换为相应子串的长度。例如，字符串 "substitution"
可以缩写为（不止这几种方法）：</p>
<pre><code>"s10n" ("s ubstitutio n")
"sub4u4" ("sub stit u tion")
"12" ("substitution")
"su3i1u2on" ("su bst i t u ti on")
"substitution" (没有替换子字符串)
</code></pre>
<p>下列是不合法的缩写：</p>
<pre><code>"s55n" ("s ubsti tutio n"，两处缩写相邻)
"s010n" (缩写存在前导零)
"s0ubstitution" (缩写是一个空字符串)
</code></pre>
<p>给你一个字符串单词 word 和一个缩写 abbr
，判断这个缩写是否可以是给定单词的缩写。</p>
<p>子字符串是字符串中连续的非空字符序列。</p>
<details>
<pre><code class="language-cpp">class Solution {
public:
    bool validWordAbbreviation(string word, string abbr) {
        int len=abbr.size();
        int wordLen=word.size();
        int abbrLen=0,num=0;
        for(int i=0;i&lt;len;i++){
            if(abbr[i]&gt;='a'&amp;&amp;abbr[i]&lt;='z'){
                abbrLen+=num+1;
                num=0;
                if(abbrLen&gt;wordLen||abbr[i]!=word[abbrLen-1]){
                    return false;
                }
            }else{
                if(!num&amp;&amp;abbr[i]=='0'){
                    return false;
                }
                num=num*10+abbr[i]-'0';
            }
        }
        return abbrLen+num==wordLen;
    }
};
</code></pre>
</details>
<h1 id="3208-交替数组"><a class="header" href="#3208-交替数组">3208 交替数组</a></h1>
<p>给你一个整数数组 colors 和一个整数 k
，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为
colors[i] ：</p>
<pre><code>colors[i] == 0 表示第 i 块瓷砖的颜色是 红色 。
colors[i] == 1 表示第 i 块瓷砖的颜色是 蓝色 。
</code></pre>
<p>环中连续 k 块瓷砖的颜色如果是 交替
颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和
右边 的颜色都不同），那么它被称为一个 交替 组。</p>
<p>请你返回 交替 组的数目。</p>
<p>注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。</p>
<details>
<pre><code class="language-cpp">class Solution {
public:
    int numberOfAlternatingGroups(vector&lt;int&gt;&amp; colors, int k) {
        int n=colors.size();
        int ans=0,cnt=0;
        for(int i=0;i&lt;n*2;i++){
            if(i&gt;0&amp;&amp;colors[i%n]==colors[(i-1)%n]){
                cnt=0;
            }
            cnt++;
            ans+=i&gt;=n&amp;&amp;cnt&gt;=k;
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="unsolved-3209-子数组按位与值为-k-的数目"><a class="header" href="#unsolved-3209-子数组按位与值为-k-的数目">UNSOLVED 3209 子数组按位与值为 K 的数目</a></h1>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回 nums
中有多少个子数组满足：子数组中所有元素按位 AND 的结果为 k 。</p>
<details>
<pre><code class="language-cpp">class Solution {
public:
    long long countSubarrays(vector&lt;int&gt;&amp; nums, int k) {
        long long ans=0;
        for(int i=0;i&lt;nums.size();i++){
            int x=nums[i];
            for(int j=i-1;j&gt;=0&amp;&amp;(nums[j]&amp;x)!=nums[j];j--){
                nums[j]&amp;=x;
            }
            ans+=upper_bound(nums.begin(),nums.begin()+i+1,k)-lower_bound(nums.begin(),nums.begin()+i+1,k);
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="782-变为棋盘"><a class="header" href="#782-变为棋盘">782 变为棋盘</a></h1>
<p>一个 n x n 的二维网络 board 仅由 0 和 1 组成 。每次移动，你能交换任意两列或是两行的位置。</p>
<p>返回 将这个矩阵变为  “棋盘”  所需的最小移动次数 。如果不存在可行的变换，输出 -1。</p>
<p>“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p>
<details>
<p>思路
board 要能变成棋盘，有两个必要条件：</p>
<pre><code>只有两种行：A 行是从 0101⋯ 交换得到的，也就是说，A 行中的 0 的个数和 1 的个数相差至多为 1；B 行是从 1010⋯ 交换得到的，和 A 行完全相反。
这两种行的个数相差至多为 1。
</code></pre>
<p>不能变成棋盘的情况</p>
<p>核心思路：统计 A 行和 B 行的个数。统计的过程中，如果发现有一行既不是 A 行也不是 B 行，直接返回 −1。统计结束后，如果发现 A 行和 B 行的个数相差超过 1，也返回 −1。</p>
<p>可以用哈希表统计。但是，没有这个必要。</p>
<p>以 board 第一行（或者任意一行）为参照物。</p>
<p>统计 board 第一行中的 0 和 1 的个数，如果 0 和 1 的个数相差超过 1，说明这一行既不是 A 行也不是 B 行，无论如何交换，绝不可能得到棋盘，返回 −1。</p>
<p>对于其余行 board[i]，首先比较 board[i][0] 和 board[0][0]：</p>
<pre><code>相同：那么 board[i] 必须和 board[0] 完全相同，即对于任意 j，board[i][j]=board[0][j] 成立。若不满足，返回 −1。
不同：那么 board[i] 必须和 board[0] 完全不同，即对于任意 j，board[i][j]=board[0][j] 成立。若不满足，返回 −1。
</code></pre>
<p>如果没有返回 −1，那么说明只有 A 行和 B 行。我们也只需统计 board[i][0]（第一列）的 0 和 1 的个数，就知道有多少个 A 行和 B 行。如果 0 和 1 的个数相差超过 1，那么返回 −1。（代码实现时，关于第一列的判断可以放在前面）</p>
<p>如果上述情况都没有返回 −1，那么 board 一定可以变成棋盘，方法如下。
最小交换次数</p>
<p>比如把 s=001110 通过交换元素，变成 t=010101。这其中 s[i]=t[i] 出现了 4 次。我们需要让 s 中的 0 在偶数下标上，1 在奇数下标上。那么把奇数上的 0 和偶数上的 1 交换，就可以满足要求，所以只需要 24​=2 次交换。一般地，有如下定理。</p>
<p>定理：如果有 diff 个位置与目标值不同，那么只需交换 2diff​ 次。</p>
<p>证明：首先 2diff​ 是交换次数的下界。下面证明可以只用 2diff​ 次交换。</p>
<p>不失一般性，假设要把 s 通过交换，变成 t=010101⋯。注意这意味着当 n 是奇数时，0 的个数更多。</p>
<pre><code>如果 n 是偶数，那么恰好有 2n​ 个 0，2n​ 个 1，2n​ 个偶数下标，2n​ 个奇数下标。设有 k 个 0 在奇数下标上，那么有 2n​−k 个 1 在奇数下标上，所以有 2n​−(2n​−k)=k 个 1 在偶数下标上，所以只需 k 次交换。注意这意味着 diff=2k，所以 diff 必定是偶数。
如果 n 是奇数，0 的个数比 1 的多 1，那么有 2n−1​+1 个 0 和 2n−1​ 个奇数下标，所以必然存在一个 0 在偶数下标上（也就是在正确的位置上），去掉这个 0，变成 n 是偶数的情况，结论同上。
</code></pre>
<p>根据该定理，得到如下计算方法：</p>
<pre><code>如果 n 是偶数，那么可以交换成 010101⋯，也可以交换成 101010⋯，设交换成 t=010101⋯ 的 s[i]=t[i] 的个数为 diff，那么交换成 t′=101010⋯ 的 s[i]=t′[i] 的个数为 n−diff，二者取最小值，最小交换次数为 2min(diff,n−diff)​。
如果 n 是奇数，那么 t 是唯一的，最小交换次数为 2diff​。
</code></pre>
<p>答案是第一行的最小交换次数，加上第一列的最小交换次数。</p>
<p>交换完成后，就得到了棋盘。</p>
<pre><code class="language-cpp">class Solution {
public:
    int movesToChessboard(vector&lt;vector&lt;int&gt;&gt;&amp; board) {
        int n=board.size();
        auto&amp; first_row=board[0];
        vector&lt;int&gt; first_col(n);
        int row_cnt[2]{},col_cnt[2]{};
        for(int i=0;i&lt;n;i++){
            row_cnt[first_row[i]]++;
            first_col[i]=board[i][0];
            col_cnt[first_col[i]]++;
        }
        if(abs(row_cnt[0]-row_cnt[1])&gt;1||abs(col_cnt[0]-col_cnt[1])&gt;1){
            return -1;
        }
        for(auto&amp; row:board){
            bool same=row[0]==first_row[0];
            for(int i=0;i&lt;n;i++){
                if((row[i]==first_row[i])!=same){
                    return -1;
                }
            }
        }
        auto min_swap=[&amp;](vector&lt;int&gt;&amp; arr,int cnt[2]){
            int x0=cnt[1]&gt;cnt[0];
            int diff=0;
            for(int i=0;i&lt;n;i++){
                diff+=i%2^arr[i]^x0;
            }
            return n%2?diff/2:min(diff,n-diff)/2;
        };
        return min_swap(first_row,row_cnt)+min_swap(first_col,col_cnt);
    }
};
</code></pre>
</details>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../数据结构与算法/字符串算法.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../数据结构与算法/队列.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../数据结构与算法/字符串算法.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../数据结构与算法/队列.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
