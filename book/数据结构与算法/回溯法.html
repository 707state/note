<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>回溯 - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#77-%E7%BB%84%E5%90%88">77 组合</a></li>
<li><a href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C">39 组合总和</a></li>
<li><a href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88">17
电话号码的字母组合</a></li>
<li><a href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C">216 组合总和</a></li>
<li><a href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C2">40 组合总和2</a></li>
<li><a href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2">131 分割回文串</a></li>
<li><a href="#93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80">93 复原IP地址</a></li>
<li><a href="#78-%E5%AD%90%E9%9B%86">78 子集</a></li>
<li><a href="#90-%E5%AD%90%E9%9B%862">90 子集2</a></li>
<li><a href="#491-%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97">491 非递减子序列</a></li>
<li><a href="#46-%E5%85%A8%E6%8E%92%E5%88%97">46 全排列</a></li>
<li><a href="#47-%E5%85%A8%E6%8E%92%E5%88%972">47 全排列2</a></li>
<li><a href="#332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B">332 重新安排行程</a></li>
<li><a href="#51-n%E7%9A%87%E5%90%8E">51 N皇后</a></li>
<li><a href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC">37 解数独</a></li>
<li><a href="#980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-3">980 不同路径 3</a></li>
<li><a href="#752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81">752 打开转盘锁</a></li>
<li><a href="#1239-%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6">1239
串联字符串的最大长度</a></li>
<li><a href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90">22 括号生成</a></li>
<li><a href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2">79 单词搜索</a></li>
<li><a href="#502-N%E7%9A%87%E5%90%8E2">502 N皇后2</a></li>
</ul>
<h1 id="77-组合"><a class="header" href="#77-组合">77 组合</a></h1>
<p>\textcolor{red}{<a href="https://leetcode.cn/problems/combinations/">链接</a>}</p>
<p>经典的组合数目题目，就是用递归+回溯，添加一个节点到path然后递归。</p>
<p>示例代码：</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
void helper(int &amp;n,int&amp; k,int startIndex){
    if(path.size()==k){
        result.emplace_back(path);
        return;
    }
    for(int i=startIndex;i&lt;=n-(k-path.size())+1;i++){
        path.emplace_back(i);
        helper(n,k,i+1);
        path.pop_back();
    }
}
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        helper(n,k,1);
        return result;
    }
};
</code></pre>
</details>
<h1 id="39-组合总和"><a class="header" href="#39-组合总和">39 组合总和</a></h1>
<p>与上述基本相同，注意的是同一个可以被多次计算。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; candidates,int target,int sum,int startIndex){
        if(sum&gt;target){
            return;
        }
        if(sum==target){
            result.emplace_back(path);
        }
        for(int i=startIndex;i&lt;candidates.size();i++){
            sum+=candidates[i];
            path.emplace_back(candidates[i]);
            backtracking(candidates,target,sum,i);
            sum-=candidates[i];
            path.pop_back();
        }
        return;
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        backtracking(candidates,target,0,0);
        return result;
    }
};
</code></pre>
</details>
优化版本
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; candidates,int target,int sum,int startIndex){
        if(sum==target){
            result.emplace_back(path);
        }
        for(int i=startIndex;i&lt;candidates.size()&amp;&amp;sum+candidates[i]&lt;=target;i++){
            sum+=candidates[i];
            path.emplace_back(candidates[i]);
            backtracking(candidates,target,sum,i);
            sum-=candidates[i];
            path.pop_back();
        }
        return;
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        ranges::sort(candidates.begin(),candidates.end());
        backtracking(candidates,target,0,0);
        return result;
    }
};
</code></pre>
</details>
<h1 id="17-电话号码的字母组合"><a class="header" href="#17-电话号码的字母组合">17 电话号码的字母组合</a></h1>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;string&gt; ans;
std::string path;
unordered_map&lt;char,string&gt; key_to_map{
    {'2',"abc"},
    {'3',"def"},
    {'4',"ghi"},
    {'5',"jkl"},
    {'6',"mno"},
    {'7',"pqrs"},
    {'8',"tuv"},
    {'9',"wxyz"}
};
void backtracking(string&amp; digits,int startIndex){
    if(path.length()==digits.length()){
        ans.emplace_back(path);
        return;
    }
    auto map_=key_to_map[digits[startIndex]];
    for(int i=0;i&lt;map_.length();i++){
        path.push_back(map_[i]);
        backtracking(digits,startIndex+1);
        path.pop_back();
    }
    return;
}
    vector&lt;string&gt; letterCombinations(string digits) {
        if(digits.length()==0){
            return vector&lt;string&gt;{};
        }
        backtracking(digits,0);
        return ans;
    }
};
</code></pre>
</details>
<h1 id="216-组合总和"><a class="header" href="#216-组合总和">216 组合总和</a></h1>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
    void backtracking(int targetSum,int k,int sum,int startIndex){
        if(path.size()==k){
            if(targetSum==sum){
                result.emplace_back(path);
            }
            return;
        }
        for(int i=startIndex;i&lt;=9&amp;&amp;sum+i&lt;=targetSum;i++){
            sum+=i;
            path.emplace_back(i);
            backtracking(targetSum,k,sum,i+1);
            path.pop_back();
            sum-=i;
        }
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {
        backtracking(n,k,0,1);
        return result;
    }
};
</code></pre>
</details>
<h1 id="40-组合总和2"><a class="header" href="#40-组合总和2">40 组合总和2</a></h1>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
void backtracking(vector&lt;int&gt;&amp; candidates,int target,int targetSum,int startIndex,int n,vector&lt;bool&gt;&amp; used){
    if(targetSum&gt;target){
        return;
    }
    if(target==targetSum){
        result.emplace_back(path);
        return;
    }
    for(int i=startIndex;i&lt;n;i++){
        if(i&gt;0&amp;&amp;candidates[i]==candidates[i-1]&amp;&amp;used[i-1]==false){
            continue;
        }
        used[i]=true;
        targetSum+=candidates[i];
        path.push_back(candidates[i]);
        backtracking(candidates,target,targetSum,i+1,n,used);
        used[i]=false;
        targetSum-=candidates[i];
        path.pop_back();
    }
}
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        sort(candidates.begin(),candidates.end());
        vector&lt;bool&gt; used(candidates.size(),false);
        backtracking(candidates,target,0,0,candidates.size(),used);
        return result;
    }
};
</code></pre>
</details>
<h1 id="131-分割回文串"><a class="header" href="#131-分割回文串">131 分割回文串</a></h1>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; path;
    bool is_palindrome(const std::string&amp; str,int start,int end){
        for(int i=start,j=end;i&lt;j;i++,j--){
            if(str[i]!=str[j]){
                return false;
            }
        }
        return true;
    }
    void backtracking(const std::string&amp; s,int startIndex){
        if(startIndex&gt;=s.size()){
            result.emplace_back(path);
            return;
        }
        for(int i=startIndex;i&lt;s.size();i++){
            if(is_palindrome(s, startIndex,i)){
                auto str=s.substr(startIndex,i-startIndex+1);
                path.emplace_back(str);
            }else{
                continue;
            }
            backtracking(s, i+1);
            path.pop_back();
        }
    }
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        backtracking(s,0);
        return result;
    }
};
</code></pre>
</details>
<h1 id="93-复原ip地址"><a class="header" href="#93-复原ip地址">93 复原IP地址</a></h1>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;string&gt; result;
bool is_valid(string&amp; s,int startIndex,int end){
    if(startIndex&gt;end){
        return false;
    }
    if(s[startIndex]=='0'&amp;&amp;startIndex!=end){
        return false;
    }
    int num=0;
    for(int i=startIndex;i&lt;=end;i++){
        if(s[i]&gt;'9'||s[i]&lt;'0'){
            return false;
        }
        num=num*10+(s[i]-'0');
        if(num&gt;255){
            return false;
        }
    }
    return true;
}
void backtracking(string&amp; s,int startIndex,int pointNum){
    if(pointNum==3){
        if(is_valid(s,startIndex,s.size()-1)){
            result.emplace_back(s);
        }
        return;
    }
    for(int i=startIndex;i&lt;s.size();i++){
        if(is_valid(s,startIndex,i)){
            s.insert(s.begin()+i+1,'.');
            pointNum++;
            backtracking(s,i+2,pointNum);
            s.erase(s.begin()+i+1);
            pointNum--;
        }else{
            break;
        }
    }
}
    vector&lt;string&gt; restoreIpAddresses(string s) {

        backtracking(s,0,0);
        return result;
    }
};
</code></pre>
</details>
<h1 id="78-子集"><a class="header" href="#78-子集">78 子集</a></h1>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; nums,int startIndex){
        result.emplace_back(path);
        if(startIndex&gt;=nums.size()){
            return;
        }
        for(int i=startIndex;i&lt;nums.size();i++){
            path.push_back(nums[i]);
            backtracking(nums,i+1);
            path.pop_back();
        }
    }
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        backtracking(nums, 0);
        return result;
    }
};
</code></pre>
</details>
<p>子集是收集树形结构中树的所有节点的结果。</p>
<p>而组合问题、分割问题是收集树形结构中叶子节点的结果。</p>
<h1 id="90-子集2"><a class="header" href="#90-子集2">90 子集2</a></h1>
<p>参考前面的组合总和2, 排序+判断数组</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
void backtracking(vector&lt;int&gt;&amp; nums,int startIndex,vector&lt;bool&gt; &amp;used){
    result.emplace_back(path);
    for(int i=startIndex;i&lt;nums.size();i++){
        if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;used[i-1]==false){
            continue;
        }
        used[i]=true;
        path.push_back(nums[i]);
        backtracking(nums,i+1,used);
        path.pop_back();
        used[i]=false;
    }
}
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        vector&lt;bool&gt; used(nums.size());
        backtracking(nums,0,used);
        return result;
    }
};
</code></pre>
</details>
<h1 id="491-非递减子序列"><a class="header" href="#491-非递减子序列">491 非递减子序列</a></h1>
<p>描述：</p>
<p>给你一个整数数组 nums
，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素
。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
void backtracking(vector&lt;int&gt;&amp; nums,int startIndex){
    if(path.size()&gt;1){
        result.emplace_back(path);
    }
    int uset[201]{};
    for(int i=startIndex;i&lt;nums.size();i++){
        if((path.size()&amp;&amp;nums[i]&lt;path.back())||uset[nums[i]+100]&gt;0){
            continue;
        }
        path.push_back(nums[i]);
        uset[nums[i]+1]++;
        backtracking(nums,i+1);
        path.pop_back();
    }
}
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) {
        backtracking(nums,0);
        return result;
    }
};
</code></pre>
</details>
<h1 id="46-全排列"><a class="header" href="#46-全排列">46 全排列</a></h1>
<p>要点在于，需要注意到重复元素</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
void backtracking(vector&lt;int&gt;&amp; nums,int startIndex,vector&lt;bool&gt;&amp; used){
    if(path.size()==nums.size()){
        result.emplace_back(path);
        return;
    }
    for(int i=0;i&lt;nums.size();i++){
        if(used[i]){
            continue;
        }
        used[i]=true;
        path.push_back(nums[i]);
        backtracking(nums,i+1,used);
        used[i]=false;
        path.pop_back();
    }

}
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
                vector&lt;bool&gt; used(nums.size());
        backtracking(nums, 0,used);

        return result;
    }
};
</code></pre>
</details>
<h1 id="47-全排列2"><a class="header" href="#47-全排列2">47 全排列2</a></h1>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; path;
void backtracking(vector&lt;int&gt;&amp; nums,int startIndex,vector&lt;bool&gt;&amp; used){
    if(path.size()==nums.size()){
        result.emplace_back(path);
        return;
    }
    for(int i=0;i&lt;nums.size();i++){
        if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;used[i-1]==false){
            continue;
        }
        if(used[i]){
            continue;
        }
        used[i]=true;
        path.push_back(nums[i]);
        backtracking(nums,i+1,used);
        path.pop_back();
        used[i]=false;
    }
}
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        vector&lt;bool&gt; used(nums.size());
        backtracking(nums, 0, used);
        return result;
    }
};
</code></pre>
</details>
<h1 id="332-重新安排行程"><a class="header" href="#332-重新安排行程">332 重新安排行程</a></h1>
<p>描述：</p>
<p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi]
表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从
JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK
开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<pre><code>例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
</code></pre>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且
只能用一次。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
    //出发机场-&gt;到达机场-&gt;航班次数
    std::unordered_map&lt;string,map&lt;string,int&gt;&gt; targets;

public:
    bool backtracking(int ticketNum,vector&lt;string&gt;&amp; result){
        if(result.size()==ticketNum+1){
            return true;
        }
        for(auto&amp; target:targets[result.back()]){
            if(target.second&gt;0){//说明有达到的路线
                result.push_back(target.first);
                target.second--;
                if(backtracking(ticketNum,result)){
                    return true;
                }
                result.pop_back();
                target.second++;
            }
        }
        return false;
    }
    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) {
        vector&lt;string&gt; result;
        for(const auto&amp; vec: tickets){
            targets[vec[0]][vec[1]]++;
        }
        result.push_back("JFK");
        backtracking(tickets.size(),result);
        return result;
    }
};
</code></pre>
</details>
<p>重点在于找到合适的描述字典序排序的容器。</p>
<h1 id="51-n皇后"><a class="header" href="#51-n皇后">51 N皇后</a></h1>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n
的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和
'.' 分别代表了皇后和空位。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
    vector&lt;vector&lt;string&gt;&gt; result;
    bool is_valid(int row,int col,vector&lt;string&gt;&amp; chessboard,int n){
        int count=0;
        for(int i=0;i&lt;row;i++){
            if(chessboard[i][col]=='Q'){return false;}
        }
        for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--){
            if(chessboard[i][j]=='Q') return false;
        }
        for(int i=row-1,j=col+1;i&gt;=0&amp;&amp; j&lt;n;i--,j++){
            if(chessboard[i][j]=='Q') return false;
        }
        return true;
    }
    void backtracking(int n,int row,vector&lt;string&gt;&amp; chessboard){
        if(row==n){
            result.emplace_back(chessboard);
            return ;
        }
        for(int col=0;col&lt;n;col++){
            if(is_valid(row,col,chessboard,n)){
                chessboard[row][col]='Q';//放置皇后
                backtracking(n,row+1,chessboard);
                chessboard[row][col]='.';//撤销皇后
            }
        }
    }
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        vector&lt;string&gt; chessboard(n,std::string(n,'.'));
        backtracking(n, 0,chessboard);
        return result;
    }
};
</code></pre>
</details>
<h1 id="37-解数独"><a class="header" href="#37-解数独">37 解数独</a></h1>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<pre><code>数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
</code></pre>
<p>数独部分空格内已填入了数字，空白格用 '.' 表示。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
bool backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; board){
    for(int i=0;i&lt;board.size();i++){
        for(int j=0;j&lt;board[0].size();j++){
            if(board[i][j]!='.')continue;
            for(char k='1';k&lt;='9';k++){
                if(is_valid(i,j,k,board)){
                    board[i][j]=k;
                    if(backtracking(board)) return true;
                    board[i][j]='.';
                }
            }
            return false;
        }
    }
    return true;
}
bool is_valid(int row,int col,char val,vector&lt;vector&lt;char&gt;&gt;&amp; board){
    for(int i=0;i&lt;9;i++){
        if(board[row][i]==val){
            return false;
        }
    }
    for(int i=0;i&lt;9;i++){
        if(board[i][col]==val){
            return false;
        }
    }
    int startRow=(row/3)*3;
    int startCol=(col/3)*3;
    for(int i=startRow;i&lt;startRow+3;i++){
        for(int j=startCol;j&lt;startCol+3;j++){
            if(board[i][j]==val){
                return false;
            }
        }
    }
    return true;
}
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        backtracking(board);
    }
};
</code></pre>
</details>
<h1 id="980-不同路径-3"><a class="header" href="#980-不同路径-3">980 不同路径 3</a></h1>
<p>在二维网格 grid 上，有 4 种类型的方格：</p>
<pre><code>1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
</code></pre>
<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。</p>
<p>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int dfs(int x,int y,int left,vector&lt;vector&lt;int&gt;&gt;&amp; grid){
       if(x&lt;0||y&lt;0||x&gt;=grid.size()||y&gt;=grid[0].size()||grid[x][y]&lt;0){
        return 0;
       }
        if(grid[x][y]==2){
            return left==0;
        }
        grid[x][y]=-1;
        int ans=dfs(x+1,y,left-1,grid)+dfs(x-1,y,left-1,grid)+dfs(x,y+1,left-1,grid)+dfs(x,y-1,left-1,grid);
        grid[x][y]=0;
        return ans;
    }
    int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int sx,sy,left;
        for(int i=0;i&lt;grid.size();i++){
            for(int j=0;j&lt;grid[0].size();j++){
                if(grid[i][j]==1){
                    sx=i;
                    sy=j;
                }
                if(grid[i][j]==0){
                    left++;
                }
            }
        }
        return dfs(sx,sy,left,grid);
    }
};
</code></pre>
</details>
<h1 id="752-打开转盘锁"><a class="header" href="#752-打开转盘锁">752 打开转盘锁</a></h1>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1',
'2', '3', '4', '5', '6', '7', '8', '9'
。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9'
。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 deadends
包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 target
代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回
-1 。</p>
<p>广度优先搜索：</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int openLock(vector&lt;string&gt;&amp; deadends, string target) {
        if (target == "0000")
            return 0;
        auto prev_char = [](char c) -&gt; char { return c == '0' ? '9' : c - 1; };
        auto next_char = [](char c) -&gt; char { return c == '9' ? '0' : c + 1; };
        auto next_status = [&amp;](string&amp; status) -&gt; array&lt;string, 8&gt; {
            array&lt;string, 8&gt; next_stat;
            for (int i = 0; i &lt; 4; i++) {
                char num = status[i];
                status[i] = prev_char(num);
                next_stat[i * 2] = status;
                status[i] = next_char(num);
                next_stat[i * 2 + 1] = status;
                status[i] = num;
            }
            return next_stat;
        };
        unordered_set&lt;string&gt; dead{deadends.begin(), deadends.end()};
        if (dead.count(target) || dead.count("0000")) {
            return -1;
        }
        queue&lt;pair&lt;string, int&gt;&gt; q;
        q.emplace("0000", 0);
        unordered_set&lt;string&gt; seen = {"0000"};
        while (!q.empty()) {
            auto [status, step] = q.front();
            q.pop();
            for (auto&amp;&amp; next_stat : next_status(status)) {
                if (!seen.count(next_stat) &amp;&amp; !dead.count(next_stat)) {
                    if (next_stat == target) {
                        return step + 1;
                    }
                    q.emplace(next_stat, step + 1);
                    seen.insert(move(next_stat));
                }
            }
        }
        return -1;
    }
};
</code></pre>
</details>
<h1 id="1239-串联字符串的最大长度"><a class="header" href="#1239-串联字符串的最大长度">1239 串联字符串的最大长度</a></h1>
<p>给定一个字符串数组 arr，字符串 s 是将 arr 的含有 不同字母 的 子序列
字符串 连接 所得的字符串。</p>
<p>请返回所有可行解 s 中最长长度。</p>
<p>子序列是一种可以从另一个数组派生而来的数组，通过删除某些元素或不删除元素而不改变其余元素的顺序。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int maxLength(vector&lt;string&gt;&amp; arr) {
        vector&lt;int&gt; masks;
        for(string &amp;s: arr){
            int mask=0;
            for(auto ch: s){
                ch-='a';
                if((mask&gt;&gt;ch)&amp;1){//mask中已经有ch, 说明s含有重复字母，无法构成可行解
                    mask=0;
                    break;
                }
                mask|=1&lt;&lt;ch;
            }
            if(mask&gt;0) masks.push_back(mask);
        }
        int ans=0;
        function&lt;void(int,int)&gt; backtracking=[&amp;](int pos,int mask){
            if(pos==masks.size()){
                ans=max(ans,__builtin_popcount(mask));
                return;
            }
            if((mask&amp;masks[pos])==0){//mask和masks[pos]，没有公共元素
                backtracking(pos+1,mask|masks[pos]);
            }
            backtracking(pos+1,mask);
        };
        backtracking(0,0);
        return ans;
    }
};
</code></pre>
</details>
<h1 id="22-括号生成"><a class="header" href="#22-括号生成">22 括号生成</a></h1>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且
有效的 括号组合。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
    vector&lt;string&gt; ans;
    void backtracking(string&amp; cur,int open,int close,int n){
        if(cur.size()==n*2){
            ans.emplace_back(cur);
            return;
        }
        if(open&lt;n){
            cur.push_back('(');
            backtracking(cur,open+1,close,n);
            cur.pop_back();
        }
        if(close&lt;open){
            cur.push_back(')');
            backtracking(cur,open,close+1,n);
            cur.pop_back();
        }
    }
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        string cur;
        backtracking(cur, 0,0, n);
        return ans;
    }
};
</code></pre>
</details>
<h1 id="79-单词搜索"><a class="header" href="#79-单词搜索">79 单词搜索</a></h1>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word
存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
    constexpr static array&lt;int, 4&gt; dx = {0, 1, 0, -1};
    constexpr static array&lt;int, 4&gt; dy = {1, 0, -1, 0};
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        int n = board.size();
        int m = board[0].size();
        auto dfs = [&amp;](auto&amp;&amp; dfs, int i, int j, int index) {
            if (board[i][j] != word[index])
                return false;
            if (index + 1 == word.length())
                return true;
            board[i][j] = 0;
            for (int s = 0; s &lt; 4; s++) {
                int x = i + dx[s], y = j + dy[s];
                if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp;
                    dfs(dfs, x, y, index + 1)) {
                    return true;
                }
            }
            board[i][j] = word[index];
            return false;
        };
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {
                if (dfs(dfs, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }
};
</code></pre>
</details>
<h1 id="502-N皇后2"><a class="header" href="#502-N皇后2">502 N 皇后 2</a></h1>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<details>
<p>DFS+位运算剪枝</p>
<p>使用常规深度优先一层层搜索
使用三个整形分别标记每一层哪些格子可以放置皇后，这三个整形分别代表列、左斜下、右斜下（<em>col, ld, rd</em>），二进制位为 1 代表不能放置，0 代表可以放置
核心两个位运算：</p>
<pre><code>x &amp; -x 代表除最后一位 1 保留，其它位全部为 0
x &amp; (x - 1) 代表将最后一位 1 变成 0
</code></pre>
<pre><code class="language-cpp">class Solution {
    int res=0;
public:
    int totalNQueens(int n) {
        dfs(n,0,0,0,0);
        return res;
    }
    void dfs(int n,int row,int col,int ld,int rd){
        if(row&gt;=n){
            res++;
            return;
        }
        int bits=~(col|ld|rd)&amp;((1&lt;&lt;n)-1);
        while(bits&gt;0){
            int pick=bits&amp;-bits;
            dfs(n,row+1,col|pick,(ld|pick)&lt;&lt;1,(rd|pick)&gt;&gt;1);
            bits&amp;=bits-1;
        }
    }
};
</code></pre>
</details>
<details>
<p>回溯</p>
<p>皇后不能放置到有皇后的列/左对角线/右对角线。</p>
<p>col表示列，diag1表示右对角线，diag2表示左对角线。</p>
<pre><code class="language-cpp">class Solution {
public:
    int totalNQueens(int n) {
        int ans=0;
        vector&lt;int&gt; col(n),diag1(n*2-1),diag2(n*2-1);
        auto dfs=[&amp;](auto&amp;&amp; dfs,int r){
            if(r==n){
                ans++;
                return;
            }
            for(int c=0;c&lt;n;c++){
                int rc=r-c+n-1;
                if(!col[c]&amp;&amp;!diag1[c+r]&amp;&amp;!diag2[rc]){
                    col[c]=diag1[c+r]=diag2[rc]=true;
                    dfs(dfs,r+1);
                    col[c]=diag1[c+r]=diag2[rc]=false;
                }
            }
        };
        dfs(dfs,0);
        return ans;
    }
};
</code></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../数据结构与算法/位运算技巧.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../数据结构与算法/红黑树.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../数据结构与算法/位运算技巧.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../数据结构与算法/红黑树.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
