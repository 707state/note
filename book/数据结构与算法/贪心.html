<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>贪心法 - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#1005-k%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C">1005
k次取反后最大化的数组和</a></li>
<li><a href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-2">45 跳跃游戏 2</a></li>
<li><a href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99">134 加油站</a></li>
<li><a href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C">135 分发糖果</a></li>
<li><a href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97">406
根据身高重建队列</a></li>
<li><a href="#452-%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83">452
最少数量的箭引爆气球</a></li>
<li><a href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4">435 无重叠区间</a></li>
<li><a href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4">763 划分字母区间</a></li>
<li><a href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">56 合并区间</a></li>
<li><a href="#738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97">738 单调递增的数字</a></li>
<li><a href="#968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91">968 监控二叉树</a></li>
<li><a href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2">455 分发饼干</a></li>
<li><a href="#871-%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0">871 最低加油次数</a></li>
<li><a href="#1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">1090
受标签影响的最大值</a></li>
<li><a href="#3255-%E9%95%BF%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E8%83%BD%E9%87%8F%E5%80%BC2">3255
长度为k的子数组的能量值2</a></li>
<li><a href="#unsolved-2071-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%AE%89%E6%8E%92%E7%9A%84%E6%9C%80%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%95%B0%E7%9B%AE">UNSOLVED 2071
你可以安排的最多任务数目</a></li>
<li><a href="#658-%E6%89%BE%E5%88%B0k%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0">658
找到K个最接近的元素</a></li>
<li><a href="#632-%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4">632 最小区间</a></li>
<li><a href="#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2">409 最长回文串</a></li>
<li><a href="#410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">410
分割数组的最大值</a></li>
</ul>
<h1 id="1005-k次取反后最大化的数组和"><a class="header" href="#1005-k次取反后最大化的数组和">1005 k次取反后最大化的数组和</a></h1>
<p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>
<pre><code>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
</code></pre>
<p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p>
<p>以这种方式修改数组后，返回数组 可能的最大和 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) {
        sort(nums.begin(),nums.end(),[](int a,int b){
            return abs(a)&gt;abs(b);
        });
        for(int i=0;i&lt;nums.size();i++){
            if(nums[i]&lt;0&amp;&amp;k&gt;0){
                nums[i]=-nums[i];
                k--;
            }
        }
        if(k%2==1) nums[nums.size()-1]*=-1;
        int result=0;
        for(auto&amp; a: nums){
            result+=a;
        }
        return result;
    }
};
</code></pre>
</details>
<h1 id="45-跳跃游戏-2"><a class="header" href="#45-跳跃游戏-2">45 跳跃游戏 2</a></h1>
<p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在
nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>
<p>0 &lt;= j &lt;= nums[i]</p>
<p>i + j &lt; n</p>
<p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n -
1]。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        if (nums.size() == 1) {
            return 0;
        }
        int cur_dist = 0;
        int ans = 0;
        int next_dist = 0;
        for (int i = 0; i &lt; nums.size(); i++) {
            next_dist = max(next_dist, nums[i] + i);
            if (i == cur_dist) {
                if (cur_dist != nums.size() - 1) {
                    ans++;
                    cur_dist = next_dist;
                    if (next_dist &gt;= nums.size() - 1)
                        break;
                } else {
                    break;
                }
            }
        }
        return ans;
    }
};
</code></pre>
</details>
简化逻辑：
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        int ans=0;
        int cur_right=0;
        int next_right=0;
        for(int i=0;i+1&lt;nums.size();i++){
            next_right=max(next_right,i+nums[i]);
            if(i==cur_right){
                cur_right=next_right;
                ans++;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="134-加油站"><a class="header" href="#134-加油站">134 加油站</a></h1>
<p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1
个加油站需要消耗汽油 cost[i]
升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost
，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1
。如果存在解，则 保证 它是 唯一 的</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
    public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
    int curSum = 0;
    int totalSum = 0;
    int start = 0;
    for (int i = 0; i &lt; gas.size(); i++) {
        curSum += gas[i] - cost[i];
        totalSum += gas[i] - cost[i];
        if (curSum &lt; 0) {
        // 当前累加rest[i]和 curSum一旦小于0
            start = i + 1;// 起始位置更新为i+1
            curSum = 0;// curSum从0开始
        }
    }
    if (totalSum &lt; 0) return -1; // 说明怎么走都不可能跑一圈了
    return start;
}
};
</code></pre>
</details>
<h1 id="135-分发糖果"><a class="header" href="#135-分发糖果">135 分发糖果</a></h1>
<p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<pre><code>每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
</code></pre>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<p>思路：</p>
<p>这道题目一定是要确定一边之后,再确定另一边,例如比较每一个孩子的左边,然后再比较右边,如果两边一起考虑一定会顾此失彼。</p>
<p>先确定右边评分大于左边的情况(也就是从前向后遍历)此时局部最优:只要右边评分比左边大,右边的孩子就多一个糖果,全局最优:相邻的孩子中,评分高的右孩子获得比左边孩子更多的糖果局部最优可以推出全局最优。
如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i -
1]的糖多一个,所以贪心:candyVec[i] = candyVec[i - 1] + 1</p>
<p>再确定左孩子大于右孩子的情况(从后向前遍历)</p>
<p>遍历顺序这里有同学可能会有疑问,为什么不能从前向后遍历呢?</p>
<p>因为如果从前向后遍历,根据 ratings[i + 1] 来确定 ratings[i]
对应的糖果,那么每次都不能利用上前一次的比较结果了。</p>
<p>所以确定左孩子大于右孩子的情况一定要从后向前遍历!如果 ratings[i] &gt;
ratings[i +
1],此时candyVec<a href="%E7%AC%ACi%E4%B8%AA%E5%B0%8F%E5%AD%A9%E7%9A%84%E7%B3%96%E6%9E%9C%E6%95%B0%E9%87%8F">i</a>就有两个选择了,一个是candyVec[i
+1] +
1(从右边这个加1得到的糖果数量),一个是candyVec<a href="%E4%B9%8B%E5%89%8D%E6%AF%94%E8%BE%83%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%A4%A7%E4%BA%8E%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%BE%97%E5%88%B0%E7%9A%84%E7%B3%96%E6%9E%9C%E6%95%B0%E9%87%8F">i</a>。
那么又要贪心了,局部最优:取candyVec[i + 1] + 1 和 candyVec[i]
最大的糖果数量,保证第i个小孩的糖果数量即
大于左边的也大于右边的。全局最优:相邻的孩子中,评分高的孩子获得更多的糖果。
局部最优可以推出全局最优。 所以就取candyVec[i + 1] + 1 和
candyVec[i] 最大的糖果数量,candyVec[i]只有取最大的才能既保持对左边
candyVec[i - 1]的糖果多,也比右边candyVec[i + 1]的糖果多。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int candy(vector&lt;int&gt;&amp; ratings) {
        vector&lt;int&gt; candyVec(ratings.size(),1);
        //从前向后
        for(int i=1;i&lt;ratings.size();i++){
            if(ratings[i]&gt;ratings[i-1]) candyVec[i]=candyVec[i-1]+1;
        }
        //从后向前
        for(int i=ratings.size()-2;i&gt;=0;i--){
            if(ratings[i]&gt;ratings[i+1]){
                candyVec[i]=max(candyVec[i],candyVec[i+1]+1);
            }
        }
        return accumulate(candyVec.begin(), candyVec.end(),0);
    }
};
</code></pre>
</details>
<h1 id="406-根据身高重建队列"><a class="header" href="#406-根据身高重建队列">406 根据身高重建队列</a></h1>
<p>假设有打乱顺序的一群人站成一个队列，数组 people
表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki]
表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people
所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj,
kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p>思路：</p>
<p>按照身高排序之后,优先按身高高的people的k来插入,后序插入节点也不会影响前面已经插入的节点,最终按照k
的规则完成了队列。 所以在按照身高从大到小排序后:
局部最优:优先按身高高的people的k来插入。插入操作过后的people满足队列属性
全局最优:最后都做完插入操作,整个队列满足题目队列属性</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) {
        auto cmp=[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)-&gt;bool{
            if(a[0]==b[0]) return a[1]&lt;b[1];
            return a[0]&gt;b[0];
        };
        sort(people.begin(),people.end(),cmp);
        vector&lt;vector&lt;int&gt;&gt; queue;
        for(int i=0;i&lt;people.size();i++){
            int position=people[i][1];
            queue.insert(queue.begin()+position, people[i]);
        }
        return queue;
    }
};
</code></pre>
</details>
<h1 id="452-最少数量的箭引爆气球"><a class="header" href="#452-最少数量的箭引爆气球">452 最少数量的箭引爆气球</a></h1>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组
points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和
xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x
处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足
xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。
弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) {
        auto cmp=[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)-&gt;bool{
            return a[0]&lt;b[0];
        };
        if(points.size()==0) return 0;
        sort(points.begin(),points.end(),cmp);
        int result=1;
        for(int i=1;i&lt;points.size();i++){
            if(points[i][0]&gt;points[i-1][1]){
                result++;
            }else{
                points[i][1]=min(points[i-1][1],points[i][1]);
            }
        }
        return result;
    }
};
</code></pre>
</details>
<h1 id="435-无重叠区间"><a class="header" href="#435-无重叠区间">435 无重叠区间</a></h1>
<p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi]
。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        auto cmp=[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)-&gt;bool{
        return a[1]&lt;b[1];
        };
        sort(intervals.begin(),intervals.end(),cmp);
        int count=1;
        int end=intervals[0][1];
        for(int i=1;i&lt;intervals.size();i++){
            if(intervals[i][0]&gt;=end){
                end=intervals[i][1];
                count++;
            }
        }
        return intervals.size()-count;
    }
};
</code></pre>
</details>
<h1 id="763-划分字母区间"><a class="header" href="#763-划分字母区间">763 划分字母区间</a></h1>
<p>给你一个字符串 s
。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s
。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; partitionLabels(string s) {
        int hash[27]{};
        for(int i=0;i&lt;s.size();i++){
            hash[s[i]-'a']=i;
        }
        vector&lt;int&gt; result;
        int left=0,right=0;
        for(int i=0;i&lt;s.size();i++){
            right=max(right,hash[s[i]-'a']);
            if(i==right){
                result.push_back(right-left+1);
                left=i+1;
            }
        }
        return result;
    }
};
</code></pre>
</details>
<h1 id="56-合并区间"><a class="header" href="#56-合并区间">56 合并区间</a></h1>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] =
[starti, endi] 。请你合并所有重叠的区间，并返回
一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        auto cmp=[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)-&gt;bool{
            return a[0]&lt;b[0];
        };
        sort(intervals.begin(),intervals.end(),cmp);
        auto left=intervals[0][0];
        auto right=intervals[0][1];
        vector&lt;vector&lt;int&gt;&gt; result;
        for(int i=1;i&lt;intervals.size();i++){
            if(intervals[i][0]&gt;right){
                result.push_back({left,right});
                left=intervals[i][0];
                right=intervals[i][1];
            }
            right=max(right,intervals[i][1]);
        }
         result.push_back({left,right});
        return result;
    }
};
</code></pre>
</details>
<h1 id="738-单调递增的数字"><a class="header" href="#738-单调递增的数字">738 单调递增的数字</a></h1>
<p>当且仅当每个相邻位数上的数字 x 和 y 满足 x 小于等于 y
时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        auto num=to_string(n);
        int flag=num.size();
        for(int i=num.size()-1;i&gt;0;i--){
            if(num[i-1]&gt;num[i]){
                flag=i;
                num[i-1]--;
            }
        }
        for(int i=flag;i&lt;num.size();i++){
            num[i]='9';
        }
        return stoi(num);
    }
};
</code></pre>
</details>
<h1 id="968-监控二叉树"><a class="header" href="#968-监控二叉树">968 监控二叉树</a></h1>
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p>所以我们要从下往上看,局部最优:让叶子节点的父节点安摄像头,所用摄像头最少,整体最优:全部摄像头数量
所用最少!</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
    int result=0;
    int traversal(TreeNode *cur){
        if(!cur) return 2;
        int left=traversal(cur-&gt;left);
        int right=traversal(cur-&gt;right);
        if(left==2&amp;&amp;right==2) return 0;
        else if(left==0||right==0){
            result++;
            return 1;
        }else return 2;
    }
public:
    int minCameraCover(TreeNode* root) {
        if(traversal(root)==0){//root无覆盖
            result++;
        }
        return result;
    }
};
</code></pre>
</details>
<h1 id="455-分发饼干"><a class="header" href="#455-分发饼干">455 分发饼干</a></h1>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值
g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干
j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j
分配给孩子 i
，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        int ans=0;
        ranges::sort(g);
        ranges::sort(s);
        int m=g.size();
        int n=s.size();
        for(int i=0,j=0;i&lt;m&amp;&amp;j&lt;n;i++,j++){
            while(j&lt;n&amp;&amp;g[i]&gt;s[j]){
                j++;
            }
            if(j&lt;n) ans++;
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="871-最低加油次数"><a class="header" href="#871-最低加油次数">871 最低加油次数</a></h1>
<p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。</p>
<p>沿途有加油站，用数组 stations 表示。其中 stations[i] = [positioni,
fueli] 表示第 i 个加油站位于出发位置东面 positioni 英里处，并且有 fueli
升汽油。</p>
<p>假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1
英里就会用掉 1
升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>
<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回
-1 。</p>
<p>注意：如果汽车到达加油站时剩余燃料为
0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为
0，仍然认为它已经到达目的地。</p>
<p>思路：</p>
<p>当汽车行驶到第 i 个加油站时，视作获取了一个装有 fueli升汽油的油桶。</p>
<p>在后续的行驶过程中，可以在没油时，把油桶中的油加到汽车中。</p>
<p>选哪个（哪些）油桶？</p>
<p>为了让加油次数尽量少，贪心地选油量多的油桶。</p>
<p>由于有添加和删除操作，用最大堆维护这些油桶。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) {
        stations.push_back({target,0});
        int ans=0,pre_position=0,cur_fuel=startFuel;
        priority_queue&lt;int&gt; fuel_heap;
        for(auto&amp; station:stations){
            int position=station[0];
            cur_fuel-=(position-pre_position);
            while(!fuel_heap.empty()&amp;&amp;cur_fuel&lt;0){
                cur_fuel+=fuel_heap.top();
                fuel_heap.pop();
                ans++;
            }
            if(cur_fuel&lt;0){
                return -1;
            }
            fuel_heap.push(station[1]);
            pre_position=position;
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="1090-受标签影响的最大值"><a class="header" href="#1090-受标签影响的最大值">1090 受标签影响的最大值</a></h1>
<p>以两个整数数组 values 和 labels 给定 n 个项的值和标签，并且给出两个整数
numWanted 和 useLimit 。</p>
<p>你的任务是从这些项中找到一个值的和 最大 的子集使得：</p>
<pre><code>项的数量 最多 为 numWanted。
相同标签的项的数量 最多 为 useLimit。
</code></pre>
<p>返回最大的和。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int numWanted, int useLimit) {
        int n=values.size();
        vector&lt;pair&lt;int,int&gt;&gt; pairs(n);
        for(int i=0;i&lt;n;++i){
            pairs[i]={-values[i],labels[i]};
        }
        sort(pairs.begin(),pairs.end());
        unordered_map&lt;int,int&gt; cnt;
        int ans=0,num=0;
        for(int i=0;i&lt;n&amp;&amp;num&lt;numWanted;i++){
            int v=-pairs[i].first,l=pairs[i].second;
            if(cnt[l]&lt;useLimit){
                ++cnt[l];
                ++num;
                ans+=v;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="3255-长度为k的子数组的能量值2"><a class="header" href="#3255-长度为k的子数组的能量值2">3255 长度为k的子数组的能量值2</a></h1>
<p>给你一个长度为 n 的整数数组 nums 和一个正整数 k 。</p>
<p>一个数组的 能量值 定义为：</p>
<pre><code>如果 所有 元素都是依次 连续 且 上升 的，那么能量值为 最大 的元素。
否则为 -1 。
</code></pre>
<p>你需要求出 nums 中所有长度为 k 的 子数组 的能量值。</p>
<p>请你返回一个长度为 n - k + 1 的整数数组 results ，其中 results[i]
是子数组 nums[i..(i + k - 1)] 的能量值。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; resultsArray(vector&lt;int&gt;&amp; nums, int k) {
        vector&lt;int&gt; ans(nums.size()-k+1,-1);
        int cnt=0;
        for(int i=0;i&lt;nums.size();i++){
            cnt=i==0||nums[i]==nums[i-1]+1?cnt+1:1;
            if(cnt&gt;=k){
                ans[i-k+1]=nums[i];
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="unsolved-2071-你可以安排的最多任务数目"><a class="header" href="#unsolved-2071-你可以安排的最多任务数目">UNSOLVED 2071 你可以安排的最多任务数目</a></h1>
<p>给你 n 个任务和 m
个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0
开始的整数数组 tasks 中，第 i 个任务需要 tasks[i]
的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers
中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个
任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] &gt;=
tasks[i] ）。</p>
<p>除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength
。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。</p>
<p>给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和
strength ，请你返回 最多 有多少个任务可以被完成。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int maxTaskAssign(vector&lt;int&gt;&amp; tasks, vector&lt;int&gt;&amp; workers, int pills, int strength) {
        int n=tasks.size(),m=workers.size();
        ranges::sort(tasks);
        ranges::sort(workers);
        auto check=[&amp;](int mid)-&gt;bool{
            int p=pills;
            multiset&lt;int&gt; ws;
            for(int i=m-mid;i&lt;m;i++){
                ws.insert(workers[i]);
            }
            for(int i=mid-1;i&gt;=0;i--){
                if(auto it=prev(ws.end());*it&gt;=tasks[i]){
                    ws.erase(it);
                }else{
                    if(!p){
                        return false;
                    }
                    auto rep=ws.lower_bound(tasks[i]-strength);
                    if(rep==ws.end()){
                        return false;
                    }
                    --p;
                    ws.erase(rep);
                }
            }
            return true;
        };
        int left=1,right=min(m,n),ans=0;
        while(left&lt;=right){
            int mid=(left+right)/2;
            if(check(mid)){
                ans=mid;
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="658-找到k个最接近的元素"><a class="header" href="#658-找到k个最接近的元素">658 找到K个最接近的元素</a></h1>
<p>给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近
x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。</p>
<p>整数 a 比整数 b 更接近 x 需要满足：</p>
<pre><code>|a - x| &lt; |b - x| 或者
|a - x| == |b - x| 且 a &lt; b
</code></pre>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
 public:
  vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) {
     ranges::sort(arr,[&amp;](int a,int b){
        return abs(a-x)==abs(b-x)?
        a&lt;b:
        abs(a-x)&lt;abs(b-x);
     });
     sort(arr.begin(),arr.begin()+k);
     return vector(arr.begin(),arr.begin()+k);
  }
};
</code></pre>
</details>
<h1 id="632-最小区间"><a class="header" href="#632-最小区间">632 最小区间</a></h1>
<p>你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k
个列表中的每个列表至少有一个数包含在其中。</p>
<p>我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比
[c,d] 小。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; smallestRange(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int rangeLeft=0,rangeRight=INT_MAX;
        int size=nums.size();
        vector&lt;int&gt; next(size);
        auto cmp=[&amp;](const int u,const int v){
            return nums[u][next[u]]&gt;nums[v][next[v]];
        };
        priority_queue&lt;int,vector&lt;int&gt;,decltype(cmp)&gt; pq(cmp);
        int minValue=0,maxValue=INT_MIN;
        for(int i=0;i&lt;size;i++){
            pq.emplace(i);
            maxValue=max(maxValue,nums[i][0]);
        }
        while(true){
            int row=pq.top();
            pq.pop();
            minValue=nums[row][next[row]];
            if(maxValue-minValue&lt;rangeRight-rangeLeft){
                rangeLeft=minValue;
                rangeRight=maxValue;
            }
            if(next[row]==nums[row].size()-1){
                break;
            }
            ++next[row];
            maxValue=max(maxValue,nums[row][next[row]]);
            pq.emplace(row);
        }
        return {rangeLeft,rangeRight};
    }
};
</code></pre>
</details>
<h1 id="409-最长回文串"><a class="header" href="#409-最长回文串">409 最长回文串</a></h1>
<p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的
最长的 回文串 的长度。</p>
<p>在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    int longestPalindrome(string s) {
        unordered_map&lt;char,int&gt; count;
        int ans=0;
        for(char c:s){
            ++count[c];
        }
        for(auto p:count){
            auto [_,v]=p;
            ans+=v/2*2;
            if(v%2==1 and ans%2==0){
                ++ans;
            }
        }
        return ans;
    }
};
</code></pre>
</details>
<h1 id="410-分割数组的最大值"><a class="header" href="#410-分割数组的最大值">410 分割数组的最大值</a></h1>
<p>给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k
个非空的连续子数组，使得这 k 个子数组各自和的最大值 最小。</p>
<p>返回分割后最小的和的最大值。</p>
<p>子数组 是数组中连续的部份。</p>
<details><summary>Click to expand</summary>
<pre><code class="language-cpp">class Solution {
public:
    bool check(vector&lt;int&gt;&amp; nums,int x,int m){
        long long sum=0;
        int cnt=1;
        for(int i=0;i&lt;nums.size();i++){
            if(nums[i]+sum&gt;x){
                cnt++;
                sum=nums[i];
            }else{
                sum+=nums[i];
            }
        }
        return cnt&lt;=m;
    }
    int splitArray(vector&lt;int&gt;&amp; nums, int k) {
        long long left=0,right=0;
        for(int i=0;i&lt;nums.size();i++){
            right+=nums[i];
            if(left&lt;nums[i]){
                left=nums[i];
            }
        }
        while(left&lt;right){
            long long mid=(left+right)&gt;&gt;1;
            if(check(nums,mid,k)){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
};
</code></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../数据结构与算法/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../数据结构与算法/dp.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../数据结构与算法/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../数据结构与算法/dp.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
