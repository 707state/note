<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Overview &amp; Memtable - 学习笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFlsm-tree">什么是LSM Tree?</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AAlsm-storage-engine">一个LSM Storage
Engine</a></li>
</ul>
</li>
<li><a href="#mem-tables">Mem Tables</a>
<ul>
<li><a href="#%E7%94%A8skiplist%E5%AE%9E%E7%8E%B0mem-table">用SkipList实现Mem
Table</a></li>
<li><a href="#%E4%B8%80%E4%B8%AAmemtable%E7%9A%84%E5%AE%9E%E7%8E%B0">一个MemTable的实现</a></li>
<li><a href="#%E5%86%BB%E7%BB%93%E4%B8%80%E4%B8%AAmemtable">冻结一个MemTable</a>
<ul>
<li><a href="#leveled-compaction-%E5%88%86%E5%B1%82%E5%8E%8B%E7%BC%A9">Leveled Compaction
分层压缩</a></li>
<li><a href="#tiered-compaction-%E5%88%86%E7%BA%A7%E5%8E%8B%E7%BC%A9">Tiered Compaction
分级压缩</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E9%A2%98">一些思考题</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88mem-table%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAdelete-api">为什么Mem Table不需要一个delete
API?</a></li>
<li><a href="#memtable%E8%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E9%99%A4%E4%BA%86skiplist%E4%B9%8B%E5%A4%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Memtable能不能用除了SkipList之外的数据结构？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="什么是lsm-tree"><a class="header" href="#什么是lsm-tree">什么是LSM Tree?</a></h1>
<p>Log-Structured Merge Tree,
是一种分层，有序，面向磁盘的数据结构，其核心思想是充分了利用了，磁盘批量的顺序写要远比随机写性能高出很多。</p>
<p>相对于RB-Tree, B-Tree, 所有的修改操作都是惰性的。</p>
<p>LSM-Tree对于以下情况非常适用：</p>
<ol>
<li>
<p>数据在持久化存储上是不可变的，这使得并发控制更加简单。可以将后台任务（如压缩操作）卸载到远程服务器执行。直接从云原生存储系统（如
S3）中存储和服务数据也是可行的。</p>
</li>
<li>
<p>更改压缩算法可以使存储引擎在读取、写入和空间放大之间找到平衡。LSM
树结构非常灵活，通过调整压缩参数，我们可以针对不同的工作负载优化 LSM
结构。</p>
</li>
</ol>
<h2 id="一个lsm-storage-engine"><a class="header" href="#一个lsm-storage-engine">一个LSM Storage Engine</a></h2>
<ol>
<li>
<p>WAL日志机制，用来做数据持久化。</p>
</li>
<li>
<p>硬盘上的SST(Sorted String Tables)，用来保持LSM Tree的结构。</p>
</li>
<li>
<p>Mem-Tables。是驻留在内存中的数据结构，用于暂存小的写入操作。小写入会被批量写入
Mem-table，等 Mem-table 满了后再刷新到磁盘生成新的 SST
文件。这种方式可以提高写入性能并减少磁盘 I/O 开销。</p>
</li>
</ol>
<p>通常要提供以下操作：</p>
<ol>
<li>
<p>Put(Key, Value);</p>
</li>
<li>
<p>Delete(Key);</p>
</li>
<li>
<p>Get(Key);</p>
</li>
<li>
<p>Scan(Range);</p>
</li>
</ol>
<p>为了处理持久化，通常还会有:</p>
<p>Sync()，用来保存sync之前的所有操作都落盘。</p>
<h1 id="mem-tables"><a class="header" href="#mem-tables">Mem Tables</a></h1>
<p>Mem Tables适用于处理Batch Write批量写的。</p>
<h2 id="用skiplist实现mem-table"><a class="header" href="#用skiplist实现mem-table">用SkipList实现Mem Table</a></h2>
<p>用cross-beam的SkipList来实现，因为cross-beam的SkipList支持无锁并发。并且都支持insert,
get和iter。</p>
<details><summary>Click to expand</summary>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MemTable {
    map: Arc&lt;SkipMap&lt;Bytes, Bytes&gt;&gt;,
    wal: Option&lt;Wal&gt;,
    id: usize,
    approximate_size: Arc&lt;AtomicUsize&gt;,
}
<span class="boring">}</span></code></pre></pre>
</details>
这是MemTable的结构体。需要实现get和delete方法。
<details><summary>Click to expand</summary>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Get a value by key.
    pub fn get(&amp;self, key: &amp;[u8]) -&gt; Option&lt;Bytes&gt; {
        self.map.get(key).map(|e| e.value().clone())
    }
<span class="boring">}</span></code></pre></pre>
</details>
<p>get通过在SkipMap中寻找key来获取对应的值。</p>
<details><summary>Click to expand</summary>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn put(&amp;self, key: &amp;[u8], value: &amp;[u8]) -&gt; Result&lt;()&gt; {
        //预估总长度
        let estimated_size = key.len() + value.len();
        //向SkipMap中插入键值对
        self.map
            .insert(Bytes::copy_from_slice(key), Bytes::copy_from_slice(value));
        //原子变量执行原子操作
        self.approximate_size
            .fetch_add(estimated_size, std::sync::atomic::Ordering::Relaxed);
        // WAL需要放入，实际上应该先做WAL
        if let Some(ref wal) = self.wal {
            wal.put(key, value)?;
        }
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
</details>
这是put方法的实现，要放入一个键值对到SkipMap中，并且为后面的WAL做准备。
<p>注意，Mem
Table不提供delete方法，在这里如果一个键对应的值是空的就视为被删除了。</p>
<h2 id="一个memtable的实现"><a class="header" href="#一个memtable的实现">一个MemTable的实现</a></h2>
<details><summary>Click to expand</summary>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Represents the state of the storage engine.
#[derive(Clone)]
pub struct LsmStorageState {
    /// The current memtable.
    pub memtable: Arc&lt;MemTable&gt;,
    /// Immutable memtables, from latest to earliest.
    pub imm_memtables: Vec&lt;Arc&lt;MemTable&gt;&gt;,
    /// L0 SSTs, from latest to earliest.
    pub l0_sstables: Vec&lt;usize&gt;,
    /// SsTables sorted by key range; L1 - L_max for leveled compaction, or tiers for tiered
    /// compaction.
    pub levels: Vec&lt;(usize, Vec&lt;usize&gt;)&gt;,
    /// SST objects.
    pub sstables: HashMap&lt;usize, Arc&lt;SsTable&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
</details>
表示存储引擎的状态，在任何时刻，引擎中只能由一个可变的MemTable。当一个MemTable达到存储上限的时候就会被冻结为一个不可变的MemTable。
<p>在lsm_storage.rs中有两个表示存储引擎的结构：MiniLSM和LsmStorageInner。MiniLSM是对于LsmStorageInner的一层封装。</p>
<p>LsmStorageInner存储了当前的LSM存储引擎的结构。需要在LsmStorageInner中实现get,
put和delete方法</p>
<h2 id="冻结一个memtable"><a class="header" href="#冻结一个memtable">冻结一个MemTable</a></h2>
<p>当一个MemTable的容量达到上限的时候就要把这个MemTable冻结起来。</p>
<p>在这里需要实现一个freeze_memtable的函数，这里有一些会造成性能问题的操作需要<a href="https://skyzh.github.io/mini-lsm/week1-01-memtable.html">注意</a>。</p>
<p>注意看第三部分，里面解释了freeze_memtable的合适做法。</p>
<h3 id="leveled-compaction-分层压缩"><a class="header" href="#leveled-compaction-分层压缩">Leveled Compaction 分层压缩</a></h3>
<details> 
<summary>展开查看</summary>
<p>广泛应用于分布式数据库（如 RocksDB 和
LevelDB）。这种策略通过将数据分层组织并压缩，优化了查询性能和存储空间利用率。</p>
<p>LSM Tree的基本结构：</p>
<p>在 LSM
树中，数据首先写入内存表（memtable），然后定期刷新到磁盘，形成不可变的文件（称为
SSTable）。这些文件按照不同的层次组织，每一层存储一定范围的数据。</p>
<p>Leveled Compaction的核心思想：</p>
<p>将数据组织成多层（Levels），每一层具有以下特性：</p>
<ol>
<li>
<p>分层结构：从L0到Ln层级逐渐增加。</p>
</li>
<li>
<p>层的大小递增：每一层的存储容量比上一层更大，通常是上一层的 10 倍。</p>
</li>
<li>
<p>数据范围无重叠：L0
层的数据可能有重叠，因为它直接存储从内存刷盘的多个 SSTable 文件；L1
及以上，每个 SSTable 文件存储的数据范围不重叠，便于快速定位。</p>
</li>
</ol>
<p>数据流动的过程：</p>
<p>写入L0: 数据首先写入内存（memtable），然后刷新到磁盘生成 L0 层的
SSTable。</p>
<p>L0到L1的压缩: 当 L0 层文件数量超过阈值（比如 4
个文件），触发压缩操作；将 L0 中的所有文件与 L1
中的文件进行合并，写入新的 L1 文件，确保 L1 中的数据范围不重叠。</p>
<p>更高层次的压缩: 当 L1 的大小超过限制，触发向 L2
层的压缩；同样遵循合并并去重的逻辑，确保 L2
中的数据范围不重叠；这种过程会依次向更高层流动。</p>
<h4 id="优点"><a class="header" href="#优点">优点</a></h4>
<p>高效的点查询：从 L1
层开始，各层的文件之间数据范围不重叠，可以通过范围查找快速定位目标
SSTable；性能比Size-Tiered Compaction更好。</p>
<p>压缩节省空间：每次压缩会移除重复数据，确保存储效率。</p>
<p>适合读密集的场景：由于数据范围清晰，适合有大量点查询或者范围查询的场景。</p>
<h4 id="缺点"><a class="header" href="#缺点">缺点</a></h4>
<p>高压缩成本：压缩需要将多个文件合并成一个文件；对写入性能有一定影响。</p>
<p>高存储抖动：在压缩过程中，大量数据被压缩。</p>
</details>
<blockquote>
<p>具体资料可见<a href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">RocksDB
Wiki</a></p>
</blockquote>
<h3 id="tiered-compaction-分级压缩"><a class="header" href="#tiered-compaction-分级压缩">Tiered Compaction 分级压缩</a></h3>
<details>
<summary>具体信息</summary>
<p>与 Leveled Compaction 不同，Tiered Compaction
优先优化写入性能，通过将小文件简单归并，减少写入阻塞。它通常用于写密集型工作负载，比如日志存储或批量写入的场景。</p>
<p>核心概念：在 Tiered Compaction
中，数据分为多个层（Tiers），每一层都包含一组 SSTable
文件。这些文件内的数据范围可以重叠，层与层之间也可能有重叠。Tiered
Compaction 的压缩操作是基于文件数量而不是数据范围重叠触发的。</p>
<p>数据流动的过程：</p>
<p>写入数据到内存：</p>
<ol>
<li>
<p>新数据首先写入内存；memtable满了之后，刷盘生成一个新的SSTable，这些文件直接写入L0。</p>
</li>
<li>
<p>L0层的文件合并，当 L0 层的文件数量超过预设的阈值（如 4
个文件），触发压缩操作。压缩的方式是将这些文件简单合并，生成更大的文件，写入下一层（L1
层）。L1 层的文件通常存储更多数据，其大小和数量的阈值也更高。</p>
</li>
<li>
<p>当某一层的文件数量超过阈值时，这些文件会被合并为更大的文件并移到下一层；合并时只是将文件归并到一起，不一定消除重复数据，也不保证数据范围不重叠。</p>
</li>
</ol>
<h4 id="优点-1"><a class="header" href="#优点-1">优点</a></h4>
<p>高写入性能：Tiered Compaction
避免了频繁的合并和去重操作，写入过程简单高效。写密集型的场景中，可以显著减少写阻塞。</p>
<p>实现简单：不需要维护分割的逻辑，只要根据文件数量就可以压缩。</p>
<h4 id="缺点-1"><a class="header" href="#缺点-1">缺点</a></h4>
<p>查询效率低：因为文件和层之间可能有重叠，点查询或范围查询时需要检查更多的
SSTable 文件。随着层数增加，文件数量可能显著增多，查询成本上升。</p>
<p>空间利用率低：重复文件的压缩。</p>
<p>读放大效应：由于需要扫描多个文件才能找到目标数据，读放大现象（读取无关数据的比例）更加明显。</p>
<h4 id="适用场景"><a class="header" href="#适用场景">适用场景</a></h4>
<p>Tiered Compaction 更适合 写密集型 场景，如：</p>
<pre><code>日志存储（Log Store）：需要快速写入大量日志数据。
数据流处理：实时接收和存储大量数据。
数据备份：批量导入数据的情况。
</code></pre>
<p>不适合查询密集型场景，因为查询效率较低。</p>
</details>
<blockquote>
<p><a href="https://opensource.docs.scylladb.com/stable/architecture/compaction/compaction-strategies.html">不同压缩算法之间的比较</a></p>
</blockquote>
<h2 id="一些思考题"><a class="header" href="#一些思考题">一些思考题</a></h2>
<h3 id="为什么mem-table不需要一个delete-api"><a class="header" href="#为什么mem-table不需要一个delete-api">为什么Mem Table不需要一个delete API?</a></h3>
<p>LSM
Tree的核心思想是追加写入，所有数据的修改都是通过追加写入的方式实现的。</p>
<p>删除操作不会真的从mem
table中添加或者在磁盘中删除，而是通过一个特殊标记（通常叫做tombstone）来实现逻辑上的删除。</p>
<h3 id="memtable能不能用除了skiplist之外的数据结构"><a class="header" href="#memtable能不能用除了skiplist之外的数据结构">Memtable能不能用除了SkipList之外的数据结构？</a></h3>
<p>当然可以，B-Tree或者RB Tree甚至哈希表都没问题。</p>
<p>SkipList优点：</p>
<p>简单且高效的实现
跳表是通过多层链表实现的，结构简单，代码易于实现，插入和删除操作相对直观。
时间复杂度接近于平衡树，通常为 O(log⁡n)O(logn)。</p>
<p>顺序存储，支持范围查询 跳表的本质是有序的，能够高效支持范围查询（Range
Query），这是 LSM 树的重要需求之一。 例如：在查询 [key1, key2]
范围内的所有数据时，可以从 key1 开始沿链表逐步查找，直到 key2。</p>
<p>并发支持较好
跳表在设计上天然支持分层，允许更高效的并发控制。通过对不同层加锁，可以实现高效的多线程读写。</p>
<p>内存管理友好
跳表的节点是链表形式，支持按需动态分配内存。相比需要预分配大量内存的哈希表，它的内存使用更加灵活。</p>
<p>缺点：</p>
<p>随机访问性能逊色</p>
<pre><code>跳表的查找性能虽然接近于 O(log⁡n)O(logn)，但由于需要依赖链表的逐节点跳转，其常数时间成本高于树结构。
</code></pre>
<p>内存使用较高</p>
<pre><code>跳表需要为每个节点维护多层索引，额外的指针占用会增加内存开销。对于大规模数据，内存使用可能成为瓶颈。
</code></pre>
<p>不支持快速点查（点查询）</p>
<pre><code>相比哈希表，跳表无法快速查找到某个键的值。对于以点查询为主的场景，性能可能不足。
</code></pre>
<p>实现复杂性随着优化增加</p>
<pre><code>基础跳表简单，但为了支持并发或更高性能，通常需要增加锁机制或实现无锁设计，这会显著提高实现复杂性。
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../LSM-Tree/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../LSM-Tree/LSMTree2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../LSM-Tree/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../LSM-Tree/LSMTree2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
