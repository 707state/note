---
title: "数据库并发"
author: "jask"
date: "2024-08-11"
output: pdf_document
header-includes:
  - \usepackage{xeCJK}
  - \setCJKmainfont{Noto Sans CJK SC}  # 替换为可用的字体
  - \setCJKmonofont{Noto Sans CJK SC}
  - \setCJKsansfont{Noto Sans CJK SC}
---

# 并发控制
## 2PL， 可串行性，可恢复性
1.当一个调度冲突等价于某个串行调度时，我们称这个调度为冲突可串行。  
2.一个调度S的优先图：对于S中的每个提交事务用一个节点表示；如果$T_i$先执行，并且和$T_i$的某个操作发生冲突，就应存在一条从$T_i$到$T_i$的边。  
3.两个结果：调度S是冲突可串行的，当且仅当起优先图中不存在回路；严格的2PL保证所有调度的优先图中都不包含回路。  

### 观测可串行化
当具有相同事务集合的两个调度S1和S2满足：
如果T_i在S1中读对象A的初始值，那么T_i在S2也必须读对象A的初始值；
如果在S1中T_i读的是T_j写入对象A的值，那么在S2中T_i也必须写入T_j写入的值；
对于一个数据对象A, 如果在S1中最后一次执行了A的写操作，S2也必须。

## 加锁管理
DBMS中处理事务加锁事项的部分叫做Lock Manager。每个Lock Manager维护一个锁表，这是一个以数据对象标识为码的哈希表。

### 加锁解锁
按照2PL,事务T读写对象A之前，必须获得A的共享/互斥锁，并把它保持到最终提交或者终止。
当事务需要某个对象的锁时，需要将请求提交给锁管理器。

若为共享锁，当前请求队列为空，且该对象没有处于互斥锁状态时，锁管理器将同意加锁请求，并更新该对象的相应锁表数据项。

若为互斥锁，并且没有事务拥有当前对象的锁，就同意加锁请求并更新该对象的锁。

事务中止或者提交时，会释放自己拥有的锁。当某个对象的锁被释放时，锁管理器更新相应的锁表数据项，并检查该对象的加锁请求队列。如果请求能被接受，请求锁的事务将被唤醒并得到锁。

加锁/解锁命令必须实现为原子操作。

## 锁转换
数据可能需要对已经获得共享锁的对象再请求排他锁。如果没有其他事务拥有该对象的共享锁，可以立即对事务的锁进行升级满足互斥锁请求。

### 死锁处理
1.使用等待图来检测死锁循环。
锁管理器在将加锁请求加到等待队列中时，向图里加一个边，满足加锁请求就删一条。
2.使用超时机制
如果事务Ti请求事务Tj拥有的锁，并发生了冲突，有两条策略：
等待-死亡：如果Ti的优先权高就等待Tj结束，否则立即终止Ti。  
受伤-等待：如果Ti优先权高，终止Tj,否则Ti等待。  
等待死亡是非抢占的，只有正在请求获得锁的事务会被终止，当事务变老，会可能去等待越来越多的年轻事务。  
等待受伤策略中，一个年轻事务和老事务发生冲突，可能被反复终止（一个具有所需要的锁的事务不会因为死锁的远古而被中止）。

## 不加锁的并发控制

### 乐观的并发控制
前提：大多数事务不会和其他事务发生冲突。  
思想是尽可能地允许事务执行。  
每个事务Ti的验证阶段的开始得到一个时间戳TS,并且验证时检查事务的时间戳顺序是否和事务的串行顺序相同。对于任意的TS(Ti)<TS(Tj)的两个事务Ti和Tj,要满足三个条件之一：
1.Ti必须在Tj开始执行之前就已经结束所有三个阶段；
2.Ti必须在Tj开始执行写阶段之前就已经结束，并且Ti没有写Tj读的数据对象；
3.Ti在Tj结束读阶段前已经完成了自己的读阶段，并且不写任何Tj读或者写的数据对象。

### 基于时间戳的并发控制
给每个数据库对象给定一个读时间戳RTS(O)和一个写时间戳WTS(O)。如果事务T希望读对象O,并且TS(T)<WTS(O)，那么这个读操作和最近的写操作见的顺序违反了事务T和写对象O的事务间的时间戳顺序。因此需要中止T,再赋予一个新的更大的时间戳重新启动。如果TS(T)>WTS(O)，T可以读O，并且RTS(O)的值设成原来的RTS(O)和TS(T)之间的较大者。  
如果T重新启动时仍具有和原来相同的时间戳，他会由于同样的冲突再次中止。


当事务T希望写对象O时：
1.如果TS(T)<RTS(O)，写操作和对象O最近的读操作发生冲突，因此要中止并重启事务T。
2.如果TS(T)<WTS(O)，由于写操作和对象O最近的写操作发生冲突，因而违反了时间戳顺序，简单的方法是中止T。
3.否则T写对象O,并且WTS(O)设为TS(T)。

### MVCC
对于每个数据对象维护具有不同写时间戳的若干版本，并允许事务Ti读取时间戳在TS(Ti)之前、最新的版本。
  
如果事务Ti希望写一个对象，我们必须保证该对象没有被满足TS(Ti)<TS(Tj)的事务Tj读过。如果当TS(Ti)<TS(Tj)时，我们允许Ti写Tj读过的对象，并且Ti的更新结果对Tj可见。

每个对象都必须具有一个读时间戳，当一个事务读到某个对象是，要对读时间戳和事务的时间戳进行比较并将读时间戳更新为较大的那个。如果Ti希望写对象O并且TS(Ti)<RTS(O)，Ti将被中止并重新启动，并重新获得新的较大的时间戳；否则Ti创建O的一个新版本，并肩新版本的读写时间戳的值设定为TS(Ti)。

## 复习

### 加锁/解锁为什么必须是原子操作
1.避免竞争条件（Race Condition）
    竞争条件是指多个线程或进程同时访问和修改共享资源时，导致最终结果不可预测的情况。如果加锁/解锁操作不是原子性的，多个线程可能会在检测和设置锁的过程中发生交叉，导致两个或多个线程同时认为自己获得了锁。这会破坏锁的互斥性，从而引发竞争条件，导致数据的不一致或崩溃。

2. 确保互斥性（Mutual Exclusion）

    锁的主要作用是保证互斥性，即在同一时间内，只有一个线程能够访问共享资源。为了实现这一点，加锁操作必须是原子性的。如果加锁操作在中途被中断，其他线程可能会错误地认为锁尚未被占用，从而也尝试访问资源。这将导致多个线程同时访问同一个资源，违反了互斥性。

3. 防止死锁（Deadlock）

    如果解锁操作不是原子性的，一个线程可能在部分完成解锁操作后被切换出 CPU 时间片，另一个线程可能会错误地尝试获取或释放同一个锁。这可能导致死锁，尤其是在复杂的锁依赖关系中。

4. 保证一致性和数据完整性

    在并发编程中，锁的使用通常用于保护共享数据的访问。加锁操作必须确保在整个操作过程中，只有持有锁的线程能够访问或修改共享数据。如果加锁/解锁操作不是原子性的，数据的一致性和完整性将无法得到保证，可能会出现数据损坏或不一致的情况。

5. 系统调用的原子性

    在多线程编程中，操作系统提供的加锁/解锁机制（如 pthread_mutex_lock 或 std::mutex）通常是通过硬件或底层系统调用实现的，这些调用保证了锁操作的原子性。如果锁操作不是原子性的，系统无法提供对共享资源的有效保护。

6. 性能考虑

    虽然性能不是原子性要求的主要原因，但原子操作通常比手动实现的复杂加锁机制更高效，因为它们可以直接在硬件层面上完成（如通过 CPU 指令集中的 test-and-set、compare-and-swap 等指令）。这有助于减少锁争用时的开销，提高系统的并发性能。

### 锁(Lock)和栓(Latch)有什么区别
锁（Lock）

锁是一种用于协调多个线程对共享资源（如内存中的变量、文件等）访问的机制。锁确保在同一时间只有一个线程可以访问共享资源，防止竞态条件（race condition）和数据不一致。

    使用场景: 锁用于控制对共享资源的访问，确保多个线程或进程不会同时修改同一个数据。这在保护临界区（critical section）中至关重要。

    特性:
        可重入性: 一些锁（如C++中的std::recursive_mutex）允许同一线程多次获得同一个锁而不会死锁。
        超时: 某些锁允许设置超时，如果一个线程在一定时间内无法获得锁，就会返回失败。
        公平性: 一些锁可以配置为公平锁，确保线程按照请求的顺序获得锁。
        阻塞行为: 当一个线程尝试获取一个已被其他线程持有的锁时，它会被阻塞，直到锁被释放。

    示例: 在多线程编程中，std::mutex是一个典型的锁，用于保护共享资源的访问。

拴（Latch）

拴（Latch）通常是用来实现一次性或短期的同步操作。与锁不同，拴的生命周期通常较短，且拴的状态一旦被触发（即从一个状态转换到另一个状态），通常就不会再回退。

    使用场景: 拴常用于协调线程在程序的某个阶段或操作上达到某种条件时的同步。例如，在多个线程同时准备好之后才一起执行某个任务，或等待某个操作的完成。

    特性:
        一次性状态转换: 拴通常是一次性的。比如一个CountDownLatch在计数降为零后，所有等待的线程都会被释放，而计数不会再增加。
        没有锁住的资源: 拴通常不用于保护共享资源，而是用于管理线程的执行顺序或等待条件。
        不可重入: 一般来说，拴不具备重入性，因为它们是用来在特定条件下触发事件的。

    示例: (c++20)std::latch和std::counting_semaphore是C++中的常见拴类，用于在多线程中实现同步和条件等待。

锁和拴的区别

    功能和用途:
        锁用于控制对共享资源的访问，确保线程安全。
        拴用于线程的协调和同步，确保某些条件满足时线程才能继续执行。

    生命周期:
        锁的生命周期通常较长，直到共享资源的保护不再需要为止。
        拴的生命周期通常较短，通常在特定条件满足或事件发生后就结束。

    状态变化:
        锁的状态可以反复变化（加锁和解锁）。
        拴的状态通常只发生一次变化（从未触发到触发）。

    复杂性:
        锁的实现和使用通常更复杂，需要小心管理以避免死锁等问题。
        拴的使用相对简单，主要用于同步点的管理。
